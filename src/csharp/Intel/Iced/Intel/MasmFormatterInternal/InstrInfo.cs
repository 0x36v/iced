/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#if !NO_MASM_FORMATTER && !NO_FORMATTER
using System;
using System.Diagnostics;

namespace Iced.Intel.MasmFormatterInternal {
	// GENERATOR-BEGIN: InstrOpKind
	// ⚠️This was generated by GENERATOR!🦹‍♂️
	enum InstrOpKind : byte {
		Register,
		NearBranch16,
		NearBranch32,
		NearBranch64,
		FarBranch16,
		FarBranch32,
		Immediate8,
		Immediate8_2nd,
		Immediate16,
		Immediate32,
		Immediate64,
		Immediate8to16,
		Immediate8to32,
		Immediate8to64,
		Immediate32to64,
		MemorySegSI,
		MemorySegESI,
		MemorySegRSI,
		MemorySegDI,
		MemorySegEDI,
		MemorySegRDI,
		MemoryESDI,
		MemoryESEDI,
		MemoryESRDI,
		Memory64,
		Memory,
		ExtraImmediate8_Value3,
		DeclareByte,
		DeclareWord,
		DeclareDword,
		DeclareQword,
	}
	// GENERATOR-END: InstrOpKind

	struct InstrOpInfo {
		internal const int TEST_RegisterBits = IcedConstants.RegisterBits;

		public string Mnemonic;
		public InstrOpInfoFlags Flags;
		public byte OpCount;
		public InstrOpKind Op0Kind;
		public InstrOpKind Op1Kind;
		public InstrOpKind Op2Kind;
		public InstrOpKind Op3Kind;
		public InstrOpKind Op4Kind;
		public byte Op0Register;
		public byte Op1Register;
		public byte Op2Register;
		public byte Op3Register;
		public byte Op4Register;
		public sbyte Op0Index;
		public sbyte Op1Index;
		public sbyte Op2Index;
		public sbyte Op3Index;
		public sbyte Op4Index;

		public readonly int GetOpRegister(int operand) => operand switch {
			0 => Op0Register,
			1 => Op1Register,
			2 => Op2Register,
			3 => Op3Register,
			4 => Op4Register,
			_ => throw new ArgumentOutOfRangeException(nameof(operand)),
		};

		public readonly InstrOpKind GetOpKind(int operand) {
			switch (operand) {
			case 0: return Op0Kind;
			case 1: return Op1Kind;
			case 2: return Op2Kind;
			case 3: return Op3Kind;
			case 4: return Op4Kind;
			default:
				Debug.Assert(Op0Kind == InstrOpKind.DeclareByte || Op0Kind == InstrOpKind.DeclareWord || Op0Kind == InstrOpKind.DeclareDword || Op0Kind == InstrOpKind.DeclareQword);
				return Op0Kind;
			}
		}

		public readonly int GetInstructionIndex(int operand) {
			int instructionOperand;
			switch (operand) {
			case 0: instructionOperand = Op0Index; break;
			case 1: instructionOperand = Op1Index; break;
			case 2: instructionOperand = Op2Index; break;
			case 3: instructionOperand = Op3Index; break;
			case 4: instructionOperand = Op4Index; break;
			default:
				Debug.Assert(Op0Kind == InstrOpKind.DeclareByte || Op0Kind == InstrOpKind.DeclareWord || Op0Kind == InstrOpKind.DeclareDword || Op0Kind == InstrOpKind.DeclareQword);
				instructionOperand = -1;
				break;
			}
			return instructionOperand < 0 ? -1 : instructionOperand;
		}

#if !NO_INSTR_INFO
		public readonly bool TryGetOpAccess(int operand, out OpAccess access) {
			int instructionOperand;
			switch (operand) {
			case 0: instructionOperand = Op0Index; break;
			case 1: instructionOperand = Op1Index; break;
			case 2: instructionOperand = Op2Index; break;
			case 3: instructionOperand = Op3Index; break;
			case 4: instructionOperand = Op4Index; break;
			default:
				Debug.Assert(Op0Kind == InstrOpKind.DeclareByte || Op0Kind == InstrOpKind.DeclareWord || Op0Kind == InstrOpKind.DeclareDword || Op0Kind == InstrOpKind.DeclareQword);
				instructionOperand = Op0Index;
				break;
			}
			if (instructionOperand < InstrInfo.OpAccess_INVALID) {
				access = (OpAccess)(-instructionOperand - 2);
				return true;
			}
			access = OpAccess.None;
			return false;
		}
#endif

		public readonly int GetOperandIndex(int instructionOperand) {
			int index;
			if (instructionOperand == Op0Index)
				index = 0;
			else if (instructionOperand == Op1Index)
				index = 1;
			else if (instructionOperand == Op2Index)
				index = 2;
			else if (instructionOperand == Op3Index)
				index = 3;
			else if (instructionOperand == Op4Index)
				index = 4;
			else
				index = -1;
			return index < OpCount ? index : -1;
		}

		public InstrOpInfo(string mnemonic, in Instruction instr, InstrOpInfoFlags flags) {
			Static.Assert(IcedConstants.MaxOpCount == 5 ? 0 : -1);
			Mnemonic = mnemonic;
			Flags = flags;
			Op0Kind = (InstrOpKind)instr.Op0Kind;
			Op1Kind = (InstrOpKind)instr.Op1Kind;
			Op2Kind = (InstrOpKind)instr.Op2Kind;
			Op3Kind = (InstrOpKind)instr.Op3Kind;
			Op4Kind = (InstrOpKind)instr.Op4Kind;
			Static.Assert(TEST_RegisterBits == 8 ? 0 : -1);
			Op0Register = (byte)instr.Op0Register;
			Static.Assert(TEST_RegisterBits == 8 ? 0 : -1);
			Op1Register = (byte)instr.Op1Register;
			Static.Assert(TEST_RegisterBits == 8 ? 0 : -1);
			Op2Register = (byte)instr.Op2Register;
			Static.Assert(TEST_RegisterBits == 8 ? 0 : -1);
			Op3Register = (byte)instr.Op3Register;
			Static.Assert(TEST_RegisterBits == 8 ? 0 : -1);
			Op4Register = (byte)instr.Op4Register;
			int opCount = instr.OpCount;
			OpCount = (byte)opCount;
			switch (opCount) {
			case 0:
				Op0Index = InstrInfo.OpAccess_INVALID;
				Op1Index = InstrInfo.OpAccess_INVALID;
				Op2Index = InstrInfo.OpAccess_INVALID;
				Op3Index = InstrInfo.OpAccess_INVALID;
				Op4Index = InstrInfo.OpAccess_INVALID;
				break;

			case 1:
				Op0Index = 0;
				Op1Index = InstrInfo.OpAccess_INVALID;
				Op2Index = InstrInfo.OpAccess_INVALID;
				Op3Index = InstrInfo.OpAccess_INVALID;
				Op4Index = InstrInfo.OpAccess_INVALID;
				break;

			case 2:
				Op0Index = 0;
				Op1Index = 1;
				Op2Index = InstrInfo.OpAccess_INVALID;
				Op3Index = InstrInfo.OpAccess_INVALID;
				Op4Index = InstrInfo.OpAccess_INVALID;
				break;

			case 3:
				Op0Index = 0;
				Op1Index = 1;
				Op2Index = 2;
				Op3Index = InstrInfo.OpAccess_INVALID;
				Op4Index = InstrInfo.OpAccess_INVALID;
				break;

			case 4:
				Op0Index = 0;
				Op1Index = 1;
				Op2Index = 2;
				Op3Index = 3;
				Op4Index = InstrInfo.OpAccess_INVALID;
				break;

			case 5:
				Op0Index = 0;
				Op1Index = 1;
				Op2Index = 2;
				Op3Index = 3;
				Op4Index = 4;
				break;

			default:
				throw new InvalidOperationException();
			}
		}
	}

	abstract class InstrInfo {
		public const int OpAccess_INVALID = -1;
#if !NO_INSTR_INFO
		public const int OpAccess_None = -(int)(OpAccess.None + 2);
		public const int OpAccess_Read = -(int)(OpAccess.Read + 2);
		public const int OpAccess_CondRead = -(int)(OpAccess.CondRead + 2);
		public const int OpAccess_Write = -(int)(OpAccess.Write + 2);
		public const int OpAccess_CondWrite = -(int)(OpAccess.CondWrite + 2);
		public const int OpAccess_ReadWrite = -(int)(OpAccess.ReadWrite + 2);
		public const int OpAccess_ReadCondWrite = -(int)(OpAccess.ReadCondWrite + 2);
		public const int OpAccess_NoMemAccess = -(int)(OpAccess.NoMemAccess + 2);
#else
		public const int OpAccess_None = OpAccess_INVALID;
		public const int OpAccess_Read = OpAccess_INVALID;
		public const int OpAccess_CondRead = OpAccess_INVALID;
		public const int OpAccess_Write = OpAccess_INVALID;
		public const int OpAccess_CondWrite = OpAccess_INVALID;
		public const int OpAccess_ReadWrite = OpAccess_INVALID;
		public const int OpAccess_ReadCondWrite = OpAccess_INVALID;
		public const int OpAccess_NoMemAccess = OpAccess_INVALID;
#endif

		protected static int GetCodeSize(CodeSize codeSize) => codeSize switch {
			CodeSize.Code16 => 16,
			CodeSize.Code32 => 32,
			CodeSize.Code64 => 64,
			_ => 0,
		};

		public abstract void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info);
	}

	sealed class SimpleInstrInfo : InstrInfo {
		readonly string mnemonic;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo(string mnemonic) : this(mnemonic, InstrOpInfoFlags.None) { }

		public SimpleInstrInfo(string mnemonic, InstrOpInfoFlags flags) {
			this.mnemonic = mnemonic;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) =>
			info = new InstrOpInfo(mnemonic, instr, flags);
	}

	sealed class SimpleInstrInfo_mmxmem : InstrInfo {
		readonly string mnemonic;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_mmxmem(string mnemonic)
			: this(mnemonic, InstrOpInfoFlags.None) {
		}

		public SimpleInstrInfo_mmxmem(string mnemonic, InstrOpInfoFlags flags) {
			this.mnemonic = mnemonic;
			this.flags = flags | InstrOpInfoFlags.MemSize_Mmx;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) =>
			info = new InstrOpInfo(mnemonic, instr, flags);
	}

	sealed class SimpleInstrInfo_memsize : InstrInfo {
		readonly int codeSize;
		readonly string mnemonic;

		public SimpleInstrInfo_memsize(int codeSize, string mnemonic) {
			this.codeSize = codeSize;
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			int instrCodeSize = GetCodeSize(instr.CodeSize);
			var flags = instrCodeSize == 0 || (instrCodeSize & codeSize) != 0 ? InstrOpInfoFlags.MemSize_Nothing : InstrOpInfoFlags.MemSize_Normal | InstrOpInfoFlags.ShowNoMemSize_ForceSize;
			info = new InstrOpInfo(mnemonic, instr, flags);
		}
	}

	sealed class SimpleInstrInfo_AamAad : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_AamAad(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			if (instr.Immediate8 == 10) {
				info = default;
				info.Mnemonic = mnemonic;
			}
			else
				info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
		}
	}

	sealed class SimpleInstrInfo_Ib : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_Ib(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			info.OpCount = 1;
			info.Op0Kind = InstrOpKind.ExtraImmediate8_Value3;
			info.Op0Index = OpAccess_Read;
		}
	}

	sealed class SimpleInstrInfo_YD : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_YD(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op0Kind,
				CodeSize.Code16 => OpKind.MemoryESDI,
				CodeSize.Code32 => OpKind.MemoryESEDI,
				CodeSize.Code64 => OpKind.MemoryESRDI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op0Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm)
				info = new InstrOpInfo(mnemonic_args, instr, flags);
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_DX : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_DX(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op1Kind,
				CodeSize.Code16 => OpKind.MemorySegSI,
				CodeSize.Code32 => OpKind.MemorySegESI,
				CodeSize.Code64 => OpKind.MemorySegRSI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op1Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm)
				info = new InstrOpInfo(mnemonic_args, instr, flags);
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_YX : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_YX(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op0Kind,
				CodeSize.Code16 => OpKind.MemoryESDI,
				CodeSize.Code32 => OpKind.MemoryESEDI,
				CodeSize.Code64 => OpKind.MemoryESRDI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op0Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm)
				info = new InstrOpInfo(mnemonic_args, instr, flags);
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_XY : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_XY(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op1Kind,
				CodeSize.Code16 => OpKind.MemoryESDI,
				CodeSize.Code32 => OpKind.MemoryESEDI,
				CodeSize.Code64 => OpKind.MemoryESRDI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op1Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm)
				info = new InstrOpInfo(mnemonic_args, instr, flags);
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_YA : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_YA(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op0Kind,
				CodeSize.Code16 => OpKind.MemoryESDI,
				CodeSize.Code32 => OpKind.MemoryESEDI,
				CodeSize.Code64 => OpKind.MemoryESRDI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op0Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm) {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_args;
				info.OpCount = 1;
				info.Op0Kind = (InstrOpKind)instr.Op0Kind;
			}
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_AX : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_AX(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op1Kind,
				CodeSize.Code16 => OpKind.MemorySegSI,
				CodeSize.Code32 => OpKind.MemorySegESI,
				CodeSize.Code64 => OpKind.MemorySegRSI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op1Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm) {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_args;
				info.OpCount = 1;
				info.Op0Kind = (InstrOpKind)instr.Op1Kind;
				info.Op0Index = 1;
			}
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_AY : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_AY(string mnemonic_args, string mnemonic_no_args, InstrOpInfoFlags flags) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op1Kind,
				CodeSize.Code16 => OpKind.MemoryESDI,
				CodeSize.Code32 => OpKind.MemoryESEDI,
				CodeSize.Code64 => OpKind.MemoryESRDI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op1Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm) {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_args;
				info.OpCount = 1;
				info.Op0Kind = (InstrOpKind)instr.Op1Kind;
				info.Op0Index = 1;
			}
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_XLAT : InstrInfo {
		readonly string mnemonic_args;
		readonly string mnemonic_no_args;

		public SimpleInstrInfo_XLAT(string mnemonic_args, string mnemonic_no_args) {
			this.mnemonic_args = mnemonic_args;
			this.mnemonic_no_args = mnemonic_no_args;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var baseReg = instr.CodeSize switch {
				CodeSize.Unknown => instr.MemoryBase,
				CodeSize.Code16 => Register.BX,
				CodeSize.Code32 => Register.EBX,
				CodeSize.Code64 => Register.RBX,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.MemoryBase == baseReg && instr.SegmentPrefix == Register.None;
			if (!shortForm)
				info = new InstrOpInfo(mnemonic_args, instr, InstrOpInfoFlags.ShowNoMemSize_ForceSize | InstrOpInfoFlags.IgnoreIndexReg);
			else {
				info = default;
				info.Mnemonic = mnemonic_no_args;
			}
		}
	}

	sealed class SimpleInstrInfo_nop : InstrInfo {
		readonly int codeSize;
		readonly string mnemonic;
		readonly Register register;

		public SimpleInstrInfo_nop(int codeSize, string mnemonic, Register register) {
			this.codeSize = codeSize;
			this.mnemonic = mnemonic;
			this.register = register;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			int instrCodeSize = GetCodeSize(instr.CodeSize);
			if (instrCodeSize == 0 || (instrCodeSize & codeSize) != 0)
				info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
			else {
				info = default;
				info.Mnemonic = "xchg";
				info.OpCount = 2;
				info.Op0Kind = InstrOpKind.Register;
				info.Op1Kind = InstrOpKind.Register;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)register;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)register;
				if (instr.Op0Register == instr.Op1Register) {
					info.Op0Index = OpAccess_None;
					info.Op1Index = OpAccess_None;
				}
				else {
					info.Op0Index = OpAccess_ReadWrite;
					info.Op1Index = OpAccess_ReadWrite;
				}
			}
		}
	}

	sealed class SimpleInstrInfo_STIG1 : InstrInfo {
		readonly string mnemonic;
		readonly bool pseudoOp;

		public SimpleInstrInfo_STIG1(string mnemonic) : this(mnemonic, false) { }

		public SimpleInstrInfo_STIG1(string mnemonic, bool pseudoOp) {
			this.mnemonic = mnemonic;
			this.pseudoOp = pseudoOp;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			Debug.Assert(instr.OpCount == 2);
			Debug.Assert(instr.Op0Kind == OpKind.Register && instr.Op0Register == Register.ST0);
			if (!pseudoOp || !(options.UsePseudoOps && instr.Op1Register == Register.ST1)) {
				info.OpCount = 1;
				Static.Assert(InstrOpKind.Register == 0 ? 0 : -1);
				//info.Op0Kind = InstrOpKind.Register;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)instr.Op1Register;
				info.Op0Index = 1;
			}
		}
	}

	sealed class SimpleInstrInfo_STi_ST2 : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_STi_ST2(string mnemonic) {
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			const InstrOpInfoFlags flags = 0;
			if (options.UsePseudoOps && (instr.Op0Register == Register.ST1 || instr.Op1Register == Register.ST1)) {
				info = default;
				info.Mnemonic = mnemonic;
			}
			else {
				info = new InstrOpInfo(mnemonic, instr, flags);
				Debug.Assert(info.Op1Register == (int)Register.ST0);
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Registers.Register_ST;
			}
		}
	}

	sealed class SimpleInstrInfo_ST_STi : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_ST_STi(string mnemonic) {
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
			Debug.Assert(info.Op0Register == (int)Register.ST0);
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op0Register = (byte)Registers.Register_ST;
		}
	}

	sealed class SimpleInstrInfo_STi_ST : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_STi_ST(string mnemonic) {
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
			Debug.Assert(info.Op1Register == (int)Register.ST0);
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op1Register = (byte)Registers.Register_ST;
		}
	}

	sealed class SimpleInstrInfo_monitor : InstrInfo {
		readonly string mnemonic;
		readonly Register reg1;
		readonly Register reg2;
		readonly Register reg3;

		public SimpleInstrInfo_monitor(string mnemonic, Register reg1, Register reg2, Register reg3) {
			this.mnemonic = mnemonic;
			this.reg1 = reg1;
			this.reg2 = reg2;
			this.reg3 = reg3;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			info.OpCount = 3;
			info.Op0Kind = InstrOpKind.Register;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op0Register = (byte)reg1;
			info.Op1Kind = InstrOpKind.Register;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op1Register = (byte)reg2;
			info.Op2Kind = InstrOpKind.Register;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op2Register = (byte)reg3;
			info.Op0Index = OpAccess_Read;
			info.Op1Index = OpAccess_Read;
			info.Op2Index = OpAccess_Read;
			if ((instr.CodeSize == CodeSize.Code64 || instr.CodeSize == CodeSize.Unknown) && (Register.EAX <= reg2 && reg2 <= Register.R15D)) {
				info.Op1Register += 0x10;
				info.Op2Register += 0x10;
			}
		}
	}

	sealed class SimpleInstrInfo_mwait : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_mwait(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			info.OpCount = 2;
			info.Op0Kind = InstrOpKind.Register;
			info.Op1Kind = InstrOpKind.Register;
			info.Op0Index = OpAccess_Read;
			info.Op1Index = OpAccess_Read;

			switch (instr.CodeSize) {
			case CodeSize.Code16:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.AX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Register.ECX;
				break;
			case CodeSize.Code32:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.EAX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Register.ECX;
				break;
			case CodeSize.Unknown:
			case CodeSize.Code64:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.RAX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Register.RCX;
				break;
			}
		}
	}

	sealed class SimpleInstrInfo_mwaitx : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_mwaitx(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			info.OpCount = 3;
			info.Op0Kind = InstrOpKind.Register;
			info.Op1Kind = InstrOpKind.Register;
			info.Op2Kind = InstrOpKind.Register;
			info.Op0Index = OpAccess_Read;
			info.Op1Index = OpAccess_Read;
			info.Op2Index = OpAccess_CondRead;

			switch (instr.CodeSize) {
			case CodeSize.Code16:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.AX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Register.ECX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op2Register = (byte)Register.EBX;
				break;
			case CodeSize.Code32:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.EAX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Register.ECX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op2Register = (byte)Register.EBX;
				break;
			case CodeSize.Unknown:
			case CodeSize.Code64:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.RAX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)Register.RCX;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op2Register = (byte)Register.RBX;
				break;
			}
		}
	}

	sealed class SimpleInstrInfo_maskmovq : InstrInfo {
		readonly string mnemonic;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_maskmovq(string mnemonic, InstrOpInfoFlags flags) {
			this.mnemonic = mnemonic;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			Debug.Assert(instr.OpCount == 3);
			var shortFormOpKind = instr.CodeSize switch {
				CodeSize.Unknown => instr.Op0Kind,
				CodeSize.Code16 => OpKind.MemorySegDI,
				CodeSize.Code32 => OpKind.MemorySegEDI,
				CodeSize.Code64 => OpKind.MemorySegRDI,
				_ => throw new InvalidOperationException(),
			};
			bool shortForm = instr.Op0Kind == shortFormOpKind && instr.SegmentPrefix == Register.None;
			if (!shortForm)
				info = new InstrOpInfo(mnemonic, instr, flags);
			else {
				info = default;
				info.Flags = flags;
				info.Mnemonic = mnemonic;
				info.OpCount = 2;
				info.Op0Kind = (InstrOpKind)instr.Op1Kind;
				info.Op0Index = 1;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)instr.Op1Register;
				info.Op1Kind = (InstrOpKind)instr.Op2Kind;
				info.Op1Index = 2;
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)instr.Op2Register;
			}
		}
	}

	sealed class SimpleInstrInfo_pblendvb : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_pblendvb(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			Debug.Assert(instr.OpCount == 2);
			info.Mnemonic = mnemonic;
			info.OpCount = 3;
			info.Op0Kind = (InstrOpKind)instr.Op0Kind;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op0Register = (byte)instr.Op0Register;
			info.Op1Kind = (InstrOpKind)instr.Op1Kind;
			info.Op1Index = 1;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op1Register = (byte)instr.Op1Register;
			info.Op2Kind = InstrOpKind.Register;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op2Register = (byte)Register.XMM0;
			info.Op2Index = OpAccess_Read;
		}
	}

	sealed class SimpleInstrInfo_reverse2 : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_reverse2(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			Debug.Assert(instr.OpCount == 2);
			info.OpCount = 2;
			info.Op0Kind = (InstrOpKind)instr.Op1Kind;
			info.Op0Index = 1;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op0Register = (byte)instr.Op1Register;
			info.Op1Kind = (InstrOpKind)instr.Op0Kind;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op1Register = (byte)instr.Op0Register;
		}
	}

	sealed class SimpleInstrInfo_OpSize : InstrInfo {
		readonly CodeSize codeSize;
		readonly string[] mnemonics;

		public SimpleInstrInfo_OpSize(CodeSize codeSize, string mnemonic, string mnemonic16, string mnemonic32, string mnemonic64) {
			this.codeSize = codeSize;
			mnemonics = new string[4];
			mnemonics[(int)CodeSize.Unknown] = mnemonic;
			mnemonics[(int)CodeSize.Code16] = mnemonic16;
			mnemonics[(int)CodeSize.Code32] = mnemonic32;
			mnemonics[(int)CodeSize.Code64] = mnemonic64;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			string mnemonic;
			if (instr.CodeSize == codeSize)
				mnemonic = mnemonics[(int)CodeSize.Unknown];
			else
				mnemonic = mnemonics[(int)codeSize];
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
		}
	}

	sealed class SimpleInstrInfo_OpSize2 : InstrInfo {
		readonly string[] mnemonics;

		public SimpleInstrInfo_OpSize2(string mnemonic, string mnemonic16, string mnemonic32, string mnemonic64) {
			mnemonics = new string[4];
			mnemonics[(int)CodeSize.Unknown] = mnemonic;
			mnemonics[(int)CodeSize.Code16] = mnemonic16;
			mnemonics[(int)CodeSize.Code32] = mnemonic32;
			mnemonics[(int)CodeSize.Code64] = mnemonic64;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var mnemonic = mnemonics[(int)instr.CodeSize];
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
		}
	}

	sealed class SimpleInstrInfo_OpSize2_bnd : InstrInfo {
		readonly string[] mnemonics;

		public SimpleInstrInfo_OpSize2_bnd(string mnemonic, string mnemonic16, string mnemonic32, string mnemonic64) {
			mnemonics = new string[4];
			mnemonics[(int)CodeSize.Unknown] = mnemonic;
			mnemonics[(int)CodeSize.Code16] = mnemonic16;
			mnemonics[(int)CodeSize.Code32] = mnemonic32;
			mnemonics[(int)CodeSize.Code64] = mnemonic64;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var flags = InstrOpInfoFlags.None;
			if (instr.HasRepnePrefix)
				flags |= InstrOpInfoFlags.BndPrefix;
			var mnemonic = mnemonics[(int)instr.CodeSize];
			info = new InstrOpInfo(mnemonic, instr, flags);
		}
	}

	sealed class SimpleInstrInfo_pushm : InstrInfo {
		readonly CodeSize codeSize;
		readonly string mnemonic;

		public SimpleInstrInfo_pushm(CodeSize codeSize, string mnemonic) {
			this.codeSize = codeSize;
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var flags = InstrOpInfoFlags.None;
			if (instr.CodeSize != codeSize && instr.CodeSize != CodeSize.Unknown)
				flags |= InstrOpInfoFlags.ShowNoMemSize_ForceSize;
			info = new InstrOpInfo(mnemonic, instr, flags);
		}
	}

	sealed class SimpleInstrInfo_fword : InstrInfo {
		readonly CodeSize codeSize;
		readonly bool forceNoMemSize;
		readonly string mnemonic;
		readonly string mnemonic2;

		public SimpleInstrInfo_fword(CodeSize codeSize, bool forceNoMemSize, string mnemonic, string mnemonic2) {
			this.codeSize = codeSize;
			this.forceNoMemSize = forceNoMemSize;
			this.mnemonic = mnemonic;
			this.mnemonic2 = mnemonic2;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var flags = InstrOpInfoFlags.None;
			string mnemonic;
			if (instr.CodeSize == codeSize || instr.CodeSize == CodeSize.Unknown)
				mnemonic = this.mnemonic;
			else
				mnemonic = mnemonic2;
			if (!forceNoMemSize)
				flags |= InstrOpInfoFlags.ShowNoMemSize_ForceSize;
			info = new InstrOpInfo(mnemonic, instr, flags);
		}
	}

	sealed class SimpleInstrInfo_jcc : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_jcc(string mnemonic) => this.mnemonic = mnemonic;

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var flags = InstrOpInfoFlags.None;
			var prefixSeg = instr.SegmentPrefix;
			if (prefixSeg == Register.CS)
				flags |= InstrOpInfoFlags.JccNotTaken;
			else if (prefixSeg == Register.DS)
				flags |= InstrOpInfoFlags.JccTaken;
			if (instr.HasRepnePrefix)
				flags |= InstrOpInfoFlags.BndPrefix;
			info = new InstrOpInfo(mnemonic, instr, flags);
		}
	}

	sealed class SimpleInstrInfo_bnd : InstrInfo {
		readonly string mnemonic;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_bnd(string mnemonic) : this(mnemonic, InstrOpInfoFlags.None) { }

		public SimpleInstrInfo_bnd(string mnemonic, InstrOpInfoFlags flags) {
			this.mnemonic = mnemonic;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			var flags = this.flags;
			if (instr.HasRepnePrefix)
				flags |= InstrOpInfoFlags.BndPrefix;
			info = new InstrOpInfo(mnemonic, instr, flags);
		}
	}

	sealed class SimpleInstrInfo_pops : InstrInfo {
		readonly string mnemonic;
		readonly string[] pseudo_ops;
		readonly InstrOpInfoFlags flags;

		public SimpleInstrInfo_pops(string mnemonic, string[] pseudo_ops) : this(mnemonic, pseudo_ops, InstrOpInfoFlags.None) { }

		public SimpleInstrInfo_pops(string mnemonic, string[] pseudo_ops, InstrOpInfoFlags flags) {
			this.mnemonic = mnemonic;
			this.pseudo_ops = pseudo_ops;
			this.flags = flags;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = new InstrOpInfo(mnemonic, instr, flags);
			int imm = instr.Immediate8;
			if (options.UsePseudoOps && (uint)imm < (uint)pseudo_ops.Length) {
				info.Mnemonic = pseudo_ops[imm];
				RemoveLastOp(ref info);
			}
		}

		internal static void RemoveLastOp(ref InstrOpInfo info) {
			switch (info.OpCount) {
			case 4:
				info.Op3Index = OpAccess_INVALID;
				break;
			case 3:
				info.Op2Index = OpAccess_INVALID;
				break;
			default:
				throw new InvalidOperationException();
			}
			info.OpCount--;
		}
	}

	sealed class SimpleInstrInfo_pclmulqdq : InstrInfo {
		readonly string mnemonic;
		readonly string[] pseudo_ops;

		public SimpleInstrInfo_pclmulqdq(string mnemonic, string[] pseudo_ops) {
			this.mnemonic = mnemonic;
			this.pseudo_ops = pseudo_ops;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
			if (options.UsePseudoOps) {
				int index;
				int imm = instr.Immediate8;
				if (imm == 0)
					index = 0;
				else if (imm == 1)
					index = 1;
				else if (imm == 0x10)
					index = 2;
				else if (imm == 0x11)
					index = 3;
				else
					index = -1;
				if (index >= 0) {
					info.Mnemonic = pseudo_ops[index];
					SimpleInstrInfo_pops.RemoveLastOp(ref info);
				}
			}
		}
	}

	sealed class SimpleInstrInfo_imul : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_imul(string mnemonic) {
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.None);
			Debug.Assert(info.OpCount == 3);
			if (options.UsePseudoOps && info.Op0Kind == InstrOpKind.Register && info.Op1Kind == InstrOpKind.Register && info.Op0Register == info.Op1Register) {
				info.OpCount--;
				info.Op0Index = OpAccess_ReadWrite;
				info.Op1Kind = info.Op2Kind;
				info.Op1Index = 2;
				info.Op2Index = OpAccess_INVALID;
			}
		}
	}

	sealed class SimpleInstrInfo_Reg16 : InstrInfo {
		readonly string mnemonic;

		public SimpleInstrInfo_Reg16(string mnemonic) {
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			const InstrOpInfoFlags flags = InstrOpInfoFlags.None;
			info = new InstrOpInfo(mnemonic, instr, flags);
			if (Register.EAX <= (Register)info.Op0Register && (Register)info.Op0Register <= Register.R15D) {
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)((Register)info.Op0Register - Register.EAX + Register.AX);
			}
			if (Register.EAX <= (Register)info.Op1Register && (Register)info.Op1Register <= Register.R15D) {
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op1Register = (byte)((Register)info.Op1Register - Register.EAX + Register.AX);
			}
		}
	}

	sealed class SimpleInstrInfo_reg : InstrInfo {
		readonly string mnemonic;
		readonly Register register;

		public SimpleInstrInfo_reg(string mnemonic, Register register) {
			this.mnemonic = mnemonic;
			this.register = register;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			info.OpCount = 1;
			info.Op0Kind = InstrOpKind.Register;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op0Register = (byte)register;
			info.Op0Index = OpAccess_Read;
		}
	}

	sealed class SimpleInstrInfo_invlpga : InstrInfo {
		readonly int codeSize;
		readonly string mnemonic;

		public SimpleInstrInfo_invlpga(int codeSize, string mnemonic) {
			this.codeSize = codeSize;
			this.mnemonic = mnemonic;
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = default;
			info.Mnemonic = mnemonic;
			info.OpCount = 2;
			info.Op0Kind = InstrOpKind.Register;
			info.Op1Kind = InstrOpKind.Register;
			Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
			info.Op1Register = (byte)Register.ECX;
			info.Op0Index = OpAccess_Read;
			info.Op1Index = OpAccess_Read;

			switch (codeSize) {
			case 16:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.AX;
				break;

			case 32:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.EAX;
				break;

			case 64:
				Static.Assert(InstrOpInfo.TEST_RegisterBits == 8 ? 0 : -1);
				info.Op0Register = (byte)Register.RAX;
				break;

			default:
				throw new InvalidOperationException();
			}
		}
	}

	sealed class SimpleInstrInfo_DeclareData : InstrInfo {
		readonly string mnemonic;
		readonly InstrOpKind opKind;

		public SimpleInstrInfo_DeclareData(Code code, string mnemonic) {
			this.mnemonic = mnemonic;
			opKind = code switch {
				Code.DeclareByte => InstrOpKind.DeclareByte,
				Code.DeclareWord => InstrOpKind.DeclareWord,
				Code.DeclareDword => InstrOpKind.DeclareDword,
				Code.DeclareQword => InstrOpKind.DeclareQword,
				_ => throw new InvalidOperationException(),
			};
		}

		public override void GetOpInfo(MasmFormatterOptions options, in Instruction instr, out InstrOpInfo info) {
			info = new InstrOpInfo(mnemonic, instr, InstrOpInfoFlags.MnemonicIsDirective);
			info.OpCount = (byte)instr.DeclareDataCount;
			info.Op0Kind = opKind;
			info.Op1Kind = opKind;
			info.Op2Kind = opKind;
			info.Op3Kind = opKind;
			info.Op4Kind = opKind;
			info.Op0Index = OpAccess_Read;
			info.Op1Index = OpAccess_Read;
			info.Op2Index = OpAccess_Read;
			info.Op3Index = OpAccess_Read;
			info.Op4Index = OpAccess_Read;
		}
	}
}
#endif
