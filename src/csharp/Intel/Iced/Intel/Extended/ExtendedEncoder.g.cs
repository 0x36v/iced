/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#nullable enable

#if !NO_ENCODER
namespace Iced.Intel {
	using System;
	public sealed partial class ExtendedEncoder {
		public void aaa() {
			Code op;
			op = Code.Aaa;
			AddInstruction(Instruction.Create(op));
		}
		public void aad(int imm) {
			Code op;
			op = Code.Aad_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void aam(int imm) {
			Code op;
			op = Code.Aam_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void aas() {
			Code op;
			op = Code.Aas;
			AddInstruction(Instruction.Create(op));
		}
		public void adc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Adc_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Adc_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Adc_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Adc_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Adc_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Adc_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Adc_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Adc_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Adc_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Adc_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Adc_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Adc_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Adc_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void adc(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Adc_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Adc_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Adc_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Adc_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Adc_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Adc_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Adc_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void adcx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adcx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adcx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adcx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Add_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Add_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Add_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Add_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Add_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Add_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Add_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Add_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Add_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Add_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Add_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Add_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Add_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Add_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Add_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void add(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Add_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Add_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Add_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Add_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Add_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Add_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Add_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void addpd(Register dst, Register src) {
			Code op;
			op = Code.Addpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void addps(Register dst, Register src) {
			Code op;
			op = Code.Addps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void addsd(Register dst, Register src) {
			Code op;
			op = Code.Addsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void addss(Register dst, Register src) {
			Code op;
			op = Code.Addss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void addsubpd(Register dst, Register src) {
			Code op;
			op = Code.Addsubpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void addsubps(Register dst, Register src) {
			Code op;
			op = Code.Addsubps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adox(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adox)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adox(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adox)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void aesdec(Register dst, Register src) {
			Code op;
			op = Code.Aesdec_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void aesdeclast(Register dst, Register src) {
			Code op;
			op = Code.Aesdeclast_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void aesenc(Register dst, Register src) {
			Code op;
			op = Code.Aesenc_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void aesenclast(Register dst, Register src) {
			Code op;
			op = Code.Aesenclast_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void aesimc(Register dst, Register src) {
			Code op;
			op = Code.Aesimc_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void aeskeygenassist(Register dst, Register src, int imm) {
			Code op;
			op = Code.Aeskeygenassist_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void and(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.And_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.And_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.And_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.And_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.And_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.And_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.And_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.And_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.And_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.And_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.And_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.And_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.And_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.And_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.And_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.And_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.And_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.And_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.And_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.And_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.And_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void and(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.And_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.And_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.And_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.And_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.And_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.And_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.And_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void andnpd(Register dst, Register src) {
			Code op;
			op = Code.Andnpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void andnps(Register dst, Register src) {
			Code op;
			op = Code.Andnps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void andpd(Register dst, Register src) {
			Code op;
			op = Code.Andpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void andps(Register dst, Register src) {
			Code op;
			op = Code.Andps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void arpl(Register dst, Register src) {
			Code op;
			op = Code.Arpl_rm16_r16;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void arpl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			op = Code.Arpl_rm16_r16;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void blendpd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Blendpd_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void blendps(Register dst, Register src, int imm) {
			Code op;
			op = Code.Blendps_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void blendvpd(Register dst, Register src) {
			Code op;
			op = Code.Blendvpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void blendvps(Register dst, Register src) {
			Code op;
			op = Code.Blendvps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsf(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsf)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsf(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsf)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsr(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bswap(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bswap_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bswap_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bswap_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bswap)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void bt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bt_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bt_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bt_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bt(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bt_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bt_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bt_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bt(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bt_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Bt_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Bt_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void bt(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bt_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bt_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bt_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btc_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Btc_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Btc_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btc_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btc_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btc_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btc(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btc_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Btc_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Btc_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btc(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btc_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btc_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btc_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btr_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Btr_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Btr_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btr_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btr_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btr_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btr(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Btr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Btr_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btr_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void bts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bts_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bts_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bts_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bts_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bts(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bts_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Bts_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Bts_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void bts(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bts_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bts_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bts_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void call(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Call_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Call_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Call_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(call)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void call(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Call_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Call_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Call_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(call)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void cbw() {
			Code op;
			op = Code.Cbw;
			AddInstruction(Instruction.Create(op));
		}
		public void cdq() {
			Code op;
			op = Code.Cdq;
			AddInstruction(Instruction.Create(op));
		}
		public void cdqe() {
			Code op;
			op = Code.Cdqe;
			AddInstruction(Instruction.Create(op));
		}
		public void cl1invmb() {
			Code op;
			op = Code.Cl1invmb;
			AddInstruction(Instruction.Create(op));
		}
		public void clac() {
			Code op;
			op = Code.Clac;
			AddInstruction(Instruction.Create(op));
		}
		public void clc() {
			Code op;
			op = Code.Clc;
			AddInstruction(Instruction.Create(op));
		}
		public void cld() {
			Code op;
			op = Code.Cld;
			AddInstruction(Instruction.Create(op));
		}
		public void clgi() {
			Code op;
			op = Code.Clgi;
			AddInstruction(Instruction.Create(op));
		}
		public void cli() {
			Code op;
			op = Code.Cli;
			AddInstruction(Instruction.Create(op));
		}
		public void clts() {
			Code op;
			op = Code.Clts;
			AddInstruction(Instruction.Create(op));
		}
		public void clzero() {
			Code op;
			if (Bitness == 64) {
				op = Code.Clzeroq;
			} else if (Bitness == 32) {
				op = Code.Clzerod;
			} else {
				op = Code.Clzerow;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void cmc() {
			Code op;
			op = Code.Cmc;
			AddInstruction(Instruction.Create(op));
		}
		public void cmova(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmova)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmova(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmova)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovae(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovae(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovbe(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovbe(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmove(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmove)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmove(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmove)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovg(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovge(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovge(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovle(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovle(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovne(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovne(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovno(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovno(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovnp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovnp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovns(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovns(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovo(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovo)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovo(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovo)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovs(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovs)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovs(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovs)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmp_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmp_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmp_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Cmp_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Cmp_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Cmp_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Cmp_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Cmp_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Cmp_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Cmp_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Cmp_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Cmp_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void cmp(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Cmp_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Cmp_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Cmp_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Cmp_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmp_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmp_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmp_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void cmppd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Cmppd_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void cmpps(Register dst, Register src, int imm) {
			Code op;
			op = Code.Cmpps_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void cmpsb() {
			Code op;
			op = Code.Cmpsb_m8_m8;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpsd() {
			Code op;
			op = Code.Cmpsd_m32_m32;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpsd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Cmpsd_xmm_xmmm64_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void cmpsq() {
			Code op;
			op = Code.Cmpsq_m64_m64;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpss(Register dst, Register src, int imm) {
			Code op;
			op = Code.Cmpss_xmm_xmmm32_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void cmpsw() {
			Code op;
			op = Code.Cmpsw_m16_m16;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpxchg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmpxchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmpxchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmpxchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void comisd(Register dst, Register src) {
			Code op;
			op = Code.Comisd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void comiss(Register dst, Register src) {
			Code op;
			op = Code.Comiss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cpuid() {
			Code op;
			op = Code.Cpuid;
			AddInstruction(Instruction.Create(op));
		}
		public void cqo() {
			Code op;
			op = Code.Cqo;
			AddInstruction(Instruction.Create(op));
		}
		public void crc32(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR64()) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR32()) {
				op = Code.Crc32_r32_rm32;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Crc32_r32_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(crc32)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void crc32(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Crc32_r32_rm32;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Crc32_r32_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(crc32)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtdq2pd(Register dst, Register src) {
			Code op;
			op = Code.Cvtdq2pd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtdq2ps(Register dst, Register src) {
			Code op;
			op = Code.Cvtdq2ps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtpd2dq(Register dst, Register src) {
			Code op;
			op = Code.Cvtpd2dq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtpd2ps(Register dst, Register src) {
			Code op;
			op = Code.Cvtpd2ps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtps2dq(Register dst, Register src) {
			Code op;
			op = Code.Cvtps2dq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtps2pd(Register dst, Register src) {
			Code op;
			op = Code.Cvtps2pd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtsd2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvtsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cvtsd2si_r32_xmmm64;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvtsd2si)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtsd2ss(Register dst, Register src) {
			Code op;
			op = Code.Cvtsd2ss_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtsi2sd(Register dst, Register src) {
			Code op;
			if (true && src.IsGPR64()) {
				op = Code.Cvtsi2sd_xmm_rm64;
			} else if (true && src.IsGPR32()) {
				op = Code.Cvtsi2sd_xmm_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvtsi2sd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtsi2sd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (true && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cvtsi2sd_xmm_rm64;
			} else if (true && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cvtsi2sd_xmm_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvtsi2sd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtsi2ss(Register dst, Register src) {
			Code op;
			if (true && src.IsGPR64()) {
				op = Code.Cvtsi2ss_xmm_rm64;
			} else if (true && src.IsGPR32()) {
				op = Code.Cvtsi2ss_xmm_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvtsi2ss)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtsi2ss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (true && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cvtsi2ss_xmm_rm64;
			} else if (true && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cvtsi2ss_xmm_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvtsi2ss)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtss2sd(Register dst, Register src) {
			Code op;
			op = Code.Cvtss2sd_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvtss2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvtss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cvtss2si_r32_xmmm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvtss2si)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvttpd2dq(Register dst, Register src) {
			Code op;
			op = Code.Cvttpd2dq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvttps2dq(Register dst, Register src) {
			Code op;
			op = Code.Cvttps2dq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvttsd2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvttsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cvttsd2si_r32_xmmm64;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvttsd2si)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cvttss2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvttss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cvttss2si_r32_xmmm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cvttss2si)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cwd() {
			Code op;
			op = Code.Cwd;
			AddInstruction(Instruction.Create(op));
		}
		public void cwde() {
			Code op;
			op = Code.Cwde;
			AddInstruction(Instruction.Create(op));
		}
		public void daa() {
			Code op;
			op = Code.Daa;
			AddInstruction(Instruction.Create(op));
		}
		public void das() {
			Code op;
			op = Code.Das;
			AddInstruction(Instruction.Create(op));
		}
		public void db() {
			Code op;
			op = Code.DeclareByte;
			AddInstruction(Instruction.Create(op));
		}
		public void dd() {
			Code op;
			op = Code.DeclareDword;
			AddInstruction(Instruction.Create(op));
		}
		public void dec(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Dec_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Dec_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Dec_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Dec_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(dec)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void dec(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Dec_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Dec_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Dec_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Dec_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(dec)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void div(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Div_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Div_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Div_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Div_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(div)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void div(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Div_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Div_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Div_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Div_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(div)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void divpd(Register dst, Register src) {
			Code op;
			op = Code.Divpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void divps(Register dst, Register src) {
			Code op;
			op = Code.Divps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void divsd(Register dst, Register src) {
			Code op;
			op = Code.Divsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void divss(Register dst, Register src) {
			Code op;
			op = Code.Divss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void dppd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Dppd_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void dpps(Register dst, Register src, int imm) {
			Code op;
			op = Code.Dpps_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void dq() {
			Code op;
			op = Code.DeclareQword;
			AddInstruction(Instruction.Create(op));
		}
		public void dw() {
			Code op;
			op = Code.DeclareWord;
			AddInstruction(Instruction.Create(op));
		}
		public void emms() {
			Code op;
			op = Code.Emms;
			AddInstruction(Instruction.Create(op));
		}
		public void encls() {
			Code op;
			op = Code.Encls;
			AddInstruction(Instruction.Create(op));
		}
		public void enclu() {
			Code op;
			op = Code.Enclu;
			AddInstruction(Instruction.Create(op));
		}
		public void enclv() {
			Code op;
			op = Code.Enclv;
			AddInstruction(Instruction.Create(op));
		}
		public void endbr32() {
			Code op;
			op = Code.Endbr32;
			AddInstruction(Instruction.Create(op));
		}
		public void endbr64() {
			Code op;
			op = Code.Endbr64;
			AddInstruction(Instruction.Create(op));
		}
		public void extractps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Extractps_r64m32_xmm_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Extractps_rm32_xmm_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(extractps)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void extractps(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Extractps_r64m32_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Extractps_rm32_xmm_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(extractps)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void f2xm1() {
			Code op;
			op = Code.F2xm1;
			AddInstruction(Instruction.Create(op));
		}
		public void fabs() {
			Code op;
			op = Code.Fabs;
			AddInstruction(Instruction.Create(op));
		}
		public void fchs() {
			Code op;
			op = Code.Fchs;
			AddInstruction(Instruction.Create(op));
		}
		public void fclex() {
			Code op;
			op = Code.Fclex;
			AddInstruction(Instruction.Create(op));
		}
		public void fcompp() {
			Code op;
			op = Code.Fcompp;
			AddInstruction(Instruction.Create(op));
		}
		public void fcos() {
			Code op;
			op = Code.Fcos;
			AddInstruction(Instruction.Create(op));
		}
		public void fdecstp() {
			Code op;
			op = Code.Fdecstp;
			AddInstruction(Instruction.Create(op));
		}
		public void fdisi() {
			Code op;
			op = Code.Fdisi;
			AddInstruction(Instruction.Create(op));
		}
		public void femms() {
			Code op;
			op = Code.Femms;
			AddInstruction(Instruction.Create(op));
		}
		public void feni() {
			Code op;
			op = Code.Feni;
			AddInstruction(Instruction.Create(op));
		}
		public void fincstp() {
			Code op;
			op = Code.Fincstp;
			AddInstruction(Instruction.Create(op));
		}
		public void finit() {
			Code op;
			op = Code.Finit;
			AddInstruction(Instruction.Create(op));
		}
		public void fld1() {
			Code op;
			op = Code.Fld1;
			AddInstruction(Instruction.Create(op));
		}
		public void fldl2e() {
			Code op;
			op = Code.Fldl2e;
			AddInstruction(Instruction.Create(op));
		}
		public void fldl2t() {
			Code op;
			op = Code.Fldl2t;
			AddInstruction(Instruction.Create(op));
		}
		public void fldlg2() {
			Code op;
			op = Code.Fldlg2;
			AddInstruction(Instruction.Create(op));
		}
		public void fldln2() {
			Code op;
			op = Code.Fldln2;
			AddInstruction(Instruction.Create(op));
		}
		public void fldpi() {
			Code op;
			op = Code.Fldpi;
			AddInstruction(Instruction.Create(op));
		}
		public void fldz() {
			Code op;
			op = Code.Fldz;
			AddInstruction(Instruction.Create(op));
		}
		public void fnclex() {
			Code op;
			op = Code.Fnclex;
			AddInstruction(Instruction.Create(op));
		}
		public void fndisi() {
			Code op;
			op = Code.Fndisi;
			AddInstruction(Instruction.Create(op));
		}
		public void fneni() {
			Code op;
			op = Code.Fneni;
			AddInstruction(Instruction.Create(op));
		}
		public void fninit() {
			Code op;
			op = Code.Fninit;
			AddInstruction(Instruction.Create(op));
		}
		public void fnop() {
			Code op;
			op = Code.Fnop;
			AddInstruction(Instruction.Create(op));
		}
		public void fnsetpm() {
			Code op;
			op = Code.Fnsetpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fnstsw(Register dst) {
			Code op;
			op = Code.Fnstsw_AX;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fpatan() {
			Code op;
			op = Code.Fpatan;
			AddInstruction(Instruction.Create(op));
		}
		public void fprem() {
			Code op;
			op = Code.Fprem;
			AddInstruction(Instruction.Create(op));
		}
		public void fprem1() {
			Code op;
			op = Code.Fprem1;
			AddInstruction(Instruction.Create(op));
		}
		public void fptan() {
			Code op;
			op = Code.Fptan;
			AddInstruction(Instruction.Create(op));
		}
		public void frndint() {
			Code op;
			op = Code.Frndint;
			AddInstruction(Instruction.Create(op));
		}
		public void frstpm() {
			Code op;
			op = Code.Frstpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fscale() {
			Code op;
			op = Code.Fscale;
			AddInstruction(Instruction.Create(op));
		}
		public void fsetpm() {
			Code op;
			op = Code.Fsetpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fsin() {
			Code op;
			op = Code.Fsin;
			AddInstruction(Instruction.Create(op));
		}
		public void fsincos() {
			Code op;
			op = Code.Fsincos;
			AddInstruction(Instruction.Create(op));
		}
		public void fsqrt() {
			Code op;
			op = Code.Fsqrt;
			AddInstruction(Instruction.Create(op));
		}
		public void fstdw(Register dst) {
			Code op;
			op = Code.Fstdw_AX;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fstsg(Register dst) {
			Code op;
			op = Code.Fstsg_AX;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fstsw(Register dst) {
			Code op;
			op = Code.Fstsw_AX;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ftst() {
			Code op;
			op = Code.Ftst;
			AddInstruction(Instruction.Create(op));
		}
		public void fucompp() {
			Code op;
			op = Code.Fucompp;
			AddInstruction(Instruction.Create(op));
		}
		public void fxam() {
			Code op;
			op = Code.Fxam;
			AddInstruction(Instruction.Create(op));
		}
		public void fxtract() {
			Code op;
			op = Code.Fxtract;
			AddInstruction(Instruction.Create(op));
		}
		public void fyl2x() {
			Code op;
			op = Code.Fyl2x;
			AddInstruction(Instruction.Create(op));
		}
		public void fyl2xp1() {
			Code op;
			op = Code.Fyl2xp1;
			AddInstruction(Instruction.Create(op));
		}
		public void getsec() {
			Code op;
			op = Code.Getsec;
			AddInstruction(Instruction.Create(op));
		}
		public void gf2p8affineinvqb(Register dst, Register src, int imm) {
			Code op;
			op = Code.Gf2p8affineinvqb_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void gf2p8affineqb(Register dst, Register src, int imm) {
			Code op;
			op = Code.Gf2p8affineqb_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void gf2p8mulb(Register dst, Register src) {
			Code op;
			op = Code.Gf2p8mulb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void haddpd(Register dst, Register src) {
			Code op;
			op = Code.Haddpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void haddps(Register dst, Register src) {
			Code op;
			op = Code.Haddps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void hlt() {
			Code op;
			op = Code.Hlt;
			AddInstruction(Instruction.Create(op));
		}
		public void hsubpd(Register dst, Register src) {
			Code op;
			op = Code.Hsubpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void hsubps(Register dst, Register src) {
			Code op;
			op = Code.Hsubps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ibts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Ibts_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ibts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ibts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ibts_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ibts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void idiv(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Idiv_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Idiv_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Idiv_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Idiv_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(idiv)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void idiv(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Idiv_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Idiv_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Idiv_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Idiv_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(idiv)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Imul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Imul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Imul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Imul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Imul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void imul(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void imul(Register dst, Register src, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Imul_r64_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Imul_r32_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Imul_r16_rm16_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void imul(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Imul_r64_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Imul_r32_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Imul_r16_rm16_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void @in(Register dst, Register src) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.In_EAX_DX;
			} else if (dst == Register.AX) {
				op = Code.In_AX_DX;
			} else if (dst == Register.AL) {
				op = Code.In_AL_DX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@in)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void @in(Register dst, int imm) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.In_EAX_imm8;
			} else if (dst == Register.AX) {
				op = Code.In_AX_imm8;
			} else if (dst == Register.AL) {
				op = Code.In_AL_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@in)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void inc(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Inc_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Inc_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Inc_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Inc_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(inc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void inc(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Inc_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Inc_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Inc_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Inc_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(inc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void insb(Register src) {
			Code op;
			op = Code.Insb_m8_DX;
			AddInstruction(Instruction.Create(op, src));
		}
		public void insd(Register src) {
			Code op;
			op = Code.Insd_m32_DX;
			AddInstruction(Instruction.Create(op, src));
		}
		public void insertps(Register dst, Register src, int imm) {
			Code op;
			op = Code.Insertps_xmm_xmmm32_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void insw(Register src) {
			Code op;
			op = Code.Insw_m16_DX;
			AddInstruction(Instruction.Create(op, src));
		}
		public void @int() {
			Code op;
			op = Code.Int3;
			AddInstruction(Instruction.Create(op));
		}
		public void @int(int imm) {
			Code op;
			op = Code.Int_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void int1() {
			Code op;
			op = Code.Int1;
			AddInstruction(Instruction.Create(op));
		}
		public void into() {
			Code op;
			op = Code.Into;
			AddInstruction(Instruction.Create(op));
		}
		public void invd() {
			Code op;
			op = Code.Invd;
			AddInstruction(Instruction.Create(op));
		}
		public void invlpga() {
			Code op;
			if (Bitness == 64) {
				op = Code.Invlpgaq;
			} else if (Bitness == 32) {
				op = Code.Invlpgad;
			} else {
				op = Code.Invlpgaw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void iret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Iretq;
			} else if (Bitness == 32) {
				op = Code.Iretd;
			} else {
				op = Code.Iretw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void jmp(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Jmp_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Jmp_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Jmp_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Jmp_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmp_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmp_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmpe(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Jmpe_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Jmpe_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmpe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmpe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmpe_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmpe_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmpe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lahf() {
			Code op;
			op = Code.Lahf;
			AddInstruction(Instruction.Create(op));
		}
		public void lar(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void lar(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void leave() {
			Code op;
			if (Bitness == 64) {
				op = Code.Leaveq;
			} else if (Bitness == 32) {
				op = Code.Leaved;
			} else {
				op = Code.Leavew;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void lfence() {
			Code op;
			op = Code.Lfence;
			AddInstruction(Instruction.Create(op));
		}
		public void lldt(Register dst) {
			Code op;
			op = Code.Lldt_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lldt(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Lldt_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lmsw(Register dst) {
			Code op;
			op = Code.Lmsw_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lmsw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Lmsw_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void loadall() {
			Code op;
			op = Code.Loadall386;
			AddInstruction(Instruction.Create(op));
		}
		public void lodsb(Register dst) {
			Code op;
			op = Code.Lodsb_AL_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lodsd(Register dst) {
			Code op;
			op = Code.Lodsd_EAX_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lodsq(Register dst) {
			Code op;
			op = Code.Lodsq_RAX_m64;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lodsw(Register dst) {
			Code op;
			op = Code.Lodsw_AX_m16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lsl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lsl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void lsl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lsl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ltr(Register dst) {
			Code op;
			op = Code.Ltr_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ltr(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Ltr_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lzcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void lzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void maxpd(Register dst, Register src) {
			Code op;
			op = Code.Maxpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void maxps(Register dst, Register src) {
			Code op;
			op = Code.Maxps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void maxsd(Register dst, Register src) {
			Code op;
			op = Code.Maxsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void maxss(Register dst, Register src) {
			Code op;
			op = Code.Maxss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mcommit() {
			Code op;
			op = Code.Mcommit;
			AddInstruction(Instruction.Create(op));
		}
		public void mfence() {
			Code op;
			op = Code.Mfence;
			AddInstruction(Instruction.Create(op));
		}
		public void minpd(Register dst, Register src) {
			Code op;
			op = Code.Minpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void minps(Register dst, Register src) {
			Code op;
			op = Code.Minps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void minsd(Register dst, Register src) {
			Code op;
			op = Code.Minsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void minss(Register dst, Register src) {
			Code op;
			op = Code.Minss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void monitor() {
			Code op;
			if (Bitness == 64) {
				op = Code.Monitorq;
			} else if (Bitness == 32) {
				op = Code.Monitord;
			} else {
				op = Code.Monitorw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void monitorx() {
			Code op;
			if (Bitness == 64) {
				op = Code.Monitorxq;
			} else if (Bitness == 32) {
				op = Code.Monitorxd;
			} else {
				op = Code.Monitorxw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void montmul() {
			Code op;
			if (Bitness == 64) {
				op = Code.Montmul_64;
			} else if (Bitness == 32) {
				op = Code.Montmul_32;
			} else {
				op = Code.Montmul_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void mov(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mov_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mov_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mov_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(Register dst, long imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR8()) {
					op = Code.Mov_r8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Mov_r64_imm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void mov(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Mov_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mov_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mov_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mov_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void movapd(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movapd_xmm_xmmm128;
			} else if (true) {
				op = Code.Movapd_xmmm128_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movapd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movaps(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movaps_xmm_xmmm128;
			} else if (true) {
				op = Code.Movaps_xmmm128_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movaps)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movd(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movd_xmm_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movd_rm32_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			op = Code.Movd_rm32_xmm;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			op = Code.Movd_xmm_rm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movddup(Register dst, Register src) {
			Code op;
			op = Code.Movddup_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movdqa(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movdqa_xmm_xmmm128;
			} else if (true) {
				op = Code.Movdqa_xmmm128_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movdqa)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movdqu(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movdqu_xmm_xmmm128;
			} else if (true) {
				op = Code.Movdqu_xmmm128_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movdqu)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movq(Register dst, Register src) {
			Code op;
			if (true && true) {
				op = Code.Movq_xmm_xmmm64;
			} else if (true && src.IsGPR64()) {
				op = Code.Movq_xmm_rm64;
			} else if (dst.IsGPR64()) {
				op = Code.Movq_rm64_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movq)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			op = Code.Movq_rm64_xmm;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			op = Code.Movq_xmm_rm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsb() {
			Code op;
			op = Code.Movsb_m8_m8;
			AddInstruction(Instruction.Create(op));
		}
		public void movsd(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movsd_xmm_xmmm64;
			} else if (true) {
				op = Code.Movsd_xmmm64_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsd() {
			Code op;
			op = Code.Movsd_m32_m32;
			AddInstruction(Instruction.Create(op));
		}
		public void movshdup(Register dst, Register src) {
			Code op;
			op = Code.Movshdup_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsldup(Register dst, Register src) {
			Code op;
			op = Code.Movsldup_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsq() {
			Code op;
			op = Code.Movsq_m64_m64;
			AddInstruction(Instruction.Create(op));
		}
		public void movss(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movss_xmm_xmmm32;
			} else if (true) {
				op = Code.Movss_xmmm32_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movss)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsw() {
			Code op;
			op = Code.Movsw_m16_m16;
			AddInstruction(Instruction.Create(op));
		}
		public void movsx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR16()) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Movsx_r16_rm16;
			} else if (dst.IsGPR16() && src.IsGPR8()) {
				op = Code.Movsx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r16_rm16;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsxd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsxd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsxd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsxd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movupd(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movupd_xmm_xmmm128;
			} else if (true) {
				op = Code.Movupd_xmmm128_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movupd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movups(Register dst, Register src) {
			Code op;
			if (true) {
				op = Code.Movups_xmm_xmmm128;
			} else if (true) {
				op = Code.Movups_xmmm128_xmm;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movups)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movzx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR16()) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Movzx_r16_rm16;
			} else if (dst.IsGPR16() && src.IsGPR8()) {
				op = Code.Movzx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movzx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movzx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r16_rm16;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movzx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mpsadbw(Register dst, Register src, int imm) {
			Code op;
			op = Code.Mpsadbw_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void mul(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mul_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mul_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mul_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void mul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void mulpd(Register dst, Register src) {
			Code op;
			op = Code.Mulpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mulps(Register dst, Register src) {
			Code op;
			op = Code.Mulps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mulsd(Register dst, Register src) {
			Code op;
			op = Code.Mulsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mulss(Register dst, Register src) {
			Code op;
			op = Code.Mulss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mwait() {
			Code op;
			op = Code.Mwait;
			AddInstruction(Instruction.Create(op));
		}
		public void mwaitx() {
			Code op;
			op = Code.Mwaitx;
			AddInstruction(Instruction.Create(op));
		}
		public void neg(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Neg_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Neg_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Neg_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Neg_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(neg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void neg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Neg_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Neg_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Neg_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Neg_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(neg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void nop() {
			Code op;
			if (Bitness == 64) {
				op = Code.Nopq;
			} else if (Bitness == 32) {
				op = Code.Nopd;
			} else {
				op = Code.Nopw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void nop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Nop_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Nop_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Nop_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(nop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void nop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Nop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Nop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Nop_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(nop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void not(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Not_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Not_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Not_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Not_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(not)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void not(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Not_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Not_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Not_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Not_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(not)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void or(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Or_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Or_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Or_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Or_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Or_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Or_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Or_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Or_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Or_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Or_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Or_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Or_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Or_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Or_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Or_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void or(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Or_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Or_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Or_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Or_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Or_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Or_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Or_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void orpd(Register dst, Register src) {
			Code op;
			op = Code.Orpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void orps(Register dst, Register src) {
			Code op;
			op = Code.Orps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void @out(Register dst, Register src) {
			Code op;
			if (dst == Register.DX && src == Register.EAX) {
				op = Code.Out_DX_EAX;
			} else if (dst == Register.DX && src == Register.AX) {
				op = Code.Out_DX_AX;
			} else if (dst == Register.DX && src == Register.AL) {
				op = Code.Out_DX_AL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@out)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void @out(int imm, Register src) {
			Code op;
			if (src == Register.EAX) {
				op = Code.Out_imm8_EAX;
			} else if (src == Register.AX) {
				op = Code.Out_imm8_AX;
			} else if (src == Register.AL) {
				op = Code.Out_imm8_AL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@out)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, imm, src));
		}
		public void outsb(Register dst) {
			Code op;
			op = Code.Outsb_DX_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void outsd(Register dst) {
			Code op;
			op = Code.Outsd_DX_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void outsw(Register dst) {
			Code op;
			op = Code.Outsw_DX_m16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void pabsb(Register dst, Register src) {
			Code op;
			op = Code.Pabsb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pabsd(Register dst, Register src) {
			Code op;
			op = Code.Pabsd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pabsw(Register dst, Register src) {
			Code op;
			op = Code.Pabsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void packssdw(Register dst, Register src) {
			Code op;
			op = Code.Packssdw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void packsswb(Register dst, Register src) {
			Code op;
			op = Code.Packsswb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void packusdw(Register dst, Register src) {
			Code op;
			op = Code.Packusdw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void packuswb(Register dst, Register src) {
			Code op;
			op = Code.Packuswb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddb(Register dst, Register src) {
			Code op;
			op = Code.Paddb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddd(Register dst, Register src) {
			Code op;
			op = Code.Paddd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddq(Register dst, Register src) {
			Code op;
			op = Code.Paddq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddsb(Register dst, Register src) {
			Code op;
			op = Code.Paddsb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddsw(Register dst, Register src) {
			Code op;
			op = Code.Paddsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddusb(Register dst, Register src) {
			Code op;
			op = Code.Paddusb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddusw(Register dst, Register src) {
			Code op;
			op = Code.Paddusw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void paddw(Register dst, Register src) {
			Code op;
			op = Code.Paddw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void palignr(Register dst, Register src, int imm) {
			Code op;
			op = Code.Palignr_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pand(Register dst, Register src) {
			Code op;
			op = Code.Pand_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pandn(Register dst, Register src) {
			Code op;
			op = Code.Pandn_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pause() {
			Code op;
			op = Code.Pause;
			AddInstruction(Instruction.Create(op));
		}
		public void pavgb(Register dst, Register src) {
			Code op;
			op = Code.Pavgb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pavgw(Register dst, Register src) {
			Code op;
			op = Code.Pavgw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pblendvb(Register dst, Register src) {
			Code op;
			op = Code.Pblendvb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pblendw(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pblendw_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pclmulqdq(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pclmulqdq_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcmpeqb(Register dst, Register src) {
			Code op;
			op = Code.Pcmpeqb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpeqd(Register dst, Register src) {
			Code op;
			op = Code.Pcmpeqd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpeqq(Register dst, Register src) {
			Code op;
			op = Code.Pcmpeqq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpeqw(Register dst, Register src) {
			Code op;
			op = Code.Pcmpeqw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpestri(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pcmpestri_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcmpestri64(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pcmpestri64_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcmpestrm(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pcmpestrm_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcmpestrm64(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pcmpestrm64_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcmpgtb(Register dst, Register src) {
			Code op;
			op = Code.Pcmpgtb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpgtd(Register dst, Register src) {
			Code op;
			op = Code.Pcmpgtd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpgtq(Register dst, Register src) {
			Code op;
			op = Code.Pcmpgtq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpgtw(Register dst, Register src) {
			Code op;
			op = Code.Pcmpgtw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pcmpistri(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pcmpistri_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcmpistrm(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pcmpistrm_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pcommit() {
			Code op;
			op = Code.Pcommit;
			AddInstruction(Instruction.Create(op));
		}
		public void pconfig() {
			Code op;
			op = Code.Pconfig;
			AddInstruction(Instruction.Create(op));
		}
		public void pextrd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pextrd_rm32_xmm_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pextrd(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			op = Code.Pextrd_rm32_xmm_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pextrq(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pextrq_rm64_xmm_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pextrq(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			op = Code.Pextrq_rm64_xmm_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void phaddd(Register dst, Register src) {
			Code op;
			op = Code.Phaddd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void phaddsw(Register dst, Register src) {
			Code op;
			op = Code.Phaddsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void phaddw(Register dst, Register src) {
			Code op;
			op = Code.Phaddw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void phminposuw(Register dst, Register src) {
			Code op;
			op = Code.Phminposuw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void phsubd(Register dst, Register src) {
			Code op;
			op = Code.Phsubd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void phsubsw(Register dst, Register src) {
			Code op;
			op = Code.Phsubsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void phsubw(Register dst, Register src) {
			Code op;
			op = Code.Phsubw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pinsrd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pinsrd_xmm_rm32_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pinsrd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			op = Code.Pinsrd_xmm_rm32_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pinsrq(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pinsrq_xmm_rm64_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pinsrq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			op = Code.Pinsrq_xmm_rm64_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pmaddubsw(Register dst, Register src) {
			Code op;
			op = Code.Pmaddubsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaddwd(Register dst, Register src) {
			Code op;
			op = Code.Pmaddwd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaxsb(Register dst, Register src) {
			Code op;
			op = Code.Pmaxsb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaxsd(Register dst, Register src) {
			Code op;
			op = Code.Pmaxsd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaxsw(Register dst, Register src) {
			Code op;
			op = Code.Pmaxsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaxub(Register dst, Register src) {
			Code op;
			op = Code.Pmaxub_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaxud(Register dst, Register src) {
			Code op;
			op = Code.Pmaxud_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmaxuw(Register dst, Register src) {
			Code op;
			op = Code.Pmaxuw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pminsb(Register dst, Register src) {
			Code op;
			op = Code.Pminsb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pminsd(Register dst, Register src) {
			Code op;
			op = Code.Pminsd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pminsw(Register dst, Register src) {
			Code op;
			op = Code.Pminsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pminub(Register dst, Register src) {
			Code op;
			op = Code.Pminub_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pminud(Register dst, Register src) {
			Code op;
			op = Code.Pminud_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pminuw(Register dst, Register src) {
			Code op;
			op = Code.Pminuw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovsxbd(Register dst, Register src) {
			Code op;
			op = Code.Pmovsxbd_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovsxbq(Register dst, Register src) {
			Code op;
			op = Code.Pmovsxbq_xmm_xmmm16;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovsxbw(Register dst, Register src) {
			Code op;
			op = Code.Pmovsxbw_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovsxdq(Register dst, Register src) {
			Code op;
			op = Code.Pmovsxdq_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovsxwd(Register dst, Register src) {
			Code op;
			op = Code.Pmovsxwd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovsxwq(Register dst, Register src) {
			Code op;
			op = Code.Pmovsxwq_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovzxbd(Register dst, Register src) {
			Code op;
			op = Code.Pmovzxbd_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovzxbq(Register dst, Register src) {
			Code op;
			op = Code.Pmovzxbq_xmm_xmmm16;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovzxbw(Register dst, Register src) {
			Code op;
			op = Code.Pmovzxbw_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovzxdq(Register dst, Register src) {
			Code op;
			op = Code.Pmovzxdq_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovzxwd(Register dst, Register src) {
			Code op;
			op = Code.Pmovzxwd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmovzxwq(Register dst, Register src) {
			Code op;
			op = Code.Pmovzxwq_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmuldq(Register dst, Register src) {
			Code op;
			op = Code.Pmuldq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmulhrsw(Register dst, Register src) {
			Code op;
			op = Code.Pmulhrsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmulhuw(Register dst, Register src) {
			Code op;
			op = Code.Pmulhuw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmulhw(Register dst, Register src) {
			Code op;
			op = Code.Pmulhw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmulld(Register dst, Register src) {
			Code op;
			op = Code.Pmulld_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmullw(Register dst, Register src) {
			Code op;
			op = Code.Pmullw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pmuludq(Register dst, Register src) {
			Code op;
			op = Code.Pmuludq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Pop_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Pop_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Pop_r16;
			} else if (dst == Register.ES) {
				op = Bitness >= 32 ? Code.Popd_ES : Code.Popw_ES;
			} else if (dst == Register.CS) {
				op = Bitness >= 32 ? Code.Popw_CS : Code.Popw_CS;
			} else if (dst == Register.SS) {
				op = Bitness >= 32 ? Code.Popd_SS : Code.Popw_SS;
			} else if (dst == Register.DS) {
				op = Bitness >= 32 ? Code.Popd_DS : Code.Popw_DS;
			} else if (dst == Register.FS) {
				op = Bitness >= 32 ? Code.Popd_FS : Code.Popw_FS;
			} else if (dst == Register.GS) {
				op = Bitness >= 32 ? Code.Popd_GS : Code.Popw_GS;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(pop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void pop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Pop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Pop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pop_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(pop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void popa() {
			Code op;
			if (Bitness >= 32) {
				op = Code.Popad;
			} else {
				op = Code.Popaw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void popcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(popcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void popcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(popcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void popf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Popfq;
			} else if (Bitness == 32) {
				op = Code.Popfd;
			} else {
				op = Code.Popfw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void por(Register dst, Register src) {
			Code op;
			op = Code.Por_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psadbw(Register dst, Register src) {
			Code op;
			op = Code.Psadbw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pshufb(Register dst, Register src) {
			Code op;
			op = Code.Pshufb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pshufd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pshufd_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pshufhw(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pshufhw_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void pshuflw(Register dst, Register src, int imm) {
			Code op;
			op = Code.Pshuflw_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void psignb(Register dst, Register src) {
			Code op;
			op = Code.Psignb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psignd(Register dst, Register src) {
			Code op;
			op = Code.Psignd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psignw(Register dst, Register src) {
			Code op;
			op = Code.Psignw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pslld(Register dst, Register src) {
			Code op;
			op = Code.Pslld_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psllq(Register dst, Register src) {
			Code op;
			op = Code.Psllq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psllw(Register dst, Register src) {
			Code op;
			op = Code.Psllw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psrad(Register dst, Register src) {
			Code op;
			op = Code.Psrad_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psraw(Register dst, Register src) {
			Code op;
			op = Code.Psraw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psrld(Register dst, Register src) {
			Code op;
			op = Code.Psrld_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psrlq(Register dst, Register src) {
			Code op;
			op = Code.Psrlq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psrlw(Register dst, Register src) {
			Code op;
			op = Code.Psrlw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubb(Register dst, Register src) {
			Code op;
			op = Code.Psubb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubd(Register dst, Register src) {
			Code op;
			op = Code.Psubd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubq(Register dst, Register src) {
			Code op;
			op = Code.Psubq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubsb(Register dst, Register src) {
			Code op;
			op = Code.Psubsb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubsw(Register dst, Register src) {
			Code op;
			op = Code.Psubsw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubusb(Register dst, Register src) {
			Code op;
			op = Code.Psubusb_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubusw(Register dst, Register src) {
			Code op;
			op = Code.Psubusw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void psubw(Register dst, Register src) {
			Code op;
			op = Code.Psubw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ptest(Register dst, Register src) {
			Code op;
			op = Code.Ptest_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ptwrite(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ptwrite_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ptwrite_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ptwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ptwrite(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ptwrite_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ptwrite_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ptwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void punpckhbw(Register dst, Register src) {
			Code op;
			op = Code.Punpckhbw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpckhdq(Register dst, Register src) {
			Code op;
			op = Code.Punpckhdq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpckhqdq(Register dst, Register src) {
			Code op;
			op = Code.Punpckhqdq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpckhwd(Register dst, Register src) {
			Code op;
			op = Code.Punpckhwd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpcklbw(Register dst, Register src) {
			Code op;
			op = Code.Punpcklbw_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpckldq(Register dst, Register src) {
			Code op;
			op = Code.Punpckldq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpcklqdq(Register dst, Register src) {
			Code op;
			op = Code.Punpcklqdq_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void punpcklwd(Register dst, Register src) {
			Code op;
			op = Code.Punpcklwd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void push(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Push_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Push_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Push_r16;
			} else if (dst == Register.ES) {
				op = Bitness >= 32 ? Code.Pushd_ES : Code.Pushw_ES;
			} else if (dst == Register.CS) {
				op = Bitness >= 32 ? Code.Pushd_CS : Code.Pushw_CS;
			} else if (dst == Register.SS) {
				op = Bitness >= 32 ? Code.Pushd_SS : Code.Pushw_SS;
			} else if (dst == Register.DS) {
				op = Bitness >= 32 ? Code.Pushd_DS : Code.Pushw_DS;
			} else if (dst == Register.FS) {
				op = Bitness >= 32 ? Code.Pushd_FS : Code.Pushw_FS;
			} else if (dst == Register.GS) {
				op = Bitness >= 32 ? Code.Pushd_GS : Code.Pushw_GS;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(push)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Push_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Push_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Push_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(push)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Pushq_imm32;
			} else if (Bitness == 32) {
				op = Code.Pushd_imm32;
			} else {
				op = Code.Push_imm16;
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		public void pusha() {
			Code op;
			if (Bitness >= 32) {
				op = Code.Pushad;
			} else {
				op = Code.Pushaw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void pushf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Pushfq;
			} else if (Bitness == 32) {
				op = Code.Pushfd;
			} else {
				op = Code.Pushfw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void pxor(Register dst, Register src) {
			Code op;
			op = Code.Pxor_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rcl_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rcl_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rcl_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rcl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcl_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcl_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcl_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcl(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rcl_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rcl_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rcl_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rcl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rcl_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rcl_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rcl_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rcl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rcl(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rcl_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rcl_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rcl_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rcl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcl_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcl_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcl_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rcpps(Register dst, Register src) {
			Code op;
			op = Code.Rcpps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcpss(Register dst, Register src) {
			Code op;
			op = Code.Rcpss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rcr_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rcr_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rcr_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rcr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcr_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcr_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcr_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcr(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rcr_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rcr_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rcr_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rcr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rcr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rcr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rcr_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rcr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rcr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rcr_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rcr_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rcr_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rcr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcr_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rdmsr() {
			Code op;
			op = Code.Rdmsr;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpkru() {
			Code op;
			op = Code.Rdpkru;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpmc() {
			Code op;
			op = Code.Rdpmc;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpru() {
			Code op;
			op = Code.Rdpru;
			AddInstruction(Instruction.Create(op));
		}
		public void rdtsc() {
			Code op;
			op = Code.Rdtsc;
			AddInstruction(Instruction.Create(op));
		}
		public void rdtscp() {
			Code op;
			op = Code.Rdtscp;
			AddInstruction(Instruction.Create(op));
		}
		public void ret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Retnq;
			} else if (Bitness == 32) {
				op = Code.Retnd;
			} else {
				op = Code.Retnw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void ret(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Retnq_imm16;
			} else if (Bitness == 32) {
				op = Code.Retnd_imm16;
			} else {
				op = Code.Retnw_imm16;
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		public void retf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Retfq;
			} else if (Bitness == 32) {
				op = Code.Retfd;
			} else {
				op = Code.Retfw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void retf(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Retfq_imm16;
			} else if (Bitness == 32) {
				op = Code.Retfd_imm16;
			} else {
				op = Code.Retfw_imm16;
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		public void rol(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rol_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rol_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rol_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rol_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rol(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rol_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rol_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rol_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rol_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rol(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rol_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rol_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rol_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rol_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rol_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rol_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rol_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rol_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rol(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rol_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rol_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rol_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rol_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rol_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rol_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rol_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rol_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void ror(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ror_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Ror_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Ror_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Ror_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ror(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ror_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ror_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ror_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Ror_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ror(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Ror_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Ror_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Ror_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Ror_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Ror_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Ror_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Ror_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Ror_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void ror(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Ror_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Ror_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Ror_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Ror_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ror_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ror_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ror_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Ror_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void roundpd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Roundpd_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void roundps(Register dst, Register src, int imm) {
			Code op;
			op = Code.Roundps_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void roundsd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Roundsd_xmm_xmmm64_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void roundss(Register dst, Register src, int imm) {
			Code op;
			op = Code.Roundss_xmm_xmmm32_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void rsm() {
			Code op;
			op = Code.Rsm;
			AddInstruction(Instruction.Create(op));
		}
		public void rsqrtps(Register dst, Register src) {
			Code op;
			op = Code.Rsqrtps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rsqrtss(Register dst, Register src) {
			Code op;
			op = Code.Rsqrtss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sahf() {
			Code op;
			op = Code.Sahf;
			AddInstruction(Instruction.Create(op));
		}
		public void sal(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sal_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Sal_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Sal_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Sal_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sal(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sal_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sal_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sal_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sal_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sal(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Sal_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Sal_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Sal_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Sal_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Sal_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Sal_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Sal_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Sal_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sal(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sal_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sal_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sal_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sal_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sal_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sal_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sal_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sal_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void salc() {
			Code op;
			op = Code.Salc;
			AddInstruction(Instruction.Create(op));
		}
		public void sar(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sar_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Sar_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Sar_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Sar_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sar(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sar_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sar_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sar_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sar_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sar(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Sar_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Sar_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Sar_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Sar_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Sar_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Sar_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Sar_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Sar_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sar(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sar_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sar_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sar_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sar_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sar_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sar_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sar_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sar_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void saveprevssp() {
			Code op;
			op = Code.Saveprevssp;
			AddInstruction(Instruction.Create(op));
		}
		public void sbb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sbb_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sbb_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sbb_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Sbb_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Sbb_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Sbb_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Sbb_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Sbb_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Sbb_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Sbb_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Sbb_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Sbb_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sbb(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sbb_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sbb_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sbb_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sbb_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sbb_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sbb_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sbb_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void scasb(Register dst) {
			Code op;
			op = Code.Scasb_AL_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void scasd(Register dst) {
			Code op;
			op = Code.Scasd_EAX_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void scasq(Register dst) {
			Code op;
			op = Code.Scasq_RAX_m64;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void scasw(Register dst) {
			Code op;
			op = Code.Scasw_AX_m16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seta(Register dst) {
			Code op;
			op = Code.Seta_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seta(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Seta_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setae(Register dst) {
			Code op;
			op = Code.Setae_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setae(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setae_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setb(Register dst) {
			Code op;
			op = Code.Setb_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setb(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setb_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setbe(Register dst) {
			Code op;
			op = Code.Setbe_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setbe(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setbe_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sete(Register dst) {
			Code op;
			op = Code.Sete_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sete(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Sete_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setg(Register dst) {
			Code op;
			op = Code.Setg_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setg(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setg_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setge(Register dst) {
			Code op;
			op = Code.Setge_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setge(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setge_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setl(Register dst) {
			Code op;
			op = Code.Setl_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setl(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setl_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setle(Register dst) {
			Code op;
			op = Code.Setle_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setle(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setle_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setne(Register dst) {
			Code op;
			op = Code.Setne_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setne(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setne_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setno(Register dst) {
			Code op;
			op = Code.Setno_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setno(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setno_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setnp(Register dst) {
			Code op;
			op = Code.Setnp_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setnp(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setnp_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setns(Register dst) {
			Code op;
			op = Code.Setns_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setns(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setns_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seto(Register dst) {
			Code op;
			op = Code.Seto_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seto(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Seto_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setp(Register dst) {
			Code op;
			op = Code.Setp_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setp(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Setp_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sets(Register dst) {
			Code op;
			op = Code.Sets_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sets(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Sets_rm8;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setssbsy() {
			Code op;
			op = Code.Setssbsy;
			AddInstruction(Instruction.Create(op));
		}
		public void sfence() {
			Code op;
			op = Code.Sfence;
			AddInstruction(Instruction.Create(op));
		}
		public void sha1msg1(Register dst, Register src) {
			Code op;
			op = Code.Sha1msg1_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sha1msg2(Register dst, Register src) {
			Code op;
			op = Code.Sha1msg2_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sha1nexte(Register dst, Register src) {
			Code op;
			op = Code.Sha1nexte_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sha1rnds4(Register dst, Register src, int imm) {
			Code op;
			op = Code.Sha1rnds4_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void sha256msg1(Register dst, Register src) {
			Code op;
			op = Code.Sha256msg1_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sha256msg2(Register dst, Register src) {
			Code op;
			op = Code.Sha256msg2_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sha256rnds2(Register dst, Register src) {
			Code op;
			op = Code.Sha256rnds2_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shl_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shl_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shl_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Shl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shl_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shl_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shl_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shl(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Shl_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Shl_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Shl_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Shl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Shl_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shl_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shl_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Shl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shl(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Shl_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Shl_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Shl_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Shl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shl_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shl_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shl_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shld_rm64_r64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shld_rm32_r32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shld_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shld(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shld_rm64_r64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shld_rm32_r32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shld_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shld(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shld_rm64_r64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shld_rm32_r32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shld_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shld(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shld_rm64_r64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shld_rm32_r32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shld_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shr_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shr_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shr_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Shr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shr_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shr_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shr_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shr(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Shr_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Shr_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Shr_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Shr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Shr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shr_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Shr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Shr_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Shr_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Shr_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Shr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shr_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shrd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shrd_rm64_r64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shrd_rm32_r32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shrd_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shrd(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shrd_rm64_r64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shrd_rm32_r32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shrd_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shrd_rm64_r64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shrd_rm32_r32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shrd_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shrd(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shrd_rm64_r64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shrd_rm32_r32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shrd_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shufpd(Register dst, Register src, int imm) {
			Code op;
			op = Code.Shufpd_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shufps(Register dst, Register src, int imm) {
			Code op;
			op = Code.Shufps_xmm_xmmm128_imm8;
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void skinit() {
			Code op;
			op = Code.Skinit;
			AddInstruction(Instruction.Create(op));
		}
		public void sldt(Register dst) {
			Code op;
			op = Code.Sldt_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sldt(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Sldt_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void smsw(Register dst) {
			Code op;
			op = Code.Smsw_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void smsw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Smsw_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sqrtpd(Register dst, Register src) {
			Code op;
			op = Code.Sqrtpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sqrtps(Register dst, Register src) {
			Code op;
			op = Code.Sqrtps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sqrtsd(Register dst, Register src) {
			Code op;
			op = Code.Sqrtsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sqrtss(Register dst, Register src) {
			Code op;
			op = Code.Sqrtss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void stac() {
			Code op;
			op = Code.Stac;
			AddInstruction(Instruction.Create(op));
		}
		public void stc() {
			Code op;
			op = Code.Stc;
			AddInstruction(Instruction.Create(op));
		}
		public void std() {
			Code op;
			op = Code.Std;
			AddInstruction(Instruction.Create(op));
		}
		public void stgi() {
			Code op;
			op = Code.Stgi;
			AddInstruction(Instruction.Create(op));
		}
		public void sti() {
			Code op;
			op = Code.Sti;
			AddInstruction(Instruction.Create(op));
		}
		public void stosb(Register src) {
			Code op;
			op = Code.Stosb_m8_AL;
			AddInstruction(Instruction.Create(op, src));
		}
		public void stosd(Register src) {
			Code op;
			op = Code.Stosd_m32_EAX;
			AddInstruction(Instruction.Create(op, src));
		}
		public void stosq(Register src) {
			Code op;
			op = Code.Stosq_m64_RAX;
			AddInstruction(Instruction.Create(op, src));
		}
		public void stosw(Register src) {
			Code op;
			op = Code.Stosw_m16_AX;
			AddInstruction(Instruction.Create(op, src));
		}
		public void str(Register dst) {
			Code op;
			op = Code.Str_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void str(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Str_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sub(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sub_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sub_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sub_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sub_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Sub_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Sub_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Sub_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Sub_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Sub_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Sub_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Sub_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Sub_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Sub_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sub(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sub_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sub_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sub_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sub_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sub_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sub_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sub_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void subpd(Register dst, Register src) {
			Code op;
			op = Code.Subpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void subps(Register dst, Register src) {
			Code op;
			op = Code.Subps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void subsd(Register dst, Register src) {
			Code op;
			op = Code.Subsd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void subss(Register dst, Register src) {
			Code op;
			op = Code.Subss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void swapgs() {
			Code op;
			op = Code.Swapgs;
			AddInstruction(Instruction.Create(op));
		}
		public void syscall() {
			Code op;
			op = Code.Syscall;
			AddInstruction(Instruction.Create(op));
		}
		public void sysenter() {
			Code op;
			op = Code.Sysenter;
			AddInstruction(Instruction.Create(op));
		}
		public void sysexit() {
			Code op;
			if (Bitness == 64) {
				op = Code.Sysexitq;
			} else {
				op = Code.Sysexitd;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void sysret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Sysretq;
			} else {
				op = Code.Sysretd;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void test(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Test_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Test_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Test_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Test_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void test(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Test_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Test_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Test_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Test_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void test(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst == Register.AL) {
					op = Code.Test_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Test_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Test_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Test_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Test_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Test_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Test_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Test_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void test(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Test_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Test_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Test_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Test_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void tzcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(tzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void tzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(tzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ucomisd(Register dst, Register src) {
			Code op;
			op = Code.Ucomisd_xmm_xmmm64;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ucomiss(Register dst, Register src) {
			Code op;
			op = Code.Ucomiss_xmm_xmmm32;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud0(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud0)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud0(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud0)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud1(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud1)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud1(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud1)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud2() {
			Code op;
			op = Code.Ud2;
			AddInstruction(Instruction.Create(op));
		}
		public void umov(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void umov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Umov_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Umov_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Umov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void umov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void unpckhpd(Register dst, Register src) {
			Code op;
			op = Code.Unpckhpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void unpckhps(Register dst, Register src) {
			Code op;
			op = Code.Unpckhps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void unpcklpd(Register dst, Register src) {
			Code op;
			op = Code.Unpcklpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void unpcklps(Register dst, Register src) {
			Code op;
			op = Code.Unpcklps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void verr(Register dst) {
			Code op;
			op = Code.Verr_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verr(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Verr_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verw(Register dst) {
			Code op;
			op = Code.Verw_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Verw_rm16;
			AddInstruction(Instruction.Create(op, dst));
		}
		public void vmcall() {
			Code op;
			op = Code.Vmcall;
			AddInstruction(Instruction.Create(op));
		}
		public void vmfunc() {
			Code op;
			op = Code.Vmfunc;
			AddInstruction(Instruction.Create(op));
		}
		public void vmlaunch() {
			Code op;
			op = Code.Vmlaunch;
			AddInstruction(Instruction.Create(op));
		}
		public void vmload() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmloadq;
			} else if (Bitness == 32) {
				op = Code.Vmloadd;
			} else {
				op = Code.Vmloadw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void vmmcall() {
			Code op;
			op = Code.Vmmcall;
			AddInstruction(Instruction.Create(op));
		}
		public void vmread(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmread_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmread)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmread(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Vmread_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmread)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmresume() {
			Code op;
			op = Code.Vmresume;
			AddInstruction(Instruction.Create(op));
		}
		public void vmrun() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmrunq;
			} else if (Bitness == 32) {
				op = Code.Vmrund;
			} else {
				op = Code.Vmrunw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void vmsave() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmsaveq;
			} else if (Bitness == 32) {
				op = Code.Vmsaved;
			} else {
				op = Code.Vmsavew;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void vmwrite(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmwrite(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmxoff() {
			Code op;
			op = Code.Vmxoff;
			AddInstruction(Instruction.Create(op));
		}
		public void wait() {
			Code op;
			op = Code.Wait;
			AddInstruction(Instruction.Create(op));
		}
		public void wbinvd() {
			Code op;
			op = Code.Wbinvd;
			AddInstruction(Instruction.Create(op));
		}
		public void wbnoinvd() {
			Code op;
			op = Code.Wbnoinvd;
			AddInstruction(Instruction.Create(op));
		}
		public void wrmsr() {
			Code op;
			op = Code.Wrmsr;
			AddInstruction(Instruction.Create(op));
		}
		public void wrpkru() {
			Code op;
			op = Code.Wrpkru;
			AddInstruction(Instruction.Create(op));
		}
		public void xabort(int imm) {
			Code op;
			op = Code.Xabort_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void xadd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xadd_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Xadd_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Xadd_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xadd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xadd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xadd_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xadd_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xadd_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xadd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xbts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xbts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xbts(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xbts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xchg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src == Register.RAX) {
				op = Code.Xchg_r64_RAX;
			} else if (dst.IsGPR64() && src.IsGPR64()) {
				op = Code.Xchg_rm64_r64;
			} else if (dst.IsGPR32() && src == Register.EAX) {
				op = Code.Xchg_r32_EAX;
			} else if (dst.IsGPR32() && src.IsGPR32()) {
				op = Code.Xchg_rm32_r32;
			} else if (dst.IsGPR16() && src == Register.AX) {
				op = Code.Xchg_r16_AX;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Xchg_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xchg_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xchg_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xchg_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xcryptcbc() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCbc_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCbc_32;
			} else {
				op = Code.XcryptCbc_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptcfb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCfb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCfb_32;
			} else {
				op = Code.XcryptCfb_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptctr() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCtr_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCtr_32;
			} else {
				op = Code.XcryptCtr_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptecb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptEcb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptEcb_32;
			} else {
				op = Code.XcryptEcb_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptofb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptOfb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptOfb_32;
			} else {
				op = Code.XcryptOfb_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xend() {
			Code op;
			op = Code.Xend;
			AddInstruction(Instruction.Create(op));
		}
		public void xgetbv() {
			Code op;
			op = Code.Xgetbv;
			AddInstruction(Instruction.Create(op));
		}
		public void xor(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xor_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xor_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xor_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xor_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Xor_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Xor_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Xor_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Xor_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Xor_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Xor_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Xor_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Xor_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Xor_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void xor(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Xor_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Xor_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Xor_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Xor_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xor_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xor_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xor_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void xorpd(Register dst, Register src) {
			Code op;
			op = Code.Xorpd_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xorps(Register dst, Register src) {
			Code op;
			op = Code.Xorps_xmm_xmmm128;
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xsetbv() {
			Code op;
			op = Code.Xsetbv;
			AddInstruction(Instruction.Create(op));
		}
		public void xsha1() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xsha1_64;
			} else if (Bitness == 32) {
				op = Code.Xsha1_32;
			} else {
				op = Code.Xsha1_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xsha256() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xsha256_64;
			} else if (Bitness == 32) {
				op = Code.Xsha256_32;
			} else {
				op = Code.Xsha256_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xstore() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xstore_64;
			} else if (Bitness == 32) {
				op = Code.Xstore_32;
			} else {
				op = Code.Xstore_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xtest() {
			Code op;
			op = Code.Xtest;
			AddInstruction(Instruction.Create(op));
		}
	}
}
#endif
