/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#nullable enable

#if !NO_ENCODER
namespace Iced.Intel {
	using System;
	public sealed partial class ExtendedEncoder {
		/// <summary>aaa instruction.<br/>
		/// <br/>
		/// <c>AAA</c><br/>
		/// <br/>
		/// <c>37</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void aaa() {
			Code op;
			op = Code.Aaa;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>aad instruction.<br/>
		/// <br/>
		/// </summary>
		public void aad(int imm) {
			Code op;
			op = Code.Aad_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>aam instruction.<br/>
		/// <br/>
		/// </summary>
		public void aam(int imm) {
			Code op;
			op = Code.Aam_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>aas instruction.<br/>
		/// <br/>
		/// <c>AAS</c><br/>
		/// <br/>
		/// <c>3F</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void aas() {
			Code op;
			op = Code.Aas;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>adc instruction.<br/>
		/// <br/>
		/// <c>ADC r/m8, r8</c><br/>
		/// <br/>
		/// <c>10 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 11 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 11 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 11 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(adc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>adc instruction.<br/>
		/// <br/>
		/// <c>ADC r/m8, r8</c><br/>
		/// <br/>
		/// <c>10 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 11 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 11 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 11 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Adc_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Adc_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Adc_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Adc_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(adc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>adc instruction.<br/>
		/// <br/>
		/// <c>ADC r8, r/m8</c><br/>
		/// <br/>
		/// <c>12 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 13 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 13 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 13 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(adc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>adc instruction.<br/>
		/// <br/>
		/// <c>ADC AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 15 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 15 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 15 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>ADC r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /2 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /2 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /2 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adc(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Adc_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Adc_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Adc_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Adc_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Adc_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(adc), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Adc_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Adc_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Adc_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Adc_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(adc), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>adc instruction.<br/>
		/// <br/>
		/// <c>ADC r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /2 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /2 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADC r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /2 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adc(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Adc_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Adc_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Adc_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Adc_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(adc), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Adc_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Adc_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Adc_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(adc), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>adcx instruction.<br/>
		/// <br/>
		/// <c>ADCX r32, r/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADCX r64, r/m64</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adcx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(adcx), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>adcx instruction.<br/>
		/// <br/>
		/// <c>ADCX r32, r/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADCX r64, r/m64</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adcx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(adcx), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>add instruction.<br/>
		/// <br/>
		/// <c>ADD r/m8, r8</c><br/>
		/// <br/>
		/// <c>00 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 01 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 01 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 01 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void add(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(add), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>add instruction.<br/>
		/// <br/>
		/// <c>ADD r/m8, r8</c><br/>
		/// <br/>
		/// <c>00 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 01 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 01 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 01 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void add(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Add_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Add_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Add_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Add_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(add), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>add instruction.<br/>
		/// <br/>
		/// <c>ADD r8, r/m8</c><br/>
		/// <br/>
		/// <c>02 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 03 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 03 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 03 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void add(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(add), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>add instruction.<br/>
		/// <br/>
		/// <c>ADD AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 05 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 05 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 05 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>ADD r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /0 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /0 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /0 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void add(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Add_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Add_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Add_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Add_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Add_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(add), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Add_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Add_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Add_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Add_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Add_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Add_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(add), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>add instruction.<br/>
		/// <br/>
		/// <c>ADD r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /0 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /0 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADD r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /0 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void add(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Add_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Add_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Add_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Add_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(add), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Add_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Add_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Add_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(add), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>addpd instruction.<br/>
		/// <br/>
		/// <c>ADDPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addpd instruction.<br/>
		/// <br/>
		/// <c>ADDPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addps instruction.<br/>
		/// <br/>
		/// <c>ADDPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addps instruction.<br/>
		/// <br/>
		/// <c>ADDPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addsd instruction.<br/>
		/// <br/>
		/// <c>ADDSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(addsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addsd instruction.<br/>
		/// <br/>
		/// <c>ADDSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(addsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addss instruction.<br/>
		/// <br/>
		/// <c>ADDSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(addss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addss instruction.<br/>
		/// <br/>
		/// <c>ADDSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 58 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(addss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addsubpd instruction.<br/>
		/// <br/>
		/// <c>ADDSUBPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D0 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addsubpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addsubpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addsubpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addsubpd instruction.<br/>
		/// <br/>
		/// <c>ADDSUBPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D0 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addsubpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addsubpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addsubpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addsubps instruction.<br/>
		/// <br/>
		/// <c>ADDSUBPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F D0 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addsubps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addsubps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addsubps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>addsubps instruction.<br/>
		/// <br/>
		/// <c>ADDSUBPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F D0 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void addsubps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Addsubps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(addsubps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>adox instruction.<br/>
		/// <br/>
		/// <c>ADOX r32, r/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADOX r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adox(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(adox), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>adox instruction.<br/>
		/// <br/>
		/// <c>ADOX r32, r/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ADOX r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>ADX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void adox(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(adox), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesdec instruction.<br/>
		/// <br/>
		/// <c>AESDEC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DE /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesdec(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesdec_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesdec), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesdec instruction.<br/>
		/// <br/>
		/// <c>AESDEC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DE /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesdec(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesdec_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesdec), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesdeclast instruction.<br/>
		/// <br/>
		/// <c>AESDECLAST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DF /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesdeclast(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesdeclast_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesdeclast), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesdeclast instruction.<br/>
		/// <br/>
		/// <c>AESDECLAST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DF /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesdeclast(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesdeclast_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesdeclast), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesenc instruction.<br/>
		/// <br/>
		/// <c>AESENC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DC /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesenc(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesenc_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesenc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesenc instruction.<br/>
		/// <br/>
		/// <c>AESENC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DC /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesenc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesenc_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesenc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesenclast instruction.<br/>
		/// <br/>
		/// <c>AESENCLAST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DD /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesenclast(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesenclast_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesenclast), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesenclast instruction.<br/>
		/// <br/>
		/// <c>AESENCLAST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DD /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesenclast(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesenclast_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesenclast), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesimc instruction.<br/>
		/// <br/>
		/// <c>AESIMC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DB /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesimc(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesimc_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesimc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aesimc instruction.<br/>
		/// <br/>
		/// <c>AESIMC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 DB /r</c><br/>
		/// <br/>
		/// <c>AES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void aesimc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aesimc_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(aesimc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>aeskeygenassist instruction.<br/>
		/// <br/>
		/// </summary>
		public void aeskeygenassist(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aeskeygenassist_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(aeskeygenassist), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>aeskeygenassist instruction.<br/>
		/// <br/>
		/// </summary>
		public void aeskeygenassist(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Aeskeygenassist_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(aeskeygenassist), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>and instruction.<br/>
		/// <br/>
		/// <c>AND r/m8, r8</c><br/>
		/// <br/>
		/// <c>20 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 21 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 21 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 21 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void and(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.And_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.And_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.And_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(and), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>and instruction.<br/>
		/// <br/>
		/// <c>AND r/m8, r8</c><br/>
		/// <br/>
		/// <c>20 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 21 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 21 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 21 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void and(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.And_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.And_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.And_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.And_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(and), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>and instruction.<br/>
		/// <br/>
		/// <c>AND r8, r/m8</c><br/>
		/// <br/>
		/// <c>22 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 23 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 23 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 23 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void and(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.And_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.And_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.And_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(and), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>and instruction.<br/>
		/// <br/>
		/// <c>AND AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 25 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 25 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 25 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>AND r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /4 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /4 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /4 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void and(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.And_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.And_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.And_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.And_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.And_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(and), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.And_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.And_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.And_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.And_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.And_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.And_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(and), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>and instruction.<br/>
		/// <br/>
		/// <c>AND r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /4 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /4 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>AND r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /4 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void and(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.And_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.And_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.And_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.And_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(and), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.And_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.And_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.And_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(and), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>andn instruction.<br/>
		/// <br/>
		/// <c>ANDN r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F2 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ANDN r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F2 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void andn(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Andn_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Andn_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(andn), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>andn instruction.<br/>
		/// <br/>
		/// <c>ANDN r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F2 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ANDN r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F2 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void andn(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Andn_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Andn_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(andn), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>andnpd instruction.<br/>
		/// <br/>
		/// <c>ANDNPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 55 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andnpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andnpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andnpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andnpd instruction.<br/>
		/// <br/>
		/// <c>ANDNPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 55 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andnpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andnpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andnpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andnps instruction.<br/>
		/// <br/>
		/// <c>ANDNPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 55 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andnps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andnps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andnps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andnps instruction.<br/>
		/// <br/>
		/// <c>ANDNPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 55 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andnps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andnps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andnps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andpd instruction.<br/>
		/// <br/>
		/// <c>ANDPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 54 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andpd instruction.<br/>
		/// <br/>
		/// <c>ANDPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 54 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andps instruction.<br/>
		/// <br/>
		/// <c>ANDPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 54 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>andps instruction.<br/>
		/// <br/>
		/// <c>ANDPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 54 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void andps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Andps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(andps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>arpl instruction.<br/>
		/// <br/>
		/// <c>ARPL r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 63 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>ARPL r32/m16, r32</c><br/>
		/// <br/>
		/// <c>o32 63 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void arpl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Arpl_r32m16_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Arpl_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(arpl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>arpl instruction.<br/>
		/// <br/>
		/// <c>ARPL r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 63 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>ARPL r32/m16, r32</c><br/>
		/// <br/>
		/// <c>o32 63 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void arpl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Arpl_r32m16_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Arpl_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(arpl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bextr instruction.<br/>
		/// <br/>
		/// <c>BEXTR r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BEXTR r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bextr(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Bextr_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Bextr_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(bextr), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>bextr instruction.<br/>
		/// <br/>
		/// <c>BEXTR r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BEXTR r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bextr(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Bextr_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Bextr_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(bextr), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>bextr instruction.<br/>
		/// <br/>
		/// <c>BEXTR r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W0 10 /r id</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BEXTR r64, r/m64, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W1 10 /r id</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bextr(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Bextr_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Bextr_r32_rm32_imm32;
			} else {
				throw NoOpCodeFoundFor(nameof(bextr), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>bextr instruction.<br/>
		/// <br/>
		/// <c>BEXTR r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W0 10 /r id</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BEXTR r64, r/m64, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W1 10 /r id</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bextr(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Bextr_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Bextr_r32_rm32_imm32;
			} else {
				throw NoOpCodeFoundFor(nameof(bextr), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>blcfill instruction.<br/>
		/// <br/>
		/// <c>BLCFILL r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCFILL r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcfill(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcfill_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcfill_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcfill), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcfill instruction.<br/>
		/// <br/>
		/// <c>BLCFILL r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCFILL r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcfill(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcfill_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcfill_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcfill), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blci instruction.<br/>
		/// <br/>
		/// <c>BLCI r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 02 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCI r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 02 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blci(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blci_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blci_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blci), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blci instruction.<br/>
		/// <br/>
		/// <c>BLCI r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 02 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCI r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 02 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blci(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blci_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blci_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blci), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcic instruction.<br/>
		/// <br/>
		/// <c>BLCIC r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /5</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCIC r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /5</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcic(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcic_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcic_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcic), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcic instruction.<br/>
		/// <br/>
		/// <c>BLCIC r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /5</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCIC r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /5</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcic(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcic_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcic_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcic), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcmsk instruction.<br/>
		/// <br/>
		/// <c>BLCMSK r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 02 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCMSK r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 02 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcmsk(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcmsk_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcmsk_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcmsk), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcmsk instruction.<br/>
		/// <br/>
		/// <c>BLCMSK r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 02 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCMSK r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 02 /1</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcmsk(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcmsk_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcmsk_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcmsk), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcs instruction.<br/>
		/// <br/>
		/// <c>BLCS r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /3</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCS r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /3</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcs(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcs_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcs), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blcs instruction.<br/>
		/// <br/>
		/// <c>BLCS r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /3</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLCS r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /3</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blcs(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blcs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blcs_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blcs), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blendpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void blendpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(blendpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>blendpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void blendpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(blendpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>blendps instruction.<br/>
		/// <br/>
		/// </summary>
		public void blendps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(blendps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>blendps instruction.<br/>
		/// <br/>
		/// </summary>
		public void blendps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(blendps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>blendvpd instruction.<br/>
		/// <br/>
		/// <c>BLENDVPD xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>66 0F 38 15 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void blendvpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendvpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(blendvpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blendvpd instruction.<br/>
		/// <br/>
		/// <c>BLENDVPD xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>66 0F 38 15 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void blendvpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendvpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(blendvpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blendvps instruction.<br/>
		/// <br/>
		/// <c>BLENDVPS xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>66 0F 38 14 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void blendvps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendvps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(blendvps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blendvps instruction.<br/>
		/// <br/>
		/// <c>BLENDVPS xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>66 0F 38 14 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void blendvps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Blendvps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(blendvps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsfill instruction.<br/>
		/// <br/>
		/// <c>BLSFILL r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /2</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSFILL r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /2</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsfill(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blsfill_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blsfill_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsfill), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsfill instruction.<br/>
		/// <br/>
		/// <c>BLSFILL r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /2</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSFILL r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /2</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsfill(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blsfill_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blsfill_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsfill), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsi instruction.<br/>
		/// <br/>
		/// <c>BLSI r32, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F3 /3</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSI r64, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F3 /3</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsi(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Blsi_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Blsi_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsi instruction.<br/>
		/// <br/>
		/// <c>BLSI r32, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F3 /3</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSI r64, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F3 /3</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Blsi_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Blsi_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsic instruction.<br/>
		/// <br/>
		/// <c>BLSIC r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSIC r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsic(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blsic_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blsic_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsic), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsic instruction.<br/>
		/// <br/>
		/// <c>BLSIC r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSIC r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /6</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsic(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Blsic_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Blsic_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsic), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsmsk instruction.<br/>
		/// <br/>
		/// <c>BLSMSK r32, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F3 /2</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSMSK r64, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F3 /2</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsmsk(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Blsmsk_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Blsmsk_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsmsk), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsmsk instruction.<br/>
		/// <br/>
		/// <c>BLSMSK r32, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F3 /2</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSMSK r64, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F3 /2</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsmsk(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Blsmsk_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Blsmsk_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsmsk), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsr instruction.<br/>
		/// <br/>
		/// <c>BLSR r32, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F3 /1</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSR r64, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F3 /1</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Blsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Blsr_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>blsr instruction.<br/>
		/// <br/>
		/// <c>BLSR r32, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F3 /1</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BLSR r64, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F3 /1</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void blsr(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Blsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Blsr_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(blsr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bsf instruction.<br/>
		/// <br/>
		/// <c>BSF r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F BC /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSF r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F BC /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSF r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F BC /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bsf(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(bsf), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bsf instruction.<br/>
		/// <br/>
		/// <c>BSF r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F BC /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSF r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F BC /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSF r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F BC /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bsf(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(bsf), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bsr instruction.<br/>
		/// <br/>
		/// <c>BSR r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F BD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSR r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F BD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSR r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F BD /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bsr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(bsr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bsr instruction.<br/>
		/// <br/>
		/// <c>BSR r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F BD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSR r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F BD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSR r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F BD /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bsr(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(bsr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bswap instruction.<br/>
		/// <br/>
		/// <c>BSWAP r16</c><br/>
		/// <br/>
		/// <c>o16 0F C8+rw</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSWAP r32</c><br/>
		/// <br/>
		/// <c>o32 0F C8+rd</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BSWAP r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F C8+ro</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bswap(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bswap_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bswap_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bswap_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(bswap), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>bt instruction.<br/>
		/// <br/>
		/// <c>BT r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F A3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BT r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F A3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BT r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F A3 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bt_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bt_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bt_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(bt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bt instruction.<br/>
		/// <br/>
		/// <c>BT r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F A3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BT r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F A3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BT r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F A3 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bt(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bt_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bt_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bt_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(bt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bt instruction.<br/>
		/// <br/>
		/// </summary>
		public void bt(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bt_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Bt_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Bt_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(bt), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>bt instruction.<br/>
		/// <br/>
		/// </summary>
		public void bt(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bt_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bt_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bt_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(bt), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>btc instruction.<br/>
		/// <br/>
		/// <c>BTC r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F BB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTC r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F BB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTC r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F BB /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void btc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btc_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Btc_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Btc_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(btc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>btc instruction.<br/>
		/// <br/>
		/// <c>BTC r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F BB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTC r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F BB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTC r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F BB /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void btc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btc_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btc_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btc_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(btc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>btc instruction.<br/>
		/// <br/>
		/// </summary>
		public void btc(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btc_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Btc_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Btc_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(btc), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>btc instruction.<br/>
		/// <br/>
		/// </summary>
		public void btc(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btc_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btc_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btc_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(btc), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>btr instruction.<br/>
		/// <br/>
		/// <c>BTR r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F B3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTR r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F B3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTR r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F B3 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void btr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btr_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Btr_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Btr_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(btr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>btr instruction.<br/>
		/// <br/>
		/// <c>BTR r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F B3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTR r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F B3 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTR r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F B3 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void btr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btr_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btr_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btr_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(btr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>btr instruction.<br/>
		/// <br/>
		/// </summary>
		public void btr(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Btr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Btr_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(btr), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>btr instruction.<br/>
		/// <br/>
		/// </summary>
		public void btr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btr_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(btr), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>bts instruction.<br/>
		/// <br/>
		/// <c>BTS r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F AB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTS r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F AB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTS r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F AB /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bts_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bts_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bts_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(bts), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bts instruction.<br/>
		/// <br/>
		/// <c>BTS r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F AB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTS r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F AB /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BTS r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F AB /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bts_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bts_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bts_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(bts), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>bts instruction.<br/>
		/// <br/>
		/// </summary>
		public void bts(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bts_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Bts_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Bts_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(bts), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>bts instruction.<br/>
		/// <br/>
		/// </summary>
		public void bts(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bts_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bts_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bts_rm16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(bts), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>bzhi instruction.<br/>
		/// <br/>
		/// <c>BZHI r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BZHI r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bzhi(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Bzhi_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Bzhi_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(bzhi), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>bzhi instruction.<br/>
		/// <br/>
		/// <c>BZHI r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W0 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>BZHI r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F38.W1 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void bzhi(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Bzhi_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Bzhi_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(bzhi), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>call instruction.<br/>
		/// <br/>
		/// <c>CALL r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CALL r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /2</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>CALL r/m64</c><br/>
		/// <br/>
		/// <c>FF /2</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void call(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Call_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Call_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Call_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(call), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>call instruction.<br/>
		/// <br/>
		/// <c>CALL r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CALL r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /2</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>CALL r/m64</c><br/>
		/// <br/>
		/// <c>FF /2</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void call(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Call_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Call_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Call_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(call), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>cbw instruction.<br/>
		/// <br/>
		/// <c>CBW</c><br/>
		/// <br/>
		/// <c>o16 98</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cbw() {
			Code op;
			op = Code.Cbw;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cdq instruction.<br/>
		/// <br/>
		/// <c>CDQ</c><br/>
		/// <br/>
		/// <c>o32 99</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cdq() {
			Code op;
			op = Code.Cdq;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cdqe instruction.<br/>
		/// <br/>
		/// <c>CDQE</c><br/>
		/// <br/>
		/// <c>REX.W 98</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cdqe() {
			Code op;
			op = Code.Cdqe;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cl1invmb instruction.<br/>
		/// <br/>
		/// <c>CL1INVMB</c><br/>
		/// <br/>
		/// <c>0F 0A</c><br/>
		/// <br/>
		/// <c>CL1INVMB</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cl1invmb() {
			Code op;
			op = Code.Cl1invmb;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>clac instruction.<br/>
		/// <br/>
		/// <c>CLAC</c><br/>
		/// <br/>
		/// <c>NP 0F 01 CA</c><br/>
		/// <br/>
		/// <c>SMAP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clac() {
			Code op;
			op = Code.Clac;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>clc instruction.<br/>
		/// <br/>
		/// <c>CLC</c><br/>
		/// <br/>
		/// <c>F8</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clc() {
			Code op;
			op = Code.Clc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cld instruction.<br/>
		/// <br/>
		/// <c>CLD</c><br/>
		/// <br/>
		/// <c>FC</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cld() {
			Code op;
			op = Code.Cld;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cldemote instruction.<br/>
		/// <br/>
		/// <c>CLDEMOTE m8</c><br/>
		/// <br/>
		/// <c>NP 0F 1C /0</c><br/>
		/// <br/>
		/// <c>CLDEMOTE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cldemote(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Cldemote_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>clflush instruction.<br/>
		/// <br/>
		/// <c>CLFLUSH m8</c><br/>
		/// <br/>
		/// <c>NP 0F AE /7</c><br/>
		/// <br/>
		/// <c>CLFSH</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clflush(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Clflush_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>clflushopt instruction.<br/>
		/// <br/>
		/// <c>CLFLUSHOPT m8</c><br/>
		/// <br/>
		/// <c>66 0F AE /7</c><br/>
		/// <br/>
		/// <c>CLFLUSHOPT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clflushopt(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Clflushopt_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>clgi instruction.<br/>
		/// <br/>
		/// <c>CLGI</c><br/>
		/// <br/>
		/// <c>0F 01 DD</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clgi() {
			Code op;
			op = Code.Clgi;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cli instruction.<br/>
		/// <br/>
		/// <c>CLI</c><br/>
		/// <br/>
		/// <c>FA</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cli() {
			Code op;
			op = Code.Cli;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>clrssbsy instruction.<br/>
		/// <br/>
		/// <c>CLRSSBSY m64</c><br/>
		/// <br/>
		/// <c>F3 0F AE /6</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clrssbsy(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Clrssbsy_m64;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>clts instruction.<br/>
		/// <br/>
		/// <c>CLTS</c><br/>
		/// <br/>
		/// <c>0F 06</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clts() {
			Code op;
			op = Code.Clts;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>clwb instruction.<br/>
		/// <br/>
		/// <c>CLWB m8</c><br/>
		/// <br/>
		/// <c>66 0F AE /6</c><br/>
		/// <br/>
		/// <c>CLWB</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void clwb(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Clwb_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>clzero instruction.<br/>
		/// <br/>
		/// <c>CLZERO</c><br/>
		/// <br/>
		/// <c>a16 0F 01 FC</c><br/>
		/// <br/>
		/// <c>CLZERO</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>CLZERO</c><br/>
		/// <br/>
		/// <c>a32 0F 01 FC</c><br/>
		/// <br/>
		/// <c>CLZERO</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CLZERO</c><br/>
		/// <br/>
		/// <c>0F 01 FC</c><br/>
		/// <br/>
		/// <c>CLZERO</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void clzero() {
			Code op;
			if (Bitness == 64) {
				op = Code.Clzeroq;
			} else if (Bitness == 32) {
				op = Code.Clzerod;
			} else if (Bitness == 16) {
				op = Code.Clzerow;
			} else {
				throw NoOpCodeFoundFor(nameof(clzero));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cmc instruction.<br/>
		/// <br/>
		/// <c>CMC</c><br/>
		/// <br/>
		/// <c>F5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cmc() {
			Code op;
			op = Code.Cmc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cmova instruction.<br/>
		/// <br/>
		/// <c>CMOVA r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 47 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVA r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 47 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVA r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 47 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmova(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmova), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmova instruction.<br/>
		/// <br/>
		/// <c>CMOVA r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 47 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVA r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 47 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVA r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 47 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmova(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmova), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovae instruction.<br/>
		/// <br/>
		/// <c>CMOVAE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 43 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVAE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 43 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVAE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 43 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovae(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovae), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovae instruction.<br/>
		/// <br/>
		/// <c>CMOVAE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 43 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVAE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 43 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVAE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 43 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovae(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovae), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovb instruction.<br/>
		/// <br/>
		/// <c>CMOVB r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 42 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVB r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 42 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVB r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 42 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovb instruction.<br/>
		/// <br/>
		/// <c>CMOVB r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 42 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVB r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 42 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVB r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 42 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovbe instruction.<br/>
		/// <br/>
		/// <c>CMOVBE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 46 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVBE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 46 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVBE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 46 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovbe(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovbe), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovbe instruction.<br/>
		/// <br/>
		/// <c>CMOVBE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 46 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVBE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 46 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVBE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 46 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovbe(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovbe), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmove instruction.<br/>
		/// <br/>
		/// <c>CMOVE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 44 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 44 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 44 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmove(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmove), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmove instruction.<br/>
		/// <br/>
		/// <c>CMOVE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 44 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 44 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 44 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmove(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmove), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovg instruction.<br/>
		/// <br/>
		/// <c>CMOVG r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4F /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVG r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4F /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVG r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4F /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovg), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovg instruction.<br/>
		/// <br/>
		/// <c>CMOVG r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4F /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVG r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4F /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVG r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4F /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovg(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovg), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovge instruction.<br/>
		/// <br/>
		/// <c>CMOVGE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4D /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVGE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4D /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVGE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4D /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovge(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovge), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovge instruction.<br/>
		/// <br/>
		/// <c>CMOVGE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4D /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVGE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4D /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVGE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4D /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovge(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovge), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovl instruction.<br/>
		/// <br/>
		/// <c>CMOVL r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4C /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVL r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4C /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVL r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4C /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovl instruction.<br/>
		/// <br/>
		/// <c>CMOVL r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4C /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVL r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4C /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVL r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4C /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovle instruction.<br/>
		/// <br/>
		/// <c>CMOVLE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4E /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVLE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4E /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVLE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4E /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovle(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovle), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovle instruction.<br/>
		/// <br/>
		/// <c>CMOVLE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4E /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVLE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4E /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVLE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4E /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovle(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovle), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovne instruction.<br/>
		/// <br/>
		/// <c>CMOVNE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 45 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 45 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 45 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovne(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovne), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovne instruction.<br/>
		/// <br/>
		/// <c>CMOVNE r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 45 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNE r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 45 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNE r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 45 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovne(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovne), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovno instruction.<br/>
		/// <br/>
		/// <c>CMOVNO r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 41 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNO r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 41 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNO r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 41 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovno(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovno), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovno instruction.<br/>
		/// <br/>
		/// <c>CMOVNO r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 41 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNO r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 41 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNO r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 41 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovno(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovno), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovnp instruction.<br/>
		/// <br/>
		/// <c>CMOVNP r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4B /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNP r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4B /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNP r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4B /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovnp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovnp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovnp instruction.<br/>
		/// <br/>
		/// <c>CMOVNP r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4B /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNP r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4B /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNP r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4B /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovnp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovnp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovns instruction.<br/>
		/// <br/>
		/// <c>CMOVNS r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 49 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNS r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 49 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNS r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 49 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovns(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovns), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovns instruction.<br/>
		/// <br/>
		/// <c>CMOVNS r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 49 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNS r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 49 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVNS r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 49 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovns(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovns), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovo instruction.<br/>
		/// <br/>
		/// <c>CMOVO r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 40 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVO r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 40 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVO r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 40 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovo(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovo), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovo instruction.<br/>
		/// <br/>
		/// <c>CMOVO r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 40 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVO r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 40 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVO r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 40 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovo(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovo), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovp instruction.<br/>
		/// <br/>
		/// <c>CMOVP r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4A /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVP r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4A /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVP r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4A /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovp instruction.<br/>
		/// <br/>
		/// <c>CMOVP r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 4A /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVP r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 4A /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVP r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 4A /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovs instruction.<br/>
		/// <br/>
		/// <c>CMOVS r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 48 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVS r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 48 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVS r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 48 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovs(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovs), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmovs instruction.<br/>
		/// <br/>
		/// <c>CMOVS r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 48 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVS r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 48 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMOVS r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 48 /r</c><br/>
		/// <br/>
		/// <c>CMOV</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmovs(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmovs), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmp instruction.<br/>
		/// <br/>
		/// <c>CMP r/m8, r8</c><br/>
		/// <br/>
		/// <c>38 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 39 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 39 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 39 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmp instruction.<br/>
		/// <br/>
		/// <c>CMP r/m8, r8</c><br/>
		/// <br/>
		/// <c>38 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 39 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 39 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 39 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmp(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmp_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmp_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmp_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmp instruction.<br/>
		/// <br/>
		/// <c>CMP r8, r/m8</c><br/>
		/// <br/>
		/// <c>3A /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 3B /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 3B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 3B /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmp instruction.<br/>
		/// <br/>
		/// <c>CMP AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 3D iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 3D id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 3D id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>CMP r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /7 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /7 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /7 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmp(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Cmp_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Cmp_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Cmp_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Cmp_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Cmp_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(cmp), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Cmp_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Cmp_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Cmp_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Cmp_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmp), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>cmp instruction.<br/>
		/// <br/>
		/// <c>CMP r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /7 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /7 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMP r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /7 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmp(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Cmp_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Cmp_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Cmp_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Cmp_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(cmp), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmp_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmp_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmp_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(cmp), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>cmppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmppd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmppd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmppd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmppd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmppd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmppd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmpps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmpps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmpps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmpps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpsb instruction.<br/>
		/// <br/>
		/// <c>CMPSB</c><br/>
		/// <br/>
		/// <c>A6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cmpsb() {
			Code op;
			op = Code.Cmpsb_m8_m8;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cmpsd instruction.<br/>
		/// <br/>
		/// <c>CMPSD</c><br/>
		/// <br/>
		/// <c>o32 A7</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cmpsd() {
			Code op;
			op = Code.Cmpsd_m32_m32;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cmpsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmpsd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmpsd_xmm_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpsd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmpsd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmpsd_xmm_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpsd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpsq instruction.<br/>
		/// <br/>
		/// <c>CMPSQ</c><br/>
		/// <br/>
		/// <c>REX.W A7</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmpsq() {
			Code op;
			op = Code.Cmpsq_m64_m64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cmpss instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmpss(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmpss_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpss), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpss instruction.<br/>
		/// <br/>
		/// </summary>
		public void cmpss(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cmpss_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpss), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>cmpsw instruction.<br/>
		/// <br/>
		/// <c>CMPSW</c><br/>
		/// <br/>
		/// <c>o16 A7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cmpsw() {
			Code op;
			op = Code.Cmpsw_m16_m16;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cmpxchg instruction.<br/>
		/// <br/>
		/// <c>CMPXCHG r/m8, r8</c><br/>
		/// <br/>
		/// <c>0F B0 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMPXCHG r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F B1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMPXCHG r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F B1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMPXCHG r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F B1 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmpxchg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpxchg), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmpxchg instruction.<br/>
		/// <br/>
		/// <c>CMPXCHG r/m8, r8</c><br/>
		/// <br/>
		/// <c>0F B0 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMPXCHG r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F B1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMPXCHG r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F B1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CMPXCHG r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F B1 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cmpxchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(cmpxchg), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cmpxchg8b instruction.<br/>
		/// <br/>
		/// <c>CMPXCHG8B m64</c><br/>
		/// <br/>
		/// <c>0F C7 /1</c><br/>
		/// <br/>
		/// <c>CX8</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cmpxchg8b(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Cmpxchg8b_m64;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>comisd instruction.<br/>
		/// <br/>
		/// <c>COMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 2F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void comisd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Comisd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(comisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>comisd instruction.<br/>
		/// <br/>
		/// <c>COMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 2F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void comisd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Comisd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(comisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>comiss instruction.<br/>
		/// <br/>
		/// <c>COMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 2F /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void comiss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Comiss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(comiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>comiss instruction.<br/>
		/// <br/>
		/// <c>COMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 2F /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void comiss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Comiss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(comiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cpuid instruction.<br/>
		/// <br/>
		/// <c>CPUID</c><br/>
		/// <br/>
		/// <c>0F A2</c><br/>
		/// <br/>
		/// <c>CPUID</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cpuid() {
			Code op;
			op = Code.Cpuid;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cqo instruction.<br/>
		/// <br/>
		/// <c>CQO</c><br/>
		/// <br/>
		/// <c>REX.W 99</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cqo() {
			Code op;
			op = Code.Cqo;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>crc32 instruction.<br/>
		/// <br/>
		/// <c>CRC32 r32, r/m8</c><br/>
		/// <br/>
		/// <c>F2 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CRC32 r64, r/m8</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>CRC32 r32, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F2 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CRC32 r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F2 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CRC32 r64, r/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void crc32(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR64()) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR32()) {
				op = Code.Crc32_r32_rm32;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Crc32_r32_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(crc32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>crc32 instruction.<br/>
		/// <br/>
		/// <c>CRC32 r32, r/m8</c><br/>
		/// <br/>
		/// <c>F2 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CRC32 r64, r/m8</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>CRC32 r32, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F2 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CRC32 r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F2 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CRC32 r64, r/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void crc32(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Crc32_r32_rm32;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Crc32_r32_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(crc32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtdq2pd instruction.<br/>
		/// <br/>
		/// <c>CVTDQ2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F3 0F E6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtdq2pd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtdq2pd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtdq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtdq2pd instruction.<br/>
		/// <br/>
		/// <c>CVTDQ2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F3 0F E6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtdq2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtdq2pd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtdq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtdq2ps instruction.<br/>
		/// <br/>
		/// <c>CVTDQ2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtdq2ps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtdq2ps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtdq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtdq2ps instruction.<br/>
		/// <br/>
		/// <c>CVTDQ2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtdq2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtdq2ps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtdq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpd2dq instruction.<br/>
		/// <br/>
		/// <c>CVTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F E6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpd2dq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpd2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpd2dq instruction.<br/>
		/// <br/>
		/// <c>CVTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F E6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpd2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpd2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpd2pi instruction.<br/>
		/// <br/>
		/// <c>CVTPD2PI mm, xmm/m128</c><br/>
		/// <br/>
		/// <c>66 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpd2pi(Register dst, Register src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvtpd2pi_mm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpd2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpd2pi instruction.<br/>
		/// <br/>
		/// <c>CVTPD2PI mm, xmm/m128</c><br/>
		/// <br/>
		/// <c>66 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpd2pi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvtpd2pi_mm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpd2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpd2ps instruction.<br/>
		/// <br/>
		/// <c>CVTPD2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpd2ps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpd2ps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpd2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpd2ps instruction.<br/>
		/// <br/>
		/// <c>CVTPD2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpd2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpd2ps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpd2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpi2pd instruction.<br/>
		/// <br/>
		/// <c>CVTPI2PD xmm, mm/m64</c><br/>
		/// <br/>
		/// <c>66 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpi2pd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpi2pd_xmm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpi2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpi2pd instruction.<br/>
		/// <br/>
		/// <c>CVTPI2PD xmm, mm/m64</c><br/>
		/// <br/>
		/// <c>66 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpi2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpi2pd_xmm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpi2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpi2ps instruction.<br/>
		/// <br/>
		/// <c>CVTPI2PS xmm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpi2ps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpi2ps_xmm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpi2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtpi2ps instruction.<br/>
		/// <br/>
		/// <c>CVTPI2PS xmm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtpi2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtpi2ps_xmm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtpi2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtps2dq instruction.<br/>
		/// <br/>
		/// <c>CVTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtps2dq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtps2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtps2dq instruction.<br/>
		/// <br/>
		/// <c>CVTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtps2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtps2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtps2pd instruction.<br/>
		/// <br/>
		/// <c>CVTPS2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtps2pd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtps2pd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtps2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtps2pd instruction.<br/>
		/// <br/>
		/// <c>CVTPS2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtps2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtps2pd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtps2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtps2pi instruction.<br/>
		/// <br/>
		/// <c>CVTPS2PI mm, xmm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtps2pi(Register dst, Register src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvtps2pi_mm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtps2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtps2pi instruction.<br/>
		/// <br/>
		/// <c>CVTPS2PI mm, xmm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtps2pi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvtps2pi_mm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtps2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsd2si instruction.<br/>
		/// <br/>
		/// <c>CVTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtsd2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvtsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cvtsd2si_r32_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsd2si instruction.<br/>
		/// <br/>
		/// <c>CVTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtsd2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvtsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cvtsd2si_r32_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsd2ss instruction.<br/>
		/// <br/>
		/// <c>CVTSD2SS xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtsd2ss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtsd2ss_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsd2ss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsd2ss instruction.<br/>
		/// <br/>
		/// <c>CVTSD2SS xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtsd2ss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtsd2ss_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsd2ss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsi2sd instruction.<br/>
		/// <br/>
		/// <c>CVTSI2SD xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>F2 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSI2SD xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtsi2sd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsGPR64()) {
				op = Code.Cvtsi2sd_xmm_rm64;
			} else if (dst.IsXMM() && src.IsGPR32()) {
				op = Code.Cvtsi2sd_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsi2sd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsi2sd instruction.<br/>
		/// <br/>
		/// <c>CVTSI2SD xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>F2 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSI2SD xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtsi2sd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cvtsi2sd_xmm_rm64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cvtsi2sd_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsi2sd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsi2ss instruction.<br/>
		/// <br/>
		/// <c>CVTSI2SS xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSI2SS xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtsi2ss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsGPR64()) {
				op = Code.Cvtsi2ss_xmm_rm64;
			} else if (dst.IsXMM() && src.IsGPR32()) {
				op = Code.Cvtsi2ss_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsi2ss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtsi2ss instruction.<br/>
		/// <br/>
		/// <c>CVTSI2SS xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSI2SS xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 2A /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtsi2ss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cvtsi2ss_xmm_rm64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cvtsi2ss_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtsi2ss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtss2sd instruction.<br/>
		/// <br/>
		/// <c>CVTSS2SD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtss2sd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtss2sd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtss2sd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtss2sd instruction.<br/>
		/// <br/>
		/// <c>CVTSS2SD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvtss2sd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvtss2sd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtss2sd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtss2si instruction.<br/>
		/// <br/>
		/// <c>CVTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtss2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvtss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cvtss2si_r32_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvtss2si instruction.<br/>
		/// <br/>
		/// <c>CVTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 2D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvtss2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvtss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cvtss2si_r32_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvtss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttpd2dq instruction.<br/>
		/// <br/>
		/// <c>CVTTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttpd2dq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvttpd2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttpd2dq instruction.<br/>
		/// <br/>
		/// <c>CVTTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttpd2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvttpd2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttpd2pi instruction.<br/>
		/// <br/>
		/// <c>CVTTPD2PI mm, xmm/m128</c><br/>
		/// <br/>
		/// <c>66 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttpd2pi(Register dst, Register src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvttpd2pi_mm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttpd2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttpd2pi instruction.<br/>
		/// <br/>
		/// <c>CVTTPD2PI mm, xmm/m128</c><br/>
		/// <br/>
		/// <c>66 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttpd2pi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvttpd2pi_mm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttpd2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttps2dq instruction.<br/>
		/// <br/>
		/// <c>CVTTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 5B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttps2dq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvttps2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttps2dq instruction.<br/>
		/// <br/>
		/// <c>CVTTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 5B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttps2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Cvttps2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttps2pi instruction.<br/>
		/// <br/>
		/// <c>CVTTPS2PI mm, xmm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttps2pi(Register dst, Register src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvttps2pi_mm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttps2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttps2pi instruction.<br/>
		/// <br/>
		/// <c>CVTTPS2PI mm, xmm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cvttps2pi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Cvttps2pi_mm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttps2pi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttsd2si instruction.<br/>
		/// <br/>
		/// <c>CVTTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvttsd2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvttsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cvttsd2si_r32_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttsd2si instruction.<br/>
		/// <br/>
		/// <c>CVTTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvttsd2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvttsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cvttsd2si_r32_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttss2si instruction.<br/>
		/// <br/>
		/// <c>CVTTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvttss2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvttss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cvttss2si_r32_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cvttss2si instruction.<br/>
		/// <br/>
		/// <c>CVTTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>CVTTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 2C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void cvttss2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cvttss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cvttss2si_r32_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(cvttss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>cwd instruction.<br/>
		/// <br/>
		/// <c>CWD</c><br/>
		/// <br/>
		/// <c>o16 99</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cwd() {
			Code op;
			op = Code.Cwd;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>cwde instruction.<br/>
		/// <br/>
		/// <c>CWDE</c><br/>
		/// <br/>
		/// <c>o32 98</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void cwde() {
			Code op;
			op = Code.Cwde;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>daa instruction.<br/>
		/// <br/>
		/// <c>DAA</c><br/>
		/// <br/>
		/// <c>27</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void daa() {
			Code op;
			op = Code.Daa;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>das instruction.<br/>
		/// <br/>
		/// <c>DAS</c><br/>
		/// <br/>
		/// <c>2F</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void das() {
			Code op;
			op = Code.Das;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>db instruction.<br/>
		/// <br/>
		/// A <c>db</c>/<c>.byte</c> asm directive that can store 1-16 bytes</summary>
		public void db() {
			Code op;
			op = Code.DeclareByte;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>dd instruction.<br/>
		/// <br/>
		/// A <c>dd</c>/<c>.int</c> asm directive that can store 1-4 dwords</summary>
		public void dd() {
			Code op;
			op = Code.DeclareDword;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>dec instruction.<br/>
		/// <br/>
		/// <c>DEC r16</c><br/>
		/// <br/>
		/// <c>o16 48+rw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>DEC r32</c><br/>
		/// <br/>
		/// <c>o32 48+rd</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>DEC r/m8</c><br/>
		/// <br/>
		/// <c>FE /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DEC r/m64</c><br/>
		/// <br/>
		/// <c>REX.W FF /1</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void dec(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Dec_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Dec_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Dec_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Dec_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(dec), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>dec instruction.<br/>
		/// <br/>
		/// <c>DEC r/m8</c><br/>
		/// <br/>
		/// <c>FE /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DEC r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DEC r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /1</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DEC r/m64</c><br/>
		/// <br/>
		/// <c>REX.W FF /1</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void dec(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Dec_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Dec_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Dec_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Dec_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(dec), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>div instruction.<br/>
		/// <br/>
		/// <c>DIV r/m8</c><br/>
		/// <br/>
		/// <c>F6 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DIV r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DIV r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /6</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DIV r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /6</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void div(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Div_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Div_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Div_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Div_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(div), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>div instruction.<br/>
		/// <br/>
		/// <c>DIV r/m8</c><br/>
		/// <br/>
		/// <c>F6 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DIV r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DIV r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /6</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>DIV r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /6</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void div(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Div_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Div_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Div_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Div_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(div), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>divpd instruction.<br/>
		/// <br/>
		/// <c>DIVPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(divpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divpd instruction.<br/>
		/// <br/>
		/// <c>DIVPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(divpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divps instruction.<br/>
		/// <br/>
		/// <c>DIVPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(divps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divps instruction.<br/>
		/// <br/>
		/// <c>DIVPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(divps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divsd instruction.<br/>
		/// <br/>
		/// <c>DIVSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(divsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divsd instruction.<br/>
		/// <br/>
		/// <c>DIVSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(divsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divss instruction.<br/>
		/// <br/>
		/// <c>DIVSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(divss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>divss instruction.<br/>
		/// <br/>
		/// <c>DIVSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5E /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void divss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Divss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(divss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>dppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void dppd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Dppd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(dppd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>dppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void dppd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Dppd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(dppd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>dpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void dpps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Dpps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(dpps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>dpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void dpps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Dpps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(dpps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>dq instruction.<br/>
		/// <br/>
		/// A <c>dq</c>/<c>.quad</c> asm directive that can store 1-2 qwords</summary>
		public void dq() {
			Code op;
			op = Code.DeclareQword;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>dw instruction.<br/>
		/// <br/>
		/// A <c>dw</c>/<c>.word</c> asm directive that can store 1-8 words</summary>
		public void dw() {
			Code op;
			op = Code.DeclareWord;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>emms instruction.<br/>
		/// <br/>
		/// <c>EMMS</c><br/>
		/// <br/>
		/// <c>NP 0F 77</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void emms() {
			Code op;
			op = Code.Emms;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>encls instruction.<br/>
		/// <br/>
		/// <c>ENCLS</c><br/>
		/// <br/>
		/// <c>NP 0F 01 CF</c><br/>
		/// <br/>
		/// <c>SGX1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void encls() {
			Code op;
			op = Code.Encls;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>enclu instruction.<br/>
		/// <br/>
		/// <c>ENCLU</c><br/>
		/// <br/>
		/// <c>NP 0F 01 D7</c><br/>
		/// <br/>
		/// <c>SGX1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void enclu() {
			Code op;
			op = Code.Enclu;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>enclv instruction.<br/>
		/// <br/>
		/// <c>ENCLV</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C0</c><br/>
		/// <br/>
		/// <c>ENCLV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void enclv() {
			Code op;
			op = Code.Enclv;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>endbr32 instruction.<br/>
		/// <br/>
		/// <c>ENDBR32</c><br/>
		/// <br/>
		/// <c>F3 0F 1E FB</c><br/>
		/// <br/>
		/// <c>CET_IBT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void endbr32() {
			Code op;
			op = Code.Endbr32;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>endbr64 instruction.<br/>
		/// <br/>
		/// <c>ENDBR64</c><br/>
		/// <br/>
		/// <c>F3 0F 1E FA</c><br/>
		/// <br/>
		/// <c>CET_IBT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void endbr64() {
			Code op;
			op = Code.Endbr64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>enqcmd instruction.<br/>
		/// <br/>
		/// <c>ENQCMD r16, m512</c><br/>
		/// <br/>
		/// <c>a16 F2 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>ENQCMD r32, m512</c><br/>
		/// <br/>
		/// <c>a32 F2 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ENQCMD r64, m512</c><br/>
		/// <br/>
		/// <c>F2 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void enqcmd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Enqcmd_r64_m512;
			} else if (dst.IsGPR32()) {
				op = Code.Enqcmd_r32_m512;
			} else if (dst.IsGPR16()) {
				op = Code.Enqcmd_r16_m512;
			} else {
				throw NoOpCodeFoundFor(nameof(enqcmd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>enqcmd instruction.<br/>
		/// <br/>
		/// <c>ENQCMD r16, m512</c><br/>
		/// <br/>
		/// <c>a16 F2 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>ENQCMD r32, m512</c><br/>
		/// <br/>
		/// <c>a32 F2 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ENQCMD r64, m512</c><br/>
		/// <br/>
		/// <c>F2 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void enqcmd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Enqcmd_r64_m512;
			} else if (dst.IsGPR32()) {
				op = Code.Enqcmd_r32_m512;
			} else if (dst.IsGPR16()) {
				op = Code.Enqcmd_r16_m512;
			} else {
				throw NoOpCodeFoundFor(nameof(enqcmd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>enqcmds instruction.<br/>
		/// <br/>
		/// <c>ENQCMDS r16, m512</c><br/>
		/// <br/>
		/// <c>a16 F3 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>ENQCMDS r32, m512</c><br/>
		/// <br/>
		/// <c>a32 F3 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ENQCMDS r64, m512</c><br/>
		/// <br/>
		/// <c>F3 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void enqcmds(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Enqcmds_r64_m512;
			} else if (dst.IsGPR32()) {
				op = Code.Enqcmds_r32_m512;
			} else if (dst.IsGPR16()) {
				op = Code.Enqcmds_r16_m512;
			} else {
				throw NoOpCodeFoundFor(nameof(enqcmds), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>enqcmds instruction.<br/>
		/// <br/>
		/// <c>ENQCMDS r16, m512</c><br/>
		/// <br/>
		/// <c>a16 F3 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>ENQCMDS r32, m512</c><br/>
		/// <br/>
		/// <c>a32 F3 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ENQCMDS r64, m512</c><br/>
		/// <br/>
		/// <c>F3 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>ENQCMD</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void enqcmds(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Enqcmds_r64_m512;
			} else if (dst.IsGPR32()) {
				op = Code.Enqcmds_r32_m512;
			} else if (dst.IsGPR16()) {
				op = Code.Enqcmds_r16_m512;
			} else {
				throw NoOpCodeFoundFor(nameof(enqcmds), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>extractps instruction.<br/>
		/// <br/>
		/// </summary>
		public void extractps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Extractps_r64m32_xmm_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Extractps_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(extractps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>extractps instruction.<br/>
		/// <br/>
		/// </summary>
		public void extractps(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Extractps_r64m32_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Extractps_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(extractps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>extrq instruction.<br/>
		/// <br/>
		/// <c>EXTRQ xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>66 0F 79 /r</c><br/>
		/// <br/>
		/// <c>SSE4A</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void extrq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Extrq_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(extrq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>f2xm1 instruction.<br/>
		/// <br/>
		/// <c>F2XM1</c><br/>
		/// <br/>
		/// <c>D9 F0</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void f2xm1() {
			Code op;
			op = Code.F2xm1;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fabs instruction.<br/>
		/// <br/>
		/// <c>FABS</c><br/>
		/// <br/>
		/// <c>D9 E1</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fabs() {
			Code op;
			op = Code.Fabs;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fadd instruction.<br/>
		/// <br/>
		/// <c>FADD ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>D8 C0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>FADD ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DC C0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fadd(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fadd_st0_sti;
			} else if (dst.IsST()) {
				op = Code.Fadd_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fadd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>faddp instruction.<br/>
		/// <br/>
		/// <c>FADDP ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DE C0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void faddp(Register dst, Register src) {
			Code op;
			if (dst.IsST()) {
				op = Code.Faddp_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(faddp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fchs instruction.<br/>
		/// <br/>
		/// <c>FCHS</c><br/>
		/// <br/>
		/// <c>D9 E0</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fchs() {
			Code op;
			op = Code.Fchs;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fclex instruction.<br/>
		/// <br/>
		/// <c>FCLEX</c><br/>
		/// <br/>
		/// <c>9B DB E2</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fclex() {
			Code op;
			op = Code.Fclex;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fcmovb instruction.<br/>
		/// <br/>
		/// <c>FCMOVB ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DA C0+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovb(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovb_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmovbe instruction.<br/>
		/// <br/>
		/// <c>FCMOVBE ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DA D0+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovbe(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovbe_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovbe), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmove instruction.<br/>
		/// <br/>
		/// <c>FCMOVE ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DA C8+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmove(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmove_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmove), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmovnb instruction.<br/>
		/// <br/>
		/// <c>FCMOVNB ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DB C0+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovnb(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovnb_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovnb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmovnbe instruction.<br/>
		/// <br/>
		/// <c>FCMOVNBE ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DB D0+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovnbe(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovnbe_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovnbe), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmovne instruction.<br/>
		/// <br/>
		/// <c>FCMOVNE ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DB C8+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovne(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovne_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovne), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmovnu instruction.<br/>
		/// <br/>
		/// <c>FCMOVNU ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DB D8+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovnu(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovnu_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovnu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcmovu instruction.<br/>
		/// <br/>
		/// <c>FCMOVU ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>DA D8+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcmovu(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcmovu_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcmovu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcom instruction.<br/>
		/// <br/>
		/// <c>FCOM ST(i)</c><br/>
		/// <br/>
		/// <c>D8 D0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcom(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcom_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcom), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcomi instruction.<br/>
		/// <br/>
		/// <c>FCOMI ST, ST(i)</c><br/>
		/// <br/>
		/// <c>DB F0+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcomi(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcomi_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcomi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcomip instruction.<br/>
		/// <br/>
		/// <c>FCOMIP ST, ST(i)</c><br/>
		/// <br/>
		/// <c>DF F0+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcomip(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcomip_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcomip), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcomp instruction.<br/>
		/// <br/>
		/// <c>FCOMP ST(i)</c><br/>
		/// <br/>
		/// <c>D8 D8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcomp(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fcomp_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fcomp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fcompp instruction.<br/>
		/// <br/>
		/// <c>FCOMPP</c><br/>
		/// <br/>
		/// <c>DE D9</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcompp() {
			Code op;
			op = Code.Fcompp;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fcos instruction.<br/>
		/// <br/>
		/// <c>FCOS</c><br/>
		/// <br/>
		/// <c>D9 FF</c><br/>
		/// <br/>
		/// <c>387+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fcos() {
			Code op;
			op = Code.Fcos;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fdecstp instruction.<br/>
		/// <br/>
		/// <c>FDECSTP</c><br/>
		/// <br/>
		/// <c>D9 F6</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fdecstp() {
			Code op;
			op = Code.Fdecstp;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fdisi instruction.<br/>
		/// <br/>
		/// <c>FDISI</c><br/>
		/// <br/>
		/// <c>9B DB E1</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fdisi() {
			Code op;
			op = Code.Fdisi;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fdiv instruction.<br/>
		/// <br/>
		/// <c>FDIV ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>D8 F0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>FDIV ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DC F8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fdiv(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fdiv_st0_sti;
			} else if (dst.IsST()) {
				op = Code.Fdiv_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fdiv), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fdivp instruction.<br/>
		/// <br/>
		/// <c>FDIVP ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DE F8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fdivp(Register dst, Register src) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fdivp_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fdivp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fdivr instruction.<br/>
		/// <br/>
		/// <c>FDIVR ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>D8 F8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>FDIVR ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DC F0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fdivr(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fdivr_st0_sti;
			} else if (dst.IsST()) {
				op = Code.Fdivr_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fdivr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fdivrp instruction.<br/>
		/// <br/>
		/// <c>FDIVRP ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DE F0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fdivrp(Register dst, Register src) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fdivrp_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fdivrp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>femms instruction.<br/>
		/// <br/>
		/// <c>FEMMS</c><br/>
		/// <br/>
		/// <c>0F 0E</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void femms() {
			Code op;
			op = Code.Femms;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>feni instruction.<br/>
		/// <br/>
		/// <c>FENI</c><br/>
		/// <br/>
		/// <c>9B DB E0</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void feni() {
			Code op;
			op = Code.Feni;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>ffree instruction.<br/>
		/// <br/>
		/// <c>FFREE ST(i)</c><br/>
		/// <br/>
		/// <c>DD C0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ffree(Register dst) {
			Code op;
			if (dst.IsST()) {
				op = Code.Ffree_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(ffree), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>ffreep instruction.<br/>
		/// <br/>
		/// <c>FFREEP ST(i)</c><br/>
		/// <br/>
		/// <c>DF C0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ffreep(Register dst) {
			Code op;
			if (dst.IsST()) {
				op = Code.Ffreep_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(ffreep), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fincstp instruction.<br/>
		/// <br/>
		/// <c>FINCSTP</c><br/>
		/// <br/>
		/// <c>D9 F7</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fincstp() {
			Code op;
			op = Code.Fincstp;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>finit instruction.<br/>
		/// <br/>
		/// <c>FINIT</c><br/>
		/// <br/>
		/// <c>9B DB E3</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void finit() {
			Code op;
			op = Code.Finit;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fld instruction.<br/>
		/// <br/>
		/// <c>FLD ST(i)</c><br/>
		/// <br/>
		/// <c>D9 C0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fld(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fld_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fld1 instruction.<br/>
		/// <br/>
		/// <c>FLD1</c><br/>
		/// <br/>
		/// <c>D9 E8</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fld1() {
			Code op;
			op = Code.Fld1;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fldcw instruction.<br/>
		/// <br/>
		/// <c>FLDCW m2byte</c><br/>
		/// <br/>
		/// <c>D9 /5</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldcw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Fldcw_m2byte;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fldl2e instruction.<br/>
		/// <br/>
		/// <c>FLDL2E</c><br/>
		/// <br/>
		/// <c>D9 EA</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldl2e() {
			Code op;
			op = Code.Fldl2e;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fldl2t instruction.<br/>
		/// <br/>
		/// <c>FLDL2T</c><br/>
		/// <br/>
		/// <c>D9 E9</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldl2t() {
			Code op;
			op = Code.Fldl2t;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fldlg2 instruction.<br/>
		/// <br/>
		/// <c>FLDLG2</c><br/>
		/// <br/>
		/// <c>D9 EC</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldlg2() {
			Code op;
			op = Code.Fldlg2;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fldln2 instruction.<br/>
		/// <br/>
		/// <c>FLDLN2</c><br/>
		/// <br/>
		/// <c>D9 ED</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldln2() {
			Code op;
			op = Code.Fldln2;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fldpi instruction.<br/>
		/// <br/>
		/// <c>FLDPI</c><br/>
		/// <br/>
		/// <c>D9 EB</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldpi() {
			Code op;
			op = Code.Fldpi;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fldz instruction.<br/>
		/// <br/>
		/// <c>FLDZ</c><br/>
		/// <br/>
		/// <c>D9 EE</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fldz() {
			Code op;
			op = Code.Fldz;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fmul instruction.<br/>
		/// <br/>
		/// <c>FMUL ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>D8 C8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>FMUL ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DC C8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fmul(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fmul_st0_sti;
			} else if (dst.IsST()) {
				op = Code.Fmul_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fmul), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fmulp instruction.<br/>
		/// <br/>
		/// <c>FMULP ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DE C8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fmulp(Register dst, Register src) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fmulp_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fmulp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fnclex instruction.<br/>
		/// <br/>
		/// <c>FNCLEX</c><br/>
		/// <br/>
		/// <c>DB E2</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fnclex() {
			Code op;
			op = Code.Fnclex;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fndisi instruction.<br/>
		/// <br/>
		/// <c>FNDISI</c><br/>
		/// <br/>
		/// <c>DB E1</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fndisi() {
			Code op;
			op = Code.Fndisi;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fneni instruction.<br/>
		/// <br/>
		/// <c>FNENI</c><br/>
		/// <br/>
		/// <c>DB E0</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fneni() {
			Code op;
			op = Code.Fneni;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fninit instruction.<br/>
		/// <br/>
		/// <c>FNINIT</c><br/>
		/// <br/>
		/// <c>DB E3</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fninit() {
			Code op;
			op = Code.Fninit;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fnop instruction.<br/>
		/// <br/>
		/// <c>FNOP</c><br/>
		/// <br/>
		/// <c>D9 D0</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fnop() {
			Code op;
			op = Code.Fnop;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fnsetpm instruction.<br/>
		/// <br/>
		/// <c>FNSETPM</c><br/>
		/// <br/>
		/// <c>DB E4</c><br/>
		/// <br/>
		/// <c>287+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fnsetpm() {
			Code op;
			op = Code.Fnsetpm;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fnstcw instruction.<br/>
		/// <br/>
		/// <c>FNSTCW m2byte</c><br/>
		/// <br/>
		/// <c>D9 /7</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fnstcw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Fnstcw_m2byte;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fnstsw instruction.<br/>
		/// <br/>
		/// <c>FNSTSW AX</c><br/>
		/// <br/>
		/// <c>DF E0</c><br/>
		/// <br/>
		/// <c>287+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fnstsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fnstsw_AX;
			} else {
				throw NoOpCodeFoundFor(nameof(fnstsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fnstsw instruction.<br/>
		/// <br/>
		/// <c>FNSTSW m2byte</c><br/>
		/// <br/>
		/// <c>DD /7</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fnstsw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Fnstsw_m2byte;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fpatan instruction.<br/>
		/// <br/>
		/// <c>FPATAN</c><br/>
		/// <br/>
		/// <c>D9 F3</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fpatan() {
			Code op;
			op = Code.Fpatan;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fprem instruction.<br/>
		/// <br/>
		/// <c>FPREM</c><br/>
		/// <br/>
		/// <c>D9 F8</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fprem() {
			Code op;
			op = Code.Fprem;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fprem1 instruction.<br/>
		/// <br/>
		/// <c>FPREM1</c><br/>
		/// <br/>
		/// <c>D9 F5</c><br/>
		/// <br/>
		/// <c>387+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fprem1() {
			Code op;
			op = Code.Fprem1;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fptan instruction.<br/>
		/// <br/>
		/// <c>FPTAN</c><br/>
		/// <br/>
		/// <c>D9 F2</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fptan() {
			Code op;
			op = Code.Fptan;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>frndint instruction.<br/>
		/// <br/>
		/// <c>FRNDINT</c><br/>
		/// <br/>
		/// <c>D9 FC</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void frndint() {
			Code op;
			op = Code.Frndint;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>frstpm instruction.<br/>
		/// <br/>
		/// <c>FRSTPM</c><br/>
		/// <br/>
		/// <c>DB E5</c><br/>
		/// <br/>
		/// <c>287 XL</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void frstpm() {
			Code op;
			op = Code.Frstpm;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fscale instruction.<br/>
		/// <br/>
		/// <c>FSCALE</c><br/>
		/// <br/>
		/// <c>D9 FD</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fscale() {
			Code op;
			op = Code.Fscale;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fsetpm instruction.<br/>
		/// <br/>
		/// <c>FSETPM</c><br/>
		/// <br/>
		/// <c>9B DB E4</c><br/>
		/// <br/>
		/// <c>287+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsetpm() {
			Code op;
			op = Code.Fsetpm;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fsin instruction.<br/>
		/// <br/>
		/// <c>FSIN</c><br/>
		/// <br/>
		/// <c>D9 FE</c><br/>
		/// <br/>
		/// <c>387+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsin() {
			Code op;
			op = Code.Fsin;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fsincos instruction.<br/>
		/// <br/>
		/// <c>FSINCOS</c><br/>
		/// <br/>
		/// <c>D9 FB</c><br/>
		/// <br/>
		/// <c>387+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsincos() {
			Code op;
			op = Code.Fsincos;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fsqrt instruction.<br/>
		/// <br/>
		/// <c>FSQRT</c><br/>
		/// <br/>
		/// <c>D9 FA</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsqrt() {
			Code op;
			op = Code.Fsqrt;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fst instruction.<br/>
		/// <br/>
		/// <c>FST ST(i)</c><br/>
		/// <br/>
		/// <c>DD D0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fst(Register dst) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fst_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fst), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstcw instruction.<br/>
		/// <br/>
		/// <c>FSTCW m2byte</c><br/>
		/// <br/>
		/// <c>9B D9 /7</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fstcw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Fstcw_m2byte;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstdw instruction.<br/>
		/// <br/>
		/// <c>FSTDW AX</c><br/>
		/// <br/>
		/// <c>DF E1</c><br/>
		/// <br/>
		/// <c>387 SL</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void fstdw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstdw_AX;
			} else {
				throw NoOpCodeFoundFor(nameof(fstdw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstp instruction.<br/>
		/// <br/>
		/// <c>FSTP ST(i)</c><br/>
		/// <br/>
		/// <c>DD D8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fstp(Register dst) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fstp_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fstp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstpnce instruction.<br/>
		/// <br/>
		/// <c>FSTPNCE ST(i)</c><br/>
		/// <br/>
		/// <c>D9 D8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fstpnce(Register dst) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fstpnce_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fstpnce), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstsg instruction.<br/>
		/// <br/>
		/// <c>FSTSG AX</c><br/>
		/// <br/>
		/// <c>DF E2</c><br/>
		/// <br/>
		/// <c>387 SL</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void fstsg(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstsg_AX;
			} else {
				throw NoOpCodeFoundFor(nameof(fstsg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstsw instruction.<br/>
		/// <br/>
		/// <c>FSTSW AX</c><br/>
		/// <br/>
		/// <c>9B DF E0</c><br/>
		/// <br/>
		/// <c>287+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fstsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstsw_AX;
			} else {
				throw NoOpCodeFoundFor(nameof(fstsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fstsw instruction.<br/>
		/// <br/>
		/// <c>FSTSW m2byte</c><br/>
		/// <br/>
		/// <c>9B DD /7</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fstsw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Fstsw_m2byte;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fsub instruction.<br/>
		/// <br/>
		/// <c>FSUB ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>D8 E0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>FSUB ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DC E8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsub(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fsub_st0_sti;
			} else if (dst.IsST()) {
				op = Code.Fsub_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fsub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fsubp instruction.<br/>
		/// <br/>
		/// <c>FSUBP ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DE E8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsubp(Register dst, Register src) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fsubp_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fsubp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fsubr instruction.<br/>
		/// <br/>
		/// <c>FSUBR ST(0), ST(i)</c><br/>
		/// <br/>
		/// <c>D8 E8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>FSUBR ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DC E0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsubr(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fsubr_st0_sti;
			} else if (dst.IsST()) {
				op = Code.Fsubr_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fsubr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fsubrp instruction.<br/>
		/// <br/>
		/// <c>FSUBRP ST(i), ST(0)</c><br/>
		/// <br/>
		/// <c>DE E0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fsubrp(Register dst, Register src) {
			Code op;
			if (dst.IsST()) {
				op = Code.Fsubrp_sti_st0;
			} else {
				throw NoOpCodeFoundFor(nameof(fsubrp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ftst instruction.<br/>
		/// <br/>
		/// <c>FTST</c><br/>
		/// <br/>
		/// <c>D9 E4</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ftst() {
			Code op;
			op = Code.Ftst;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fucom instruction.<br/>
		/// <br/>
		/// <c>FUCOM ST(i)</c><br/>
		/// <br/>
		/// <c>DD E0+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fucom(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fucom_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fucom), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fucomi instruction.<br/>
		/// <br/>
		/// <c>FUCOMI ST, ST(i)</c><br/>
		/// <br/>
		/// <c>DB E8+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fucomi(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fucomi_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fucomi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fucomip instruction.<br/>
		/// <br/>
		/// <c>FUCOMIP ST, ST(i)</c><br/>
		/// <br/>
		/// <c>DF E8+i</c><br/>
		/// <br/>
		/// <c>8087+ and CMOV</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fucomip(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fucomip_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fucomip), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fucomp instruction.<br/>
		/// <br/>
		/// <c>FUCOMP ST(i)</c><br/>
		/// <br/>
		/// <c>DD E8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fucomp(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fucomp_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fucomp), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fucompp instruction.<br/>
		/// <br/>
		/// <c>FUCOMPP</c><br/>
		/// <br/>
		/// <c>DA E9</c><br/>
		/// <br/>
		/// <c>387+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fucompp() {
			Code op;
			op = Code.Fucompp;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fxam instruction.<br/>
		/// <br/>
		/// <c>FXAM</c><br/>
		/// <br/>
		/// <c>D9 E5</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxam() {
			Code op;
			op = Code.Fxam;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fxch instruction.<br/>
		/// <br/>
		/// <c>FXCH ST(i)</c><br/>
		/// <br/>
		/// <c>D9 C8+i</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxch(Register dst, Register src) {
			Code op;
			if (dst == Register.ST0) {
				op = Code.Fxch_st0_sti;
			} else {
				throw NoOpCodeFoundFor(nameof(fxch), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>fxrstor instruction.<br/>
		/// <br/>
		/// <c>FXRSTOR m512byte</c><br/>
		/// <br/>
		/// <c>NP 0F AE /1</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxrstor(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Fxrstor_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxrstor), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxrstor instruction.<br/>
		/// <br/>
		/// <c>FXRSTOR m512byte</c><br/>
		/// <br/>
		/// <c>NP 0F AE /1</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxrstor(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Fxrstor_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxrstor), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxrstor64 instruction.<br/>
		/// <br/>
		/// <c>FXRSTOR64 m512byte</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /1</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void fxrstor64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Fxrstor64_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxrstor64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxrstor64 instruction.<br/>
		/// <br/>
		/// <c>FXRSTOR64 m512byte</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /1</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void fxrstor64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Fxrstor64_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxrstor64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxsave instruction.<br/>
		/// <br/>
		/// <c>FXSAVE m512byte</c><br/>
		/// <br/>
		/// <c>NP 0F AE /0</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxsave(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Fxsave_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxsave), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxsave instruction.<br/>
		/// <br/>
		/// <c>FXSAVE m512byte</c><br/>
		/// <br/>
		/// <c>NP 0F AE /0</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxsave(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Fxsave_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxsave), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxsave64 instruction.<br/>
		/// <br/>
		/// <c>FXSAVE64 m512byte</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /0</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void fxsave64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Fxsave64_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxsave64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxsave64 instruction.<br/>
		/// <br/>
		/// <c>FXSAVE64 m512byte</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /0</c><br/>
		/// <br/>
		/// <c>FXSR</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void fxsave64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Fxsave64_m512byte;
			} else {
				throw NoOpCodeFoundFor(nameof(fxsave64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>fxtract instruction.<br/>
		/// <br/>
		/// <c>FXTRACT</c><br/>
		/// <br/>
		/// <c>D9 F4</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fxtract() {
			Code op;
			op = Code.Fxtract;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fyl2x instruction.<br/>
		/// <br/>
		/// <c>FYL2X</c><br/>
		/// <br/>
		/// <c>D9 F1</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fyl2x() {
			Code op;
			op = Code.Fyl2x;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>fyl2xp1 instruction.<br/>
		/// <br/>
		/// <c>FYL2XP1</c><br/>
		/// <br/>
		/// <c>D9 F9</c><br/>
		/// <br/>
		/// <c>8087+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void fyl2xp1() {
			Code op;
			op = Code.Fyl2xp1;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>getsec instruction.<br/>
		/// <br/>
		/// <c>GETSEC</c><br/>
		/// <br/>
		/// <c>NP 0F 37</c><br/>
		/// <br/>
		/// <c>SMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void getsec() {
			Code op;
			op = Code.Getsec;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>gf2p8affineinvqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void gf2p8affineinvqb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Gf2p8affineinvqb_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(gf2p8affineinvqb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>gf2p8affineinvqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void gf2p8affineinvqb(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Gf2p8affineinvqb_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(gf2p8affineinvqb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>gf2p8affineqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void gf2p8affineqb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Gf2p8affineqb_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(gf2p8affineqb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>gf2p8affineqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void gf2p8affineqb(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Gf2p8affineqb_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(gf2p8affineqb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>gf2p8mulb instruction.<br/>
		/// <br/>
		/// <c>GF2P8MULB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 CF /r</c><br/>
		/// <br/>
		/// <c>GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void gf2p8mulb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Gf2p8mulb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(gf2p8mulb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>gf2p8mulb instruction.<br/>
		/// <br/>
		/// <c>GF2P8MULB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 CF /r</c><br/>
		/// <br/>
		/// <c>GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void gf2p8mulb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Gf2p8mulb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(gf2p8mulb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>haddpd instruction.<br/>
		/// <br/>
		/// <c>HADDPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 7C /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void haddpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Haddpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(haddpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>haddpd instruction.<br/>
		/// <br/>
		/// <c>HADDPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 7C /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void haddpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Haddpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(haddpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>haddps instruction.<br/>
		/// <br/>
		/// <c>HADDPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F 7C /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void haddps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Haddps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(haddps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>haddps instruction.<br/>
		/// <br/>
		/// <c>HADDPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F 7C /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void haddps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Haddps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(haddps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>hlt instruction.<br/>
		/// <br/>
		/// <c>HLT</c><br/>
		/// <br/>
		/// <c>F4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void hlt() {
			Code op;
			op = Code.Hlt;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>hsubpd instruction.<br/>
		/// <br/>
		/// <c>HSUBPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 7D /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void hsubpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Hsubpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(hsubpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>hsubpd instruction.<br/>
		/// <br/>
		/// <c>HSUBPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 7D /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void hsubpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Hsubpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(hsubpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>hsubps instruction.<br/>
		/// <br/>
		/// <c>HSUBPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F 7D /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void hsubps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Hsubps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(hsubps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>hsubps instruction.<br/>
		/// <br/>
		/// <c>HSUBPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F2 0F 7D /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void hsubps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Hsubps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(hsubps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ibts instruction.<br/>
		/// <br/>
		/// <c>IBTS r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F A7 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>IBTS r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F A7 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void ibts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Ibts_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(ibts), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ibts instruction.<br/>
		/// <br/>
		/// <c>IBTS r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F A7 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>IBTS r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F A7 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void ibts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ibts_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(ibts), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>idiv instruction.<br/>
		/// <br/>
		/// <c>IDIV r/m8</c><br/>
		/// <br/>
		/// <c>F6 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IDIV r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IDIV r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /7</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IDIV r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /7</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void idiv(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Idiv_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Idiv_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Idiv_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Idiv_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(idiv), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>idiv instruction.<br/>
		/// <br/>
		/// <c>IDIV r/m8</c><br/>
		/// <br/>
		/// <c>F6 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IDIV r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IDIV r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /7</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IDIV r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /7</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void idiv(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Idiv_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Idiv_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Idiv_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Idiv_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(idiv), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>imul instruction.<br/>
		/// <br/>
		/// <c>IMUL r/m8</c><br/>
		/// <br/>
		/// <c>F6 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /5</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /5</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void imul(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Imul_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(imul), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>imul instruction.<br/>
		/// <br/>
		/// <c>IMUL r/m8</c><br/>
		/// <br/>
		/// <c>F6 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /5</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /5</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void imul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Imul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Imul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Imul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Imul_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(imul), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>imul instruction.<br/>
		/// <br/>
		/// <c>IMUL r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F AF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F AF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F AF /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void imul(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(imul), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>imul instruction.<br/>
		/// <br/>
		/// <c>IMUL r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F AF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F AF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F AF /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void imul(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(imul), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>imul instruction.<br/>
		/// <br/>
		/// <c>IMUL r16, r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 69 /r iw</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 69 /r id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r64, r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 69 /r id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void imul(Register dst, Register src, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Imul_r64_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Imul_r32_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Imul_r16_rm16_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(imul), dst, src, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(imul), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>imul instruction.<br/>
		/// <br/>
		/// <c>IMUL r16, r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 69 /r iw</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 69 /r id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IMUL r64, r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 69 /r id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void imul(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Imul_r64_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Imul_r32_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Imul_r16_rm16_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(imul), dst, src, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(imul), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>in instruction.<br/>
		/// <br/>
		/// <c>IN AL, DX</c><br/>
		/// <br/>
		/// <c>EC</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IN AX, DX</c><br/>
		/// <br/>
		/// <c>o16 ED</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IN EAX, DX</c><br/>
		/// <br/>
		/// <c>o32 ED</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void @in(Register dst, Register src) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.In_EAX_DX;
			} else if (dst == Register.AX) {
				op = Code.In_AX_DX;
			} else if (dst == Register.AL) {
				op = Code.In_AL_DX;
			} else {
				throw NoOpCodeFoundFor(nameof(@in), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>in instruction.<br/>
		/// <br/>
		/// </summary>
		public void @in(Register dst, int imm) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.In_EAX_imm8;
			} else if (dst == Register.AX) {
				op = Code.In_AX_imm8;
			} else if (dst == Register.AL) {
				op = Code.In_AL_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(@in), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>inc instruction.<br/>
		/// <br/>
		/// <c>INC r16</c><br/>
		/// <br/>
		/// <c>o16 40+rw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INC r32</c><br/>
		/// <br/>
		/// <c>o32 40+rd</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INC r/m8</c><br/>
		/// <br/>
		/// <c>FE /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>INC r/m64</c><br/>
		/// <br/>
		/// <c>REX.W FF /0</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void inc(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Inc_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Inc_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Inc_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Inc_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(inc), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>inc instruction.<br/>
		/// <br/>
		/// <c>INC r/m8</c><br/>
		/// <br/>
		/// <c>FE /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>INC r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>INC r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /0</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>INC r/m64</c><br/>
		/// <br/>
		/// <c>REX.W FF /0</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void inc(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Inc_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Inc_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Inc_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Inc_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(inc), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>incsspd instruction.<br/>
		/// <br/>
		/// <c>INCSSPD r32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /5</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void incsspd(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Incsspd_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(incsspd), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>incsspq instruction.<br/>
		/// <br/>
		/// <c>INCSSPQ r64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /5</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void incsspq(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Incsspq_r64;
			} else {
				throw NoOpCodeFoundFor(nameof(incsspq), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>insb instruction.<br/>
		/// <br/>
		/// <c>INSB</c><br/>
		/// <br/>
		/// <c>6C</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void insb(Register src) {
			Code op;
			if (src == Register.DX) {
				op = Code.Insb_m8_DX;
			} else {
				throw NoOpCodeFoundFor(nameof(insb), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>insd instruction.<br/>
		/// <br/>
		/// <c>INSD</c><br/>
		/// <br/>
		/// <c>o32 6D</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void insd(Register src) {
			Code op;
			if (src == Register.DX) {
				op = Code.Insd_m32_DX;
			} else {
				throw NoOpCodeFoundFor(nameof(insd), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>insertps instruction.<br/>
		/// <br/>
		/// </summary>
		public void insertps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Insertps_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(insertps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>insertps instruction.<br/>
		/// <br/>
		/// </summary>
		public void insertps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Insertps_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(insertps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>insertq instruction.<br/>
		/// <br/>
		/// <c>INSERTQ xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>F2 0F 79 /r</c><br/>
		/// <br/>
		/// <c>SSE4A</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void insertq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Insertq_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(insertq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>insw instruction.<br/>
		/// <br/>
		/// <c>INSW</c><br/>
		/// <br/>
		/// <c>o16 6D</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void insw(Register src) {
			Code op;
			if (src == Register.DX) {
				op = Code.Insw_m16_DX;
			} else {
				throw NoOpCodeFoundFor(nameof(insw), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>int instruction.<br/>
		/// <br/>
		/// <c>INT3</c><br/>
		/// <br/>
		/// <c>CC</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void @int() {
			Code op;
			op = Code.Int3;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>int instruction.<br/>
		/// <br/>
		/// </summary>
		public void @int(int imm) {
			Code op;
			op = Code.Int_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>int1 instruction.<br/>
		/// <br/>
		/// <c>INT1</c><br/>
		/// <br/>
		/// <c>F1</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void int1() {
			Code op;
			op = Code.Int1;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>into instruction.<br/>
		/// <br/>
		/// <c>INTO</c><br/>
		/// <br/>
		/// <c>CE</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void into() {
			Code op;
			op = Code.Into;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>invd instruction.<br/>
		/// <br/>
		/// <c>INVD</c><br/>
		/// <br/>
		/// <c>0F 08</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void invd() {
			Code op;
			op = Code.Invd;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>invept instruction.<br/>
		/// <br/>
		/// <c>INVEPT r32, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 80 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 20]</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVEPT r64, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 80 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 20]</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invept(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Invept_r64_m128;
			} else if (dst.IsGPR32()) {
				op = Code.Invept_r32_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(invept), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>invept instruction.<br/>
		/// <br/>
		/// <c>INVEPT r32, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 80 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 20]</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVEPT r64, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 80 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 20]</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invept(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Invept_r64_m128;
			} else if (dst.IsGPR32()) {
				op = Code.Invept_r32_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(invept), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>invlpg instruction.<br/>
		/// <br/>
		/// <c>INVLPG m</c><br/>
		/// <br/>
		/// <c>0F 01 /7</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void invlpg(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Invlpg_m;
			} else {
				throw NoOpCodeFoundFor(nameof(invlpg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>invlpg instruction.<br/>
		/// <br/>
		/// <c>INVLPG m</c><br/>
		/// <br/>
		/// <c>0F 01 /7</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void invlpg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Invlpg_m;
			} else {
				throw NoOpCodeFoundFor(nameof(invlpg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>invlpga instruction.<br/>
		/// <br/>
		/// <c>INVLPGA</c><br/>
		/// <br/>
		/// <c>a16 0F 01 DF</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVLPGA</c><br/>
		/// <br/>
		/// <c>a32 0F 01 DF</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>INVLPGA</c><br/>
		/// <br/>
		/// <c>0F 01 DF</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invlpga() {
			Code op;
			if (Bitness == 64) {
				op = Code.Invlpgaq;
			} else if (Bitness == 32) {
				op = Code.Invlpgad;
			} else if (Bitness == 16) {
				op = Code.Invlpgaw;
			} else {
				throw NoOpCodeFoundFor(nameof(invlpga));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>invpcid instruction.<br/>
		/// <br/>
		/// <c>INVPCID r32, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 82 /r</c><br/>
		/// <br/>
		/// <c>INVPCID</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVPCID r64, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 82 /r</c><br/>
		/// <br/>
		/// <c>INVPCID</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invpcid(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Invpcid_r64_m128;
			} else if (dst.IsGPR32()) {
				op = Code.Invpcid_r32_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(invpcid), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>invpcid instruction.<br/>
		/// <br/>
		/// <c>INVPCID r32, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 82 /r</c><br/>
		/// <br/>
		/// <c>INVPCID</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVPCID r64, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 82 /r</c><br/>
		/// <br/>
		/// <c>INVPCID</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invpcid(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Invpcid_r64_m128;
			} else if (dst.IsGPR32()) {
				op = Code.Invpcid_r32_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(invpcid), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>invvpid instruction.<br/>
		/// <br/>
		/// <c>INVVPID r32, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 81 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 32]</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVVPID r64, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 81 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 32]</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invvpid(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Invvpid_r64_m128;
			} else if (dst.IsGPR32()) {
				op = Code.Invvpid_r32_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(invvpid), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>invvpid instruction.<br/>
		/// <br/>
		/// <c>INVVPID r32, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 81 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 32]</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>INVVPID r64, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 81 /r</c><br/>
		/// <br/>
		/// <c>VMX and IA32_VMX_EPT_VPID_CAP[bit 32]</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void invvpid(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Invvpid_r64_m128;
			} else if (dst.IsGPR32()) {
				op = Code.Invvpid_r32_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(invvpid), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>iret instruction.<br/>
		/// <br/>
		/// <c>IRET</c><br/>
		/// <br/>
		/// <c>o16 CF</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IRETD</c><br/>
		/// <br/>
		/// <c>o32 CF</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>IRETQ</c><br/>
		/// <br/>
		/// <c>REX.W CF</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void iret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Iretq;
			} else if (Bitness == 32) {
				op = Code.Iretd;
			} else if (Bitness == 16) {
				op = Code.Iretw;
			} else {
				throw NoOpCodeFoundFor(nameof(iret));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>jmp instruction.<br/>
		/// <br/>
		/// <c>JMP r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>JMP r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /4</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>JMP r/m64</c><br/>
		/// <br/>
		/// <c>FF /4</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void jmp(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Jmp_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Jmp_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Jmp_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(jmp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>jmp instruction.<br/>
		/// <br/>
		/// <c>JMP r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>JMP r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /4</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>JMP r/m64</c><br/>
		/// <br/>
		/// <c>FF /4</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void jmp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Jmp_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmp_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmp_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(jmp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>jmpe instruction.<br/>
		/// <br/>
		/// <c>JMPE r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /6</c><br/>
		/// <br/>
		/// <c>IA-64</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>JMPE r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 00 /6</c><br/>
		/// <br/>
		/// <c>IA-64</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void jmpe(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Jmpe_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Jmpe_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(jmpe), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>jmpe instruction.<br/>
		/// <br/>
		/// <c>JMPE r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /6</c><br/>
		/// <br/>
		/// <c>IA-64</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>JMPE r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 00 /6</c><br/>
		/// <br/>
		/// <c>IA-64</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void jmpe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmpe_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmpe_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(jmpe), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>kaddb instruction.<br/>
		/// <br/>
		/// <c>KADDB k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 4A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kaddb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kaddb_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kaddb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kaddd instruction.<br/>
		/// <br/>
		/// <c>KADDD k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W1 4A /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kaddd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kaddd_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kaddd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kaddq instruction.<br/>
		/// <br/>
		/// <c>KADDQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 4A /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kaddq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kaddq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kaddq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kaddw instruction.<br/>
		/// <br/>
		/// <c>KADDW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 4A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kaddw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kaddw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kaddw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandb instruction.<br/>
		/// <br/>
		/// <c>KANDB k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 41 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandb_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandd instruction.<br/>
		/// <br/>
		/// <c>KANDD k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W1 41 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandd_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandnb instruction.<br/>
		/// <br/>
		/// <c>KANDNB k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandnb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandnb_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandnb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandnd instruction.<br/>
		/// <br/>
		/// <c>KANDND k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandnd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandnd_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandnd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandnq instruction.<br/>
		/// <br/>
		/// <c>KANDNQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandnq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandnq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandnq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandnw instruction.<br/>
		/// <br/>
		/// <c>KANDNW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandnw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandnw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandnw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandq instruction.<br/>
		/// <br/>
		/// <c>KANDQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 41 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kandw instruction.<br/>
		/// <br/>
		/// <c>KANDW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 41 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kandw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kandw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kandw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kmovb instruction.<br/>
		/// <br/>
		/// <c>KMOVB k1, r32</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 92 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>KMOVB r32, k1</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 93 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>KMOVB k1, k2/m8</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.VEX_Kmovb_r32_k;
			} else if (dst.IsK() && src.IsGPR32()) {
				op = Code.VEX_Kmovb_k_r32;
			} else if (dst.IsK() && src.IsK()) {
				op = Code.VEX_Kmovb_k_km8;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovb instruction.<br/>
		/// <br/>
		/// <c>KMOVB k1, k2/m8</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kmovb_k_km8;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovd instruction.<br/>
		/// <br/>
		/// <c>KMOVD k1, r32</c><br/>
		/// <br/>
		/// <c>VEX.L0.F2.0F.W0 92 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>KMOVD r32, k1</c><br/>
		/// <br/>
		/// <c>VEX.L0.F2.0F.W0 93 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>KMOVD k1, k2/m32</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W1 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.VEX_Kmovd_r32_k;
			} else if (dst.IsK() && src.IsGPR32()) {
				op = Code.VEX_Kmovd_k_r32;
			} else if (dst.IsK() && src.IsK()) {
				op = Code.VEX_Kmovd_k_km32;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovd instruction.<br/>
		/// <br/>
		/// <c>KMOVD k1, k2/m32</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W1 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kmovd_k_km32;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovq instruction.<br/>
		/// <br/>
		/// <c>KMOVQ k1, r64</c><br/>
		/// <br/>
		/// <c>VEX.L0.F2.0F.W1 92 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>KMOVQ r64, k1</c><br/>
		/// <br/>
		/// <c>VEX.L0.F2.0F.W1 93 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>KMOVQ k1, k2/m64</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W1 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovq(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Kmovq_r64_k;
			} else if (dst.IsK() && src.IsGPR64()) {
				op = Code.VEX_Kmovq_k_r64;
			} else if (dst.IsK() && src.IsK()) {
				op = Code.VEX_Kmovq_k_km64;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovq instruction.<br/>
		/// <br/>
		/// <c>KMOVQ k1, k2/m64</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W1 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kmovq_k_km64;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovw instruction.<br/>
		/// <br/>
		/// <c>KMOVW k1, r32</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 92 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>KMOVW r32, k1</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 93 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>KMOVW k1, k2/m16</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovw(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.VEX_Kmovw_r32_k;
			} else if (dst.IsK() && src.IsGPR32()) {
				op = Code.VEX_Kmovw_k_r32;
			} else if (dst.IsK() && src.IsK()) {
				op = Code.VEX_Kmovw_k_km16;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kmovw instruction.<br/>
		/// <br/>
		/// <c>KMOVW k1, k2/m16</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 90 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kmovw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kmovw_k_km16;
			} else {
				throw NoOpCodeFoundFor(nameof(kmovw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>knotb instruction.<br/>
		/// <br/>
		/// <c>KNOTB k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void knotb(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Knotb_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(knotb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>knotd instruction.<br/>
		/// <br/>
		/// <c>KNOTD k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void knotd(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Knotd_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(knotd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>knotq instruction.<br/>
		/// <br/>
		/// <c>KNOTQ k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void knotq(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Knotq_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(knotq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>knotw instruction.<br/>
		/// <br/>
		/// <c>KNOTW k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void knotw(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Knotw_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(knotw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>korb instruction.<br/>
		/// <br/>
		/// <c>KORB k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void korb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Korb_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(korb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kord instruction.<br/>
		/// <br/>
		/// <c>KORD k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kord(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kord_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>korq instruction.<br/>
		/// <br/>
		/// <c>KORQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void korq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Korq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(korq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kortestb instruction.<br/>
		/// <br/>
		/// <c>KORTESTB k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kortestb(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kortestb_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kortestb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kortestd instruction.<br/>
		/// <br/>
		/// <c>KORTESTD k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W1 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kortestd(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kortestd_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kortestd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kortestq instruction.<br/>
		/// <br/>
		/// <c>KORTESTQ k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W1 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kortestq(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kortestq_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kortestq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kortestw instruction.<br/>
		/// <br/>
		/// <c>KORTESTW k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kortestw(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kortestw_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kortestw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>korw instruction.<br/>
		/// <br/>
		/// <c>KORW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void korw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Korw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(korw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kshiftlb instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftlb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftlb_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftlb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftld instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftld(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftld_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftlq instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftlq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftlq_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftlq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftlw instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftlw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftlw_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftlw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftrb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftrb_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftrd_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftrq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftrq_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>kshiftrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void kshiftrw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kshiftrw_k_k_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(kshiftrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>ktestb instruction.<br/>
		/// <br/>
		/// <c>KTESTB k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W0 99 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ktestb(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Ktestb_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(ktestb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ktestd instruction.<br/>
		/// <br/>
		/// <c>KTESTD k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.66.0F.W1 99 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ktestd(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Ktestd_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(ktestd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ktestq instruction.<br/>
		/// <br/>
		/// <c>KTESTQ k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W1 99 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ktestq(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Ktestq_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(ktestq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ktestw instruction.<br/>
		/// <br/>
		/// <c>KTESTW k1, k2</c><br/>
		/// <br/>
		/// <c>VEX.L0.0F.W0 99 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ktestw(Register dst, Register src) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Ktestw_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(ktestw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>kunpckbw instruction.<br/>
		/// <br/>
		/// <c>KUNPCKBW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 4B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kunpckbw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kunpckbw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kunpckbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kunpckdq instruction.<br/>
		/// <br/>
		/// <c>KUNPCKDQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 4B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kunpckdq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kunpckdq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kunpckdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kunpckwd instruction.<br/>
		/// <br/>
		/// <c>KUNPCKWD k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 4B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kunpckwd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kunpckwd_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kunpckwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxnorb instruction.<br/>
		/// <br/>
		/// <c>KXNORB k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxnorb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxnorb_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxnorb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxnord instruction.<br/>
		/// <br/>
		/// <c>KXNORD k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxnord(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxnord_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxnord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxnorq instruction.<br/>
		/// <br/>
		/// <c>KXNORQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxnorq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxnorq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxnorq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxnorw instruction.<br/>
		/// <br/>
		/// <c>KXNORW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxnorw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxnorw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxnorw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxorb instruction.<br/>
		/// <br/>
		/// <c>KXORB k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxorb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxorb_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxorb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxord instruction.<br/>
		/// <br/>
		/// <c>KXORD k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.66.0F.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxord(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxord_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxorq instruction.<br/>
		/// <br/>
		/// <c>KXORQ k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxorq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxorq_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxorq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>kxorw instruction.<br/>
		/// <br/>
		/// <c>KXORW k1, k2, k3</c><br/>
		/// <br/>
		/// <c>VEX.L1.0F.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void kxorw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK()) {
				op = Code.VEX_Kxorw_k_k_k;
			} else {
				throw NoOpCodeFoundFor(nameof(kxorw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>lahf instruction.<br/>
		/// <br/>
		/// <c>LAHF</c><br/>
		/// <br/>
		/// <c>9F</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lahf() {
			Code op;
			op = Code.Lahf;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>lar instruction.<br/>
		/// <br/>
		/// <c>LAR r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 02 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LAR r32, r32/m16</c><br/>
		/// <br/>
		/// <c>o32 0F 02 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LAR r64, r64/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F 02 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lar(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lar), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>lar instruction.<br/>
		/// <br/>
		/// <c>LAR r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 02 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LAR r32, r32/m16</c><br/>
		/// <br/>
		/// <c>o32 0F 02 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LAR r64, r64/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F 02 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lar(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lar), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>lddqu instruction.<br/>
		/// <br/>
		/// <c>LDDQU xmm1, m128</c><br/>
		/// <br/>
		/// <c>F2 0F F0 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lddqu(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Lddqu_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(lddqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>lddqu instruction.<br/>
		/// <br/>
		/// <c>LDDQU xmm1, m128</c><br/>
		/// <br/>
		/// <c>F2 0F F0 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lddqu(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Lddqu_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(lddqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ldmxcsr instruction.<br/>
		/// <br/>
		/// <c>LDMXCSR m32</c><br/>
		/// <br/>
		/// <c>NP 0F AE /2</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ldmxcsr(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Ldmxcsr_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lea instruction.<br/>
		/// <br/>
		/// <c>LEA r16, m</c><br/>
		/// <br/>
		/// <c>o16 8D /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LEA r32, m</c><br/>
		/// <br/>
		/// <c>o32 8D /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LEA r64, m</c><br/>
		/// <br/>
		/// <c>REX.W 8D /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lea(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lea_r64_m;
			} else if (dst.IsGPR32()) {
				op = Code.Lea_r32_m;
			} else if (dst.IsGPR16()) {
				op = Code.Lea_r16_m;
			} else {
				throw NoOpCodeFoundFor(nameof(lea), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>lea instruction.<br/>
		/// <br/>
		/// <c>LEA r16, m</c><br/>
		/// <br/>
		/// <c>o16 8D /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LEA r32, m</c><br/>
		/// <br/>
		/// <c>o32 8D /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LEA r64, m</c><br/>
		/// <br/>
		/// <c>REX.W 8D /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lea(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lea_r64_m;
			} else if (dst.IsGPR32()) {
				op = Code.Lea_r32_m;
			} else if (dst.IsGPR16()) {
				op = Code.Lea_r16_m;
			} else {
				throw NoOpCodeFoundFor(nameof(lea), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>leave instruction.<br/>
		/// <br/>
		/// <c>LEAVE</c><br/>
		/// <br/>
		/// <c>o16 C9</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LEAVE</c><br/>
		/// <br/>
		/// <c>o32 C9</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>LEAVE</c><br/>
		/// <br/>
		/// <c>C9</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void leave() {
			Code op;
			if (Bitness == 64) {
				op = Code.Leaveq;
			} else if (Bitness == 32) {
				op = Code.Leaved;
			} else if (Bitness == 16) {
				op = Code.Leavew;
			} else {
				throw NoOpCodeFoundFor(nameof(leave));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>lfence instruction.<br/>
		/// <br/>
		/// <c>LFENCE</c><br/>
		/// <br/>
		/// <c>NP 0F AE E8</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lfence() {
			Code op;
			op = Code.Lfence;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>lldt instruction.<br/>
		/// <br/>
		/// <c>LLDT r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /2</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lldt(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Lldt_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lldt), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lldt instruction.<br/>
		/// <br/>
		/// <c>LLDT r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /2</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lldt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Lldt_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lldt), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>llwpcb instruction.<br/>
		/// <br/>
		/// <c>LLWPCB r32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 12 /0</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LLWPCB r64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 12 /0</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void llwpcb(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Llwpcb_r64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Llwpcb_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(llwpcb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lmsw instruction.<br/>
		/// <br/>
		/// <c>LMSW r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 01 /6</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lmsw(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Lmsw_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lmsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lmsw instruction.<br/>
		/// <br/>
		/// <c>LMSW r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 01 /6</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lmsw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Lmsw_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lmsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>loadall instruction.<br/>
		/// <br/>
		/// <c>LOADALL</c><br/>
		/// <br/>
		/// <c>0F 07</c><br/>
		/// <br/>
		/// <c>386</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void loadall() {
			Code op;
			op = Code.Loadall386;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>lodsb instruction.<br/>
		/// <br/>
		/// <c>LODSB</c><br/>
		/// <br/>
		/// <c>AC</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lodsb(Register dst) {
			Code op;
			if (dst == Register.AL) {
				op = Code.Lodsb_AL_m8;
			} else {
				throw NoOpCodeFoundFor(nameof(lodsb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lodsd instruction.<br/>
		/// <br/>
		/// <c>LODSD</c><br/>
		/// <br/>
		/// <c>o32 AD</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lodsd(Register dst) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.Lodsd_EAX_m32;
			} else {
				throw NoOpCodeFoundFor(nameof(lodsd), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lodsq instruction.<br/>
		/// <br/>
		/// <c>LODSQ</c><br/>
		/// <br/>
		/// <c>REX.W AD</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lodsq(Register dst) {
			Code op;
			if (dst == Register.RAX) {
				op = Code.Lodsq_RAX_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(lodsq), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lodsw instruction.<br/>
		/// <br/>
		/// <c>LODSW</c><br/>
		/// <br/>
		/// <c>o16 AD</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void lodsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Lodsw_AX_m16;
			} else {
				throw NoOpCodeFoundFor(nameof(lodsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lsl instruction.<br/>
		/// <br/>
		/// <c>LSL r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 03 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LSL r32, r32/m16</c><br/>
		/// <br/>
		/// <c>o32 0F 03 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LSL r64, r64/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F 03 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lsl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lsl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>lsl instruction.<br/>
		/// <br/>
		/// <c>LSL r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 03 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LSL r32, r32/m16</c><br/>
		/// <br/>
		/// <c>o32 0F 03 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LSL r64, r64/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F 03 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lsl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lsl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ltr instruction.<br/>
		/// <br/>
		/// <c>LTR r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /3</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ltr(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Ltr_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ltr), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>ltr instruction.<br/>
		/// <br/>
		/// <c>LTR r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /3</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ltr(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ltr_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ltr), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>lwpins instruction.<br/>
		/// <br/>
		/// <c>LWPINS r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W0 12 /0 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LWPINS r64, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W1 12 /0 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lwpins(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Lwpins_r64_rm32_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Lwpins_r32_rm32_imm32;
			} else {
				throw NoOpCodeFoundFor(nameof(lwpins), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>lwpins instruction.<br/>
		/// <br/>
		/// <c>LWPINS r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W0 12 /0 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LWPINS r64, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W1 12 /0 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lwpins(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Lwpins_r64_rm32_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Lwpins_r32_rm32_imm32;
			} else {
				throw NoOpCodeFoundFor(nameof(lwpins), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>lwpval instruction.<br/>
		/// <br/>
		/// <c>LWPVAL r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W0 12 /1 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LWPVAL r64, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W1 12 /1 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lwpval(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Lwpval_r64_rm32_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Lwpval_r32_rm32_imm32;
			} else {
				throw NoOpCodeFoundFor(nameof(lwpval), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>lwpval instruction.<br/>
		/// <br/>
		/// <c>LWPVAL r32, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W0 12 /1 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LWPVAL r64, r/m32, imm32</c><br/>
		/// <br/>
		/// <c>XOP.L0.XA.W1 12 /1 id</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lwpval(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Lwpval_r64_rm32_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Lwpval_r32_rm32_imm32;
			} else {
				throw NoOpCodeFoundFor(nameof(lwpval), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>lzcnt instruction.<br/>
		/// <br/>
		/// <c>LZCNT r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F3 0F BD /r</c><br/>
		/// <br/>
		/// <c>LZCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LZCNT r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F3 0F BD /r</c><br/>
		/// <br/>
		/// <c>LZCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LZCNT r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F BD /r</c><br/>
		/// <br/>
		/// <c>LZCNT</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lzcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lzcnt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>lzcnt instruction.<br/>
		/// <br/>
		/// <c>LZCNT r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F3 0F BD /r</c><br/>
		/// <br/>
		/// <c>LZCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LZCNT r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F3 0F BD /r</c><br/>
		/// <br/>
		/// <c>LZCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>LZCNT r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F BD /r</c><br/>
		/// <br/>
		/// <c>LZCNT</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void lzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(lzcnt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxpd instruction.<br/>
		/// <br/>
		/// <c>MAXPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(maxpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxpd instruction.<br/>
		/// <br/>
		/// <c>MAXPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(maxpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxps instruction.<br/>
		/// <br/>
		/// <c>MAXPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(maxps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxps instruction.<br/>
		/// <br/>
		/// <c>MAXPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(maxps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxsd instruction.<br/>
		/// <br/>
		/// <c>MAXSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(maxsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxsd instruction.<br/>
		/// <br/>
		/// <c>MAXSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(maxsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxss instruction.<br/>
		/// <br/>
		/// <c>MAXSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(maxss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>maxss instruction.<br/>
		/// <br/>
		/// <c>MAXSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5F /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void maxss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Maxss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(maxss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mcommit instruction.<br/>
		/// <br/>
		/// <c>MCOMMIT</c><br/>
		/// <br/>
		/// <c>F3 0F 01 FA</c><br/>
		/// <br/>
		/// <c>MCOMMIT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mcommit() {
			Code op;
			op = Code.Mcommit;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>mfence instruction.<br/>
		/// <br/>
		/// <c>MFENCE</c><br/>
		/// <br/>
		/// <c>NP 0F AE F0</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mfence() {
			Code op;
			op = Code.Mfence;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>minpd instruction.<br/>
		/// <br/>
		/// <c>MINPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(minpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minpd instruction.<br/>
		/// <br/>
		/// <c>MINPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(minpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minps instruction.<br/>
		/// <br/>
		/// <c>MINPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(minps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minps instruction.<br/>
		/// <br/>
		/// <c>MINPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(minps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minsd instruction.<br/>
		/// <br/>
		/// <c>MINSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(minsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minsd instruction.<br/>
		/// <br/>
		/// <c>MINSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(minsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minss instruction.<br/>
		/// <br/>
		/// <c>MINSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(minss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>minss instruction.<br/>
		/// <br/>
		/// <c>MINSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5D /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void minss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Minss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(minss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>monitor instruction.<br/>
		/// <br/>
		/// <c>MONITOR</c><br/>
		/// <br/>
		/// <c>a16 NP 0F 01 C8</c><br/>
		/// <br/>
		/// <c>MONITOR</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MONITOR</c><br/>
		/// <br/>
		/// <c>a32 NP 0F 01 C8</c><br/>
		/// <br/>
		/// <c>MONITOR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MONITOR</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C8</c><br/>
		/// <br/>
		/// <c>MONITOR</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void monitor() {
			Code op;
			if (Bitness == 64) {
				op = Code.Monitorq;
			} else if (Bitness == 32) {
				op = Code.Monitord;
			} else if (Bitness == 16) {
				op = Code.Monitorw;
			} else {
				throw NoOpCodeFoundFor(nameof(monitor));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>monitorx instruction.<br/>
		/// <br/>
		/// <c>MONITORX</c><br/>
		/// <br/>
		/// <c>a16 NP 0F 01 FA</c><br/>
		/// <br/>
		/// <c>MONITORX</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MONITORX</c><br/>
		/// <br/>
		/// <c>a32 NP 0F 01 FA</c><br/>
		/// <br/>
		/// <c>MONITORX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MONITORX</c><br/>
		/// <br/>
		/// <c>NP 0F 01 FA</c><br/>
		/// <br/>
		/// <c>MONITORX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void monitorx() {
			Code op;
			if (Bitness == 64) {
				op = Code.Monitorxq;
			} else if (Bitness == 32) {
				op = Code.Monitorxd;
			} else if (Bitness == 16) {
				op = Code.Monitorxw;
			} else {
				throw NoOpCodeFoundFor(nameof(monitorx));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>montmul instruction.<br/>
		/// <br/>
		/// <c>MONTMUL</c><br/>
		/// <br/>
		/// <c>a16 0F A6 C0</c><br/>
		/// <br/>
		/// <c>PADLOCK_PMM</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MONTMUL</c><br/>
		/// <br/>
		/// <c>a32 0F A6 C0</c><br/>
		/// <br/>
		/// <c>PADLOCK_PMM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MONTMUL</c><br/>
		/// <br/>
		/// <c>0F A6 C0</c><br/>
		/// <br/>
		/// <c>PADLOCK_PMM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void montmul() {
			Code op;
			if (Bitness == 64) {
				op = Code.Montmul_64;
			} else if (Bitness == 32) {
				op = Code.Montmul_32;
			} else if (Bitness == 16) {
				op = Code.Montmul_16;
			} else {
				throw NoOpCodeFoundFor(nameof(montmul));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>mov instruction.<br/>
		/// <br/>
		/// <c>MOV r32, cr</c><br/>
		/// <br/>
		/// <c>0F 20 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MOV cr, r32</c><br/>
		/// <br/>
		/// <c>0F 22 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MOV r/m8, r8</c><br/>
		/// <br/>
		/// <c>88 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 89 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 89 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 89 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mov(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_rm32_r32;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_cr;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_rm8_r8;
			} else if (dst.IsCr()) {
				op = Code.Mov_cr_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(mov), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mov instruction.<br/>
		/// <br/>
		/// <c>MOV r/m8, r8</c><br/>
		/// <br/>
		/// <c>88 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 89 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 89 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 89 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mov_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mov_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mov_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mov_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(mov), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mov instruction.<br/>
		/// <br/>
		/// <c>MOV r8, r/m8</c><br/>
		/// <br/>
		/// <c>8A /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 8B /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 8B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 8B /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(mov), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mov instruction.<br/>
		/// <br/>
		/// <c>MOV r16, imm16</c><br/>
		/// <br/>
		/// <c>o16 B8+rw iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r32, imm32</c><br/>
		/// <br/>
		/// <c>o32 B8+rd id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r64, imm64</c><br/>
		/// <br/>
		/// <c>REX.W B8+ro io</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mov(Register dst, long imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR8()) {
					op = Code.Mov_r8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(mov), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Mov_r64_imm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(mov), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>mov instruction.<br/>
		/// <br/>
		/// <c>MOV r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 C7 /0 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 C7 /0 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOV r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W C7 /0 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mov(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Mov_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(mov), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mov_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mov_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mov_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(mov), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>movapd instruction.<br/>
		/// <br/>
		/// <c>MOVAPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 28 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movapd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movapd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movapd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movapd instruction.<br/>
		/// <br/>
		/// <c>MOVAPD xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 29 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movapd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movapd_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movapd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movapd instruction.<br/>
		/// <br/>
		/// <c>MOVAPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 28 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movapd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movapd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movapd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movaps instruction.<br/>
		/// <br/>
		/// <c>MOVAPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 28 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movaps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movaps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movaps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movaps instruction.<br/>
		/// <br/>
		/// <c>MOVAPS xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>NP 0F 29 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movaps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movaps_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movaps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movaps instruction.<br/>
		/// <br/>
		/// <c>MOVAPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 28 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movaps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movaps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movaps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movbe instruction.<br/>
		/// <br/>
		/// <c>MOVBE m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>MOVBE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVBE m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>MOVBE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVBE m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 38 F1 /r</c><br/>
		/// <br/>
		/// <c>MOVBE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movbe(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Movbe_m64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Movbe_m32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Movbe_m16_r16;
			} else {
				throw NoOpCodeFoundFor(nameof(movbe), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movbe instruction.<br/>
		/// <br/>
		/// <c>MOVBE r16, m16</c><br/>
		/// <br/>
		/// <c>o16 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>MOVBE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVBE r32, m32</c><br/>
		/// <br/>
		/// <c>o32 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>MOVBE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVBE r64, m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 38 F0 /r</c><br/>
		/// <br/>
		/// <c>MOVBE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movbe(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movbe_r64_m64;
			} else if (dst.IsGPR32()) {
				op = Code.Movbe_r32_m32;
			} else if (dst.IsGPR16()) {
				op = Code.Movbe_r16_m16;
			} else {
				throw NoOpCodeFoundFor(nameof(movbe), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movd instruction.<br/>
		/// <br/>
		/// <c>MOVD mm, r/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 6E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVD xmm, r/m32</c><br/>
		/// <br/>
		/// <c>66 0F 6E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVD r/m32, mm</c><br/>
		/// <br/>
		/// <c>NP 0F 7E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVD r/m32, xmm</c><br/>
		/// <br/>
		/// <c>66 0F 7E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movd_xmm_rm32;
			} else if (dst.IsGPR32() && src.IsXMM()) {
				op = Code.Movd_rm32_xmm;
			} else if (dst.IsGPR32() && src.IsMM()) {
				op = Code.Movd_rm32_mm;
			} else if (dst.IsMM()) {
				op = Code.Movd_mm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(movd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movd instruction.<br/>
		/// <br/>
		/// <c>MOVD r/m32, mm</c><br/>
		/// <br/>
		/// <c>NP 0F 7E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVD r/m32, xmm</c><br/>
		/// <br/>
		/// <c>66 0F 7E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr && src.IsXMM()) {
				op = Code.Movd_rm32_xmm;
			} else if (dst.Size == MemoryOperandSize.DwordPtr && src.IsMM()) {
				op = Code.Movd_rm32_mm;
			} else {
				throw NoOpCodeFoundFor(nameof(movd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movd instruction.<br/>
		/// <br/>
		/// <c>MOVD mm, r/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 6E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVD xmm, r/m32</c><br/>
		/// <br/>
		/// <c>66 0F 6E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movd_xmm_rm32;
			} else if (dst.IsMM()) {
				op = Code.Movd_mm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(movd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movddup instruction.<br/>
		/// <br/>
		/// <c>MOVDDUP xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movddup(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movddup_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(movddup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movddup instruction.<br/>
		/// <br/>
		/// <c>MOVDDUP xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movddup(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movddup_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(movddup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdir64b instruction.<br/>
		/// <br/>
		/// <c>MOVDIR64B r16, m512</c><br/>
		/// <br/>
		/// <c>a16 66 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>MOVDIR64B</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MOVDIR64B r32, m512</c><br/>
		/// <br/>
		/// <c>a32 66 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>MOVDIR64B</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVDIR64B r64, m512</c><br/>
		/// <br/>
		/// <c>66 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>MOVDIR64B</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movdir64b(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movdir64b_r64_m512;
			} else if (dst.IsGPR32()) {
				op = Code.Movdir64b_r32_m512;
			} else if (dst.IsGPR16()) {
				op = Code.Movdir64b_r16_m512;
			} else {
				throw NoOpCodeFoundFor(nameof(movdir64b), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdir64b instruction.<br/>
		/// <br/>
		/// <c>MOVDIR64B r16, m512</c><br/>
		/// <br/>
		/// <c>a16 66 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>MOVDIR64B</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>MOVDIR64B r32, m512</c><br/>
		/// <br/>
		/// <c>a32 66 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>MOVDIR64B</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVDIR64B r64, m512</c><br/>
		/// <br/>
		/// <c>66 0F 38 F8 /r</c><br/>
		/// <br/>
		/// <c>MOVDIR64B</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movdir64b(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movdir64b_r64_m512;
			} else if (dst.IsGPR32()) {
				op = Code.Movdir64b_r32_m512;
			} else if (dst.IsGPR16()) {
				op = Code.Movdir64b_r16_m512;
			} else {
				throw NoOpCodeFoundFor(nameof(movdir64b), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdiri instruction.<br/>
		/// <br/>
		/// <c>MOVDIRI m32, r32</c><br/>
		/// <br/>
		/// <c>NP 0F 38 F9 /r</c><br/>
		/// <br/>
		/// <c>MOVDIRI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVDIRI m64, r64</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 38 F9 /r</c><br/>
		/// <br/>
		/// <c>MOVDIRI</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movdiri(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Movdiri_m64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Movdiri_m32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(movdiri), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdq2q instruction.<br/>
		/// <br/>
		/// <c>MOVDQ2Q mm, xmm</c><br/>
		/// <br/>
		/// <c>F2 0F D6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdq2q(Register dst, Register src) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Movdq2q_mm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movdq2q), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdqa instruction.<br/>
		/// <br/>
		/// <c>MOVDQA xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdqa(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movdqa_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdqa instruction.<br/>
		/// <br/>
		/// <c>MOVDQA xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 7F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdqa(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movdqa_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdqa instruction.<br/>
		/// <br/>
		/// <c>MOVDQA xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdqa(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movdqa_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdqu instruction.<br/>
		/// <br/>
		/// <c>MOVDQU xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 6F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdqu(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movdqu_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movdqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdqu instruction.<br/>
		/// <br/>
		/// <c>MOVDQU xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>F3 0F 7F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdqu(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movdqu_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movdqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movdqu instruction.<br/>
		/// <br/>
		/// <c>MOVDQU xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 6F /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movdqu(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movdqu_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movdqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhlps instruction.<br/>
		/// <br/>
		/// <c>MOVHLPS xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>NP 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhlps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movhlps_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movhlps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhpd instruction.<br/>
		/// <br/>
		/// <c>MOVHPD xmm1, m64</c><br/>
		/// <br/>
		/// <c>66 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movhpd_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhpd instruction.<br/>
		/// <br/>
		/// <c>MOVHPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 17 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movhpd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhpd instruction.<br/>
		/// <br/>
		/// <c>MOVHPD xmm1, m64</c><br/>
		/// <br/>
		/// <c>66 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movhpd_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhps instruction.<br/>
		/// <br/>
		/// <c>MOVHPS xmm1, m64</c><br/>
		/// <br/>
		/// <c>NP 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movhps_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhps instruction.<br/>
		/// <br/>
		/// <c>MOVHPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>NP 0F 17 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movhps_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movhps instruction.<br/>
		/// <br/>
		/// <c>MOVHPS xmm1, m64</c><br/>
		/// <br/>
		/// <c>NP 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movhps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movhps_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlhps instruction.<br/>
		/// <br/>
		/// <c>MOVLHPS xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>NP 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlhps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movlhps_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movlhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlpd instruction.<br/>
		/// <br/>
		/// <c>MOVLPD xmm1, m64</c><br/>
		/// <br/>
		/// <c>66 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movlpd_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movlpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlpd instruction.<br/>
		/// <br/>
		/// <c>MOVLPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 13 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movlpd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movlpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlpd instruction.<br/>
		/// <br/>
		/// <c>MOVLPD xmm1, m64</c><br/>
		/// <br/>
		/// <c>66 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movlpd_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movlpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlps instruction.<br/>
		/// <br/>
		/// <c>MOVLPS xmm1, m64</c><br/>
		/// <br/>
		/// <c>NP 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movlps_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movlps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlps instruction.<br/>
		/// <br/>
		/// <c>MOVLPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>NP 0F 13 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movlps_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movlps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movlps instruction.<br/>
		/// <br/>
		/// <c>MOVLPS xmm1, m64</c><br/>
		/// <br/>
		/// <c>NP 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movlps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movlps_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(movlps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movmskpd instruction.<br/>
		/// <br/>
		/// <c>MOVMSKPD r32, xmm</c><br/>
		/// <br/>
		/// <c>66 0F 50 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVMSKPD r64, xmm</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 50 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movmskpd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movmskpd_r64_xmm;
			} else if (dst.IsGPR32()) {
				op = Code.Movmskpd_r32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movmskpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movmskps instruction.<br/>
		/// <br/>
		/// <c>MOVMSKPS r32, xmm</c><br/>
		/// <br/>
		/// <c>NP 0F 50 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVMSKPS r64, xmm</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 50 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movmskps(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movmskps_r64_xmm;
			} else if (dst.IsGPR32()) {
				op = Code.Movmskps_r32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movmskps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntdq instruction.<br/>
		/// <br/>
		/// <c>MOVNTDQ m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F E7 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntdq_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntdq instruction.<br/>
		/// <br/>
		/// <c>MOVNTDQ m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F E7 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntdq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movntdq_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntdqa instruction.<br/>
		/// <br/>
		/// <c>MOVNTDQA xmm1, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 2A /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntdqa(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntdqa_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(movntdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntdqa instruction.<br/>
		/// <br/>
		/// <c>MOVNTDQA xmm1, m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 2A /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntdqa(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntdqa_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(movntdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movnti instruction.<br/>
		/// <br/>
		/// <c>MOVNTI m32, r32</c><br/>
		/// <br/>
		/// <c>NP 0F C3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVNTI m64, r64</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movnti(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Movnti_m64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Movnti_m32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(movnti), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntpd instruction.<br/>
		/// <br/>
		/// <c>MOVNTPD m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntpd_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntpd instruction.<br/>
		/// <br/>
		/// <c>MOVNTPD m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movntpd_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntps instruction.<br/>
		/// <br/>
		/// <c>MOVNTPS m128, xmm1</c><br/>
		/// <br/>
		/// <c>NP 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntps_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntps instruction.<br/>
		/// <br/>
		/// <c>MOVNTPS m128, xmm1</c><br/>
		/// <br/>
		/// <c>NP 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movntps_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntq instruction.<br/>
		/// <br/>
		/// <c>MOVNTQ m64, mm</c><br/>
		/// <br/>
		/// <c>NP 0F E7 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntq_m64_mm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntq instruction.<br/>
		/// <br/>
		/// <c>MOVNTQ m64, mm</c><br/>
		/// <br/>
		/// <c>NP 0F E7 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movntq_m64_mm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntsd instruction.<br/>
		/// <br/>
		/// <c>MOVNTSD m64, xmm1</c><br/>
		/// <br/>
		/// <c>F2 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE4A</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntsd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntsd instruction.<br/>
		/// <br/>
		/// <c>MOVNTSD m64, xmm1</c><br/>
		/// <br/>
		/// <c>F2 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE4A</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntsd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movntsd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntss instruction.<br/>
		/// <br/>
		/// <c>MOVNTSS m32, xmm1</c><br/>
		/// <br/>
		/// <c>F3 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE4A</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movntss_m32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movntss instruction.<br/>
		/// <br/>
		/// <c>MOVNTSS m32, xmm1</c><br/>
		/// <br/>
		/// <c>F3 0F 2B /r</c><br/>
		/// <br/>
		/// <c>SSE4A</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movntss(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movntss_m32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movntss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movq instruction.<br/>
		/// <br/>
		/// <c>MOVQ mm, r/m64</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 6E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ xmm, r/m64</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 6E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 6F /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVQ r/m64, mm</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 7E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ r/m64, xmm</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 7E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F3 0F 7E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsXMM()) {
				op = Code.Movq_xmm_xmmm64;
			} else if (dst.IsXMM() && src.IsGPR64()) {
				op = Code.Movq_xmm_rm64;
			} else if (dst.IsGPR64() && src.IsXMM()) {
				op = Code.Movq_rm64_xmm;
			} else if (dst.IsGPR64() && src.IsMM()) {
				op = Code.Movq_rm64_mm;
			} else if (dst.IsMM() && src.IsGPR64()) {
				op = Code.Movq_mm_rm64;
			} else if (dst.IsMM() && src.IsMM()) {
				op = Code.Movq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(movq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movq instruction.<br/>
		/// <br/>
		/// <c>MOVQ r/m64, mm</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 7E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ r/m64, xmm</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 7E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ mm/m64, mm</c><br/>
		/// <br/>
		/// <c>NP 0F 7F /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVQ xmm2/m64, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F D6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movq_xmmm64_xmm;
			} else if (dst.Size == MemoryOperandSize.QwordPtr && src.IsXMM()) {
				op = Code.Movq_rm64_xmm;
			} else if (dst.Size == MemoryOperandSize.QwordPtr && src.IsMM()) {
				op = Code.Movq_rm64_mm;
			} else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Movq_mmm64_mm;
			} else {
				throw NoOpCodeFoundFor(nameof(movq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movq instruction.<br/>
		/// <br/>
		/// <c>MOVQ mm, r/m64</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 6E /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ xmm, r/m64</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 6E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 6F /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F3 0F 7E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movq_xmm_xmmm64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Movq_xmm_rm64;
			} else if (dst.IsMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Movq_mm_rm64;
			} else if (dst.IsMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Movq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(movq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movq2dq instruction.<br/>
		/// <br/>
		/// <c>MOVQ2DQ xmm, mm</c><br/>
		/// <br/>
		/// <c>F3 0F D6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movq2dq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movq2dq_xmm_mm;
			} else {
				throw NoOpCodeFoundFor(nameof(movq2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsb instruction.<br/>
		/// <br/>
		/// <c>MOVSB</c><br/>
		/// <br/>
		/// <c>A4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsb() {
			Code op;
			op = Code.Movsb_m8_m8;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>movsd instruction.<br/>
		/// <br/>
		/// <c>MOVSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(movsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsd instruction.<br/>
		/// <br/>
		/// <c>MOVSD xmm1/m64, xmm2</c><br/>
		/// <br/>
		/// <c>F2 0F 11 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movsd_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsd instruction.<br/>
		/// <br/>
		/// <c>MOVSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(movsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsd instruction.<br/>
		/// <br/>
		/// <c>MOVSD</c><br/>
		/// <br/>
		/// <c>o32 A5</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsd() {
			Code op;
			op = Code.Movsd_m32_m32;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>movshdup instruction.<br/>
		/// <br/>
		/// <c>MOVSHDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movshdup(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movshdup_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movshdup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movshdup instruction.<br/>
		/// <br/>
		/// <c>MOVSHDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 16 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movshdup(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movshdup_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movshdup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsldup instruction.<br/>
		/// <br/>
		/// <c>MOVSLDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsldup(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movsldup_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movsldup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsldup instruction.<br/>
		/// <br/>
		/// <c>MOVSLDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>F3 0F 12 /r</c><br/>
		/// <br/>
		/// <c>SSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsldup(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movsldup_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movsldup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsq instruction.<br/>
		/// <br/>
		/// <c>MOVSQ</c><br/>
		/// <br/>
		/// <c>REX.W A5</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movsq() {
			Code op;
			op = Code.Movsq_m64_m64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>movss instruction.<br/>
		/// <br/>
		/// <c>MOVSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(movss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movss instruction.<br/>
		/// <br/>
		/// <c>MOVSS xmm2/m32, xmm1</c><br/>
		/// <br/>
		/// <c>F3 0F 11 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movss(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movss_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movss instruction.<br/>
		/// <br/>
		/// <c>MOVSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(movss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsw instruction.<br/>
		/// <br/>
		/// <c>MOVSW</c><br/>
		/// <br/>
		/// <c>o16 A5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movsw() {
			Code op;
			op = Code.Movsw_m16_m16;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>movsx instruction.<br/>
		/// <br/>
		/// <c>MOVSX r16, r/m8</c><br/>
		/// <br/>
		/// <c>o16 0F BE /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r32, r/m8</c><br/>
		/// <br/>
		/// <c>o32 0F BE /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r64, r/m8</c><br/>
		/// <br/>
		/// <c>REX.W 0F BE /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVSX r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F BF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r32, r/m16</c><br/>
		/// <br/>
		/// <c>o32 0F BF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r64, r/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F BF /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movsx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR16()) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Movsx_r16_rm16;
			} else if (dst.IsGPR16() && src.IsGPR8()) {
				op = Code.Movsx_r16_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(movsx), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsx instruction.<br/>
		/// <br/>
		/// <c>MOVSX r16, r/m8</c><br/>
		/// <br/>
		/// <c>o16 0F BE /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r32, r/m8</c><br/>
		/// <br/>
		/// <c>o32 0F BE /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r64, r/m8</c><br/>
		/// <br/>
		/// <c>REX.W 0F BE /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVSX r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F BF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r32, r/m16</c><br/>
		/// <br/>
		/// <c>o32 0F BF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVSX r64, r/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F BF /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movsx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r16_rm16;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r16_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(movsx), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsxd instruction.<br/>
		/// <br/>
		/// <c>MOVSXD r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 63 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVSXD r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 63 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVSXD r64, r/m32</c><br/>
		/// <br/>
		/// <c>REX.W 63 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movsxd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(movsxd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movsxd instruction.<br/>
		/// <br/>
		/// <c>MOVSXD r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 63 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVSXD r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 63 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVSXD r64, r/m32</c><br/>
		/// <br/>
		/// <c>REX.W 63 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movsxd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(movsxd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movupd instruction.<br/>
		/// <br/>
		/// <c>MOVUPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movupd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movupd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movupd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movupd instruction.<br/>
		/// <br/>
		/// <c>MOVUPD xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>66 0F 11 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movupd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movupd_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movupd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movupd instruction.<br/>
		/// <br/>
		/// <c>MOVUPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movupd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movupd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movupd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movups instruction.<br/>
		/// <br/>
		/// <c>MOVUPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movups(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movups_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movups), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movups instruction.<br/>
		/// <br/>
		/// <c>MOVUPS xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>NP 0F 11 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movups(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Movups_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(movups), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movups instruction.<br/>
		/// <br/>
		/// <c>MOVUPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 10 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void movups(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Movups_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(movups), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movzx instruction.<br/>
		/// <br/>
		/// <c>MOVZX r16, r/m8</c><br/>
		/// <br/>
		/// <c>o16 0F B6 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r32, r/m8</c><br/>
		/// <br/>
		/// <c>o32 0F B6 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r64, r/m8</c><br/>
		/// <br/>
		/// <c>REX.W 0F B6 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVZX r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F B7 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r32, r/m16</c><br/>
		/// <br/>
		/// <c>o32 0F B7 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r64, r/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F B7 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movzx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR16()) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Movzx_r16_rm16;
			} else if (dst.IsGPR16() && src.IsGPR8()) {
				op = Code.Movzx_r16_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(movzx), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>movzx instruction.<br/>
		/// <br/>
		/// <c>MOVZX r16, r/m8</c><br/>
		/// <br/>
		/// <c>o16 0F B6 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r32, r/m8</c><br/>
		/// <br/>
		/// <c>o32 0F B6 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r64, r/m8</c><br/>
		/// <br/>
		/// <c>REX.W 0F B6 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>MOVZX r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F B7 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r32, r/m16</c><br/>
		/// <br/>
		/// <c>o32 0F B7 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MOVZX r64, r/m16</c><br/>
		/// <br/>
		/// <c>REX.W 0F B7 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void movzx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r16_rm16;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r16_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(movzx), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mpsadbw instruction.<br/>
		/// <br/>
		/// </summary>
		public void mpsadbw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mpsadbw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(mpsadbw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>mpsadbw instruction.<br/>
		/// <br/>
		/// </summary>
		public void mpsadbw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mpsadbw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(mpsadbw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>mul instruction.<br/>
		/// <br/>
		/// <c>MUL r/m8</c><br/>
		/// <br/>
		/// <c>F6 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MUL r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MUL r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /4</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MUL r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /4</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mul(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mul_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mul_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mul_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mul_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(mul), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>mul instruction.<br/>
		/// <br/>
		/// <c>MUL r/m8</c><br/>
		/// <br/>
		/// <c>F6 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MUL r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MUL r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /4</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MUL r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /4</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mul_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(mul), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>mulpd instruction.<br/>
		/// <br/>
		/// <c>MULPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(mulpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulpd instruction.<br/>
		/// <br/>
		/// <c>MULPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(mulpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulps instruction.<br/>
		/// <br/>
		/// <c>MULPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(mulps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulps instruction.<br/>
		/// <br/>
		/// <c>MULPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(mulps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulsd instruction.<br/>
		/// <br/>
		/// <c>MULSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(mulsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulsd instruction.<br/>
		/// <br/>
		/// <c>MULSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(mulsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulss instruction.<br/>
		/// <br/>
		/// <c>MULSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(mulss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulss instruction.<br/>
		/// <br/>
		/// <c>MULSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 59 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mulss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Mulss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(mulss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>mulx instruction.<br/>
		/// <br/>
		/// <c>MULX r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W0 F6 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MULX r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W1 F6 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mulx(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Mulx_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Mulx_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(mulx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>mulx instruction.<br/>
		/// <br/>
		/// <c>MULX r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W0 F6 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>MULX r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W1 F6 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void mulx(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Mulx_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Mulx_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(mulx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>mwait instruction.<br/>
		/// <br/>
		/// <c>MWAIT</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C9</c><br/>
		/// <br/>
		/// <c>MONITOR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mwait() {
			Code op;
			op = Code.Mwait;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>mwaitx instruction.<br/>
		/// <br/>
		/// <c>MWAITX</c><br/>
		/// <br/>
		/// <c>0F 01 FB</c><br/>
		/// <br/>
		/// <c>MONITORX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void mwaitx() {
			Code op;
			op = Code.Mwaitx;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>neg instruction.<br/>
		/// <br/>
		/// <c>NEG r/m8</c><br/>
		/// <br/>
		/// <c>F6 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NEG r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NEG r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /3</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NEG r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /3</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void neg(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Neg_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Neg_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Neg_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Neg_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(neg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>neg instruction.<br/>
		/// <br/>
		/// <c>NEG r/m8</c><br/>
		/// <br/>
		/// <c>F6 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NEG r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NEG r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /3</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NEG r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /3</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void neg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Neg_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Neg_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Neg_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Neg_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(neg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>nop instruction.<br/>
		/// <br/>
		/// <c>NOP</c><br/>
		/// <br/>
		/// <c>o16 90</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOP</c><br/>
		/// <br/>
		/// <c>o32 90</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOP</c><br/>
		/// <br/>
		/// <c>REX.W 90</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void nop() {
			Code op;
			if (Bitness == 64) {
				op = Code.Nopq;
			} else if (Bitness == 32) {
				op = Code.Nopd;
			} else if (Bitness == 16) {
				op = Code.Nopw;
			} else {
				throw NoOpCodeFoundFor(nameof(nop));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>nop instruction.<br/>
		/// <br/>
		/// <c>NOP r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 1F /0</c><br/>
		/// <br/>
		/// <c>CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOP r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 1F /0</c><br/>
		/// <br/>
		/// <c>CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOP r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 1F /0</c><br/>
		/// <br/>
		/// <c>CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void nop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Nop_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Nop_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Nop_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(nop), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>nop instruction.<br/>
		/// <br/>
		/// <c>NOP r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 1F /0</c><br/>
		/// <br/>
		/// <c>CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOP r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 1F /0</c><br/>
		/// <br/>
		/// <c>CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOP r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F 1F /0</c><br/>
		/// <br/>
		/// <c>CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void nop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Nop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Nop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Nop_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(nop), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>not instruction.<br/>
		/// <br/>
		/// <c>NOT r/m8</c><br/>
		/// <br/>
		/// <c>F6 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOT r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOT r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /2</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOT r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /2</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void not(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Not_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Not_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Not_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Not_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(not), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>not instruction.<br/>
		/// <br/>
		/// <c>NOT r/m8</c><br/>
		/// <br/>
		/// <c>F6 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOT r/m16</c><br/>
		/// <br/>
		/// <c>o16 F7 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOT r/m32</c><br/>
		/// <br/>
		/// <c>o32 F7 /2</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>NOT r/m64</c><br/>
		/// <br/>
		/// <c>REX.W F7 /2</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void not(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Not_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Not_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Not_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Not_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(not), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>or instruction.<br/>
		/// <br/>
		/// <c>OR r/m8, r8</c><br/>
		/// <br/>
		/// <c>08 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 09 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 09 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 09 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void or(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(or), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>or instruction.<br/>
		/// <br/>
		/// <c>OR r/m8, r8</c><br/>
		/// <br/>
		/// <c>08 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 09 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 09 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 09 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void or(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Or_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Or_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Or_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Or_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(or), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>or instruction.<br/>
		/// <br/>
		/// <c>OR r8, r/m8</c><br/>
		/// <br/>
		/// <c>0A /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0B /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0B /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void or(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(or), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>or instruction.<br/>
		/// <br/>
		/// <c>OR AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 0D iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 0D id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 0D id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>OR r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /1 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /1 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /1 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void or(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Or_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Or_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Or_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Or_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Or_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(or), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Or_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Or_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Or_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Or_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Or_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Or_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(or), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>or instruction.<br/>
		/// <br/>
		/// <c>OR r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /1 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /1 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OR r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /1 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void or(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Or_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Or_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Or_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Or_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(or), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Or_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Or_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Or_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(or), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>orpd instruction.<br/>
		/// <br/>
		/// <c>ORPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 56 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void orpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Orpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(orpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>orpd instruction.<br/>
		/// <br/>
		/// <c>ORPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 56 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void orpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Orpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(orpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>orps instruction.<br/>
		/// <br/>
		/// <c>ORPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 56 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void orps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Orps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(orps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>orps instruction.<br/>
		/// <br/>
		/// <c>ORPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 56 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void orps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Orps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(orps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>out instruction.<br/>
		/// <br/>
		/// <c>OUT DX, AL</c><br/>
		/// <br/>
		/// <c>EE</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OUT DX, AX</c><br/>
		/// <br/>
		/// <c>o16 EF</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>OUT DX, EAX</c><br/>
		/// <br/>
		/// <c>o32 EF</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void @out(Register dst, Register src) {
			Code op;
			if (dst == Register.DX && src == Register.EAX) {
				op = Code.Out_DX_EAX;
			} else if (dst == Register.DX && src == Register.AX) {
				op = Code.Out_DX_AX;
			} else if (dst == Register.DX && src == Register.AL) {
				op = Code.Out_DX_AL;
			} else {
				throw NoOpCodeFoundFor(nameof(@out), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>out instruction.<br/>
		/// <br/>
		/// </summary>
		public void @out(int imm, Register src) {
			Code op;
			if (src == Register.EAX) {
				op = Code.Out_imm8_EAX;
			} else if (src == Register.AX) {
				op = Code.Out_imm8_AX;
			} else if (src == Register.AL) {
				op = Code.Out_imm8_AL;
			} else {
				throw NoOpCodeFoundFor(nameof(@out), imm, src);
			}
			AddInstruction(Instruction.Create(op, imm, src));
		}
		/// <summary>outsb instruction.<br/>
		/// <br/>
		/// <c>OUTSB</c><br/>
		/// <br/>
		/// <c>6E</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void outsb(Register dst) {
			Code op;
			if (dst == Register.DX) {
				op = Code.Outsb_DX_m8;
			} else {
				throw NoOpCodeFoundFor(nameof(outsb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>outsd instruction.<br/>
		/// <br/>
		/// <c>OUTSD</c><br/>
		/// <br/>
		/// <c>o32 6F</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void outsd(Register dst) {
			Code op;
			if (dst == Register.DX) {
				op = Code.Outsd_DX_m32;
			} else {
				throw NoOpCodeFoundFor(nameof(outsd), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>outsw instruction.<br/>
		/// <br/>
		/// <c>OUTSW</c><br/>
		/// <br/>
		/// <c>o16 6F</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void outsw(Register dst) {
			Code op;
			if (dst == Register.DX) {
				op = Code.Outsw_DX_m16;
			} else {
				throw NoOpCodeFoundFor(nameof(outsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>pabsb instruction.<br/>
		/// <br/>
		/// <c>PABSB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 1C /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PABSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 1C /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pabsb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pabsb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pabsb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pabsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pabsb instruction.<br/>
		/// <br/>
		/// <c>PABSB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 1C /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PABSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 1C /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pabsb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pabsb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pabsb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pabsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pabsd instruction.<br/>
		/// <br/>
		/// <c>PABSD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 1E /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PABSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 1E /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pabsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pabsd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pabsd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pabsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pabsd instruction.<br/>
		/// <br/>
		/// <c>PABSD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 1E /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PABSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 1E /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pabsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pabsd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pabsd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pabsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pabsw instruction.<br/>
		/// <br/>
		/// <c>PABSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 1D /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PABSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 1D /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pabsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pabsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pabsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pabsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pabsw instruction.<br/>
		/// <br/>
		/// <c>PABSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 1D /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PABSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 1D /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pabsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pabsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pabsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pabsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packssdw instruction.<br/>
		/// <br/>
		/// <c>PACKSSDW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 6B /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PACKSSDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packssdw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packssdw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Packssdw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(packssdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packssdw instruction.<br/>
		/// <br/>
		/// <c>PACKSSDW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 6B /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PACKSSDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6B /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packssdw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packssdw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Packssdw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(packssdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packsswb instruction.<br/>
		/// <br/>
		/// <c>PACKSSWB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 63 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PACKSSWB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 63 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packsswb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packsswb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Packsswb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(packsswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packsswb instruction.<br/>
		/// <br/>
		/// <c>PACKSSWB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 63 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PACKSSWB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 63 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packsswb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packsswb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Packsswb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(packsswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packusdw instruction.<br/>
		/// <br/>
		/// <c>PACKUSDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 2B /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packusdw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packusdw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(packusdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packusdw instruction.<br/>
		/// <br/>
		/// <c>PACKUSDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 2B /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packusdw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packusdw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(packusdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packuswb instruction.<br/>
		/// <br/>
		/// <c>PACKUSWB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 67 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PACKUSWB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 67 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packuswb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packuswb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Packuswb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(packuswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>packuswb instruction.<br/>
		/// <br/>
		/// <c>PACKUSWB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 67 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PACKUSWB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 67 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void packuswb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Packuswb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Packuswb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(packuswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddb instruction.<br/>
		/// <br/>
		/// <c>PADDB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FC /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FC /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddb instruction.<br/>
		/// <br/>
		/// <c>PADDB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FC /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FC /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddd instruction.<br/>
		/// <br/>
		/// <c>PADDD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FE /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FE /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddd instruction.<br/>
		/// <br/>
		/// <c>PADDD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FE /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FE /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddq instruction.<br/>
		/// <br/>
		/// <c>PADDQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D4 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddq instruction.<br/>
		/// <br/>
		/// <c>PADDQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D4 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddsb instruction.<br/>
		/// <br/>
		/// <c>PADDSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EC /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EC /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddsb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddsb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddsb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddsb instruction.<br/>
		/// <br/>
		/// <c>PADDSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EC /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EC /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddsb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddsb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddsb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddsw instruction.<br/>
		/// <br/>
		/// <c>PADDSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F ED /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F ED /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddsw instruction.<br/>
		/// <br/>
		/// <c>PADDSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F ED /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F ED /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddusb instruction.<br/>
		/// <br/>
		/// <c>PADDUSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DC /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDUSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DC /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddusb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddusb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddusb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddusb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddusb instruction.<br/>
		/// <br/>
		/// <c>PADDUSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DC /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDUSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DC /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddusb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddusb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddusb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddusb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddusw instruction.<br/>
		/// <br/>
		/// <c>PADDUSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DD /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDUSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DD /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddusw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddusw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddusw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddusw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddusw instruction.<br/>
		/// <br/>
		/// <c>PADDUSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DD /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDUSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DD /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddusw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddusw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddusw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddusw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddw instruction.<br/>
		/// <br/>
		/// <c>PADDW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FD /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FD /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>paddw instruction.<br/>
		/// <br/>
		/// <c>PADDW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FD /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PADDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FD /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void paddw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Paddw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Paddw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(paddw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>palignr instruction.<br/>
		/// <br/>
		/// </summary>
		public void palignr(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Palignr_xmm_xmmm128_imm8;
			} else if (dst.IsMM()) {
				op = Code.Palignr_mm_mmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(palignr), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>palignr instruction.<br/>
		/// <br/>
		/// </summary>
		public void palignr(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Palignr_xmm_xmmm128_imm8;
			} else if (dst.IsMM()) {
				op = Code.Palignr_mm_mmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(palignr), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pand instruction.<br/>
		/// <br/>
		/// <c>PAND mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DB /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PAND xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pand(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pand_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pand_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pand), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pand instruction.<br/>
		/// <br/>
		/// <c>PAND mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DB /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PAND xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pand(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pand_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pand_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pand), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pandn instruction.<br/>
		/// <br/>
		/// <c>PANDN mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DF /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PANDN xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DF /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pandn(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pandn_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pandn_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pandn), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pandn instruction.<br/>
		/// <br/>
		/// <c>PANDN mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DF /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PANDN xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DF /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pandn(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pandn_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pandn_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pandn), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pause instruction.<br/>
		/// <br/>
		/// <c>PAUSE</c><br/>
		/// <br/>
		/// <c>F3 90</c><br/>
		/// <br/>
		/// <c>Pentium 4 or later</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pause() {
			Code op;
			op = Code.Pause;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pavgb instruction.<br/>
		/// <br/>
		/// <c>PAVGB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E0 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PAVGB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E0 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pavgb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pavgb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pavgb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pavgb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pavgb instruction.<br/>
		/// <br/>
		/// <c>PAVGB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E0 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PAVGB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E0 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pavgb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pavgb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pavgb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pavgb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pavgusb instruction.<br/>
		/// <br/>
		/// <c>PAVGUSB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r BF</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pavgusb() {
			Code op;
			op = Code.D3NOW_Pavgusb_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pavgw instruction.<br/>
		/// <br/>
		/// <c>PAVGW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E3 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PAVGW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pavgw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pavgw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pavgw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pavgw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pavgw instruction.<br/>
		/// <br/>
		/// <c>PAVGW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E3 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PAVGW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pavgw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pavgw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pavgw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pavgw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pblendvb instruction.<br/>
		/// <br/>
		/// <c>PBLENDVB xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>66 0F 38 10 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pblendvb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pblendvb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pblendvb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pblendvb instruction.<br/>
		/// <br/>
		/// <c>PBLENDVB xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>66 0F 38 10 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pblendvb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pblendvb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pblendvb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pblendw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pblendw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pblendw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pblendw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pblendw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pblendw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pblendw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pblendw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pclmulqdq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pclmulqdq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pclmulqdq_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pclmulqdq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pclmulqdq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pclmulqdq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pclmulqdq_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pclmulqdq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpeqb instruction.<br/>
		/// <br/>
		/// <c>PCMPEQB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 74 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPEQB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 74 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpeqb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqb instruction.<br/>
		/// <br/>
		/// <c>PCMPEQB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 74 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPEQB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 74 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpeqb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqd instruction.<br/>
		/// <br/>
		/// <c>PCMPEQD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 76 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPEQD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 76 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpeqd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqd instruction.<br/>
		/// <br/>
		/// <c>PCMPEQD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 76 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPEQD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 76 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpeqd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqq instruction.<br/>
		/// <br/>
		/// <c>PCMPEQQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 29 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqq instruction.<br/>
		/// <br/>
		/// <c>PCMPEQQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 29 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqw instruction.<br/>
		/// <br/>
		/// <c>PCMPEQW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 75 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPEQW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 75 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpeqw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpeqw instruction.<br/>
		/// <br/>
		/// <c>PCMPEQW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 75 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPEQW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 75 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpeqw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpeqw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpeqw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpeqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpestri instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestri(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestri instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestri(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestri64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestri64(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestri64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestri64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestri64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestri64(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestri64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestri64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestrm(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestrm(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestrm64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestrm64(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestrm64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestrm64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpestrm64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpestrm64(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpestrm64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpestrm64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpgtb instruction.<br/>
		/// <br/>
		/// <c>PCMPGTB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 64 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPGTB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 64 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpgtb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtb instruction.<br/>
		/// <br/>
		/// <c>PCMPGTB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 64 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPGTB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 64 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpgtb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtd instruction.<br/>
		/// <br/>
		/// <c>PCMPGTD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 66 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPGTD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 66 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpgtd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtd instruction.<br/>
		/// <br/>
		/// <c>PCMPGTD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 66 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPGTD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 66 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpgtd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtq instruction.<br/>
		/// <br/>
		/// <c>PCMPGTQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 37 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtq instruction.<br/>
		/// <br/>
		/// <c>PCMPGTQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 37 /r</c><br/>
		/// <br/>
		/// <c>SSE4.2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtw instruction.<br/>
		/// <br/>
		/// <c>PCMPGTW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 65 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPGTW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 65 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpgtw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpgtw instruction.<br/>
		/// <br/>
		/// <c>PCMPGTW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 65 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PCMPGTW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 65 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcmpgtw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpgtw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pcmpgtw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpgtw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pcmpistri instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpistri(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpistri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpistri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpistri instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpistri(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpistri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpistri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpistrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpistrm(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpistrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpistrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcmpistrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void pcmpistrm(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pcmpistrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pcmpistrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pcommit instruction.<br/>
		/// <br/>
		/// <c>PCOMMIT</c><br/>
		/// <br/>
		/// <c>66 0F AE F8</c><br/>
		/// <br/>
		/// <c>PCOMMIT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pcommit() {
			Code op;
			op = Code.Pcommit;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pconfig instruction.<br/>
		/// <br/>
		/// <c>PCONFIG</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C5</c><br/>
		/// <br/>
		/// <c>PCONFIG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pconfig() {
			Code op;
			op = Code.Pconfig;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pdep instruction.<br/>
		/// <br/>
		/// <c>PDEP r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W0 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PDEP r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W1 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pdep(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Pdep_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Pdep_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pdep), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>pdep instruction.<br/>
		/// <br/>
		/// <c>PDEP r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W0 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PDEP r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W1 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pdep(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Pdep_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Pdep_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pdep), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>pext instruction.<br/>
		/// <br/>
		/// <c>PEXT r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W0 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PEXT r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W1 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pext(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Pext_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Pext_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pext), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>pext instruction.<br/>
		/// <br/>
		/// <c>PEXT r32a, r32b, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W0 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PEXT r64a, r64b, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W1 F5 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pext(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Pext_r64_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Pext_r32_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pext), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>pextrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Pextrb_r32m8_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrb(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Pextrb_r32m8_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Pextrb_r64m8_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Pextrd_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrd(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Pextrd_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Pextrq_rm64_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrq(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Pextrq_rm64_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64() && src.IsXMM()) {
				op = Code.Pextrw_r64_xmm_imm8;
			} else if (dst.IsGPR64() && src.IsMM()) {
				op = Code.Pextrw_r64_mm_imm8;
			} else if (dst.IsGPR32() && src.IsXMM()) {
				op = Code.Pextrw_r32_xmm_imm8;
			} else if (dst.IsGPR32() && src.IsMM()) {
				op = Code.Pextrw_r32_mm_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Pextrw_r32m16_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pextrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pextrw(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pextrw_r32m16_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pextrw_r64m16_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pextrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pf2id instruction.<br/>
		/// <br/>
		/// <c>PF2ID mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 1D</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pf2id() {
			Code op;
			op = Code.D3NOW_Pf2id_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pf2iw instruction.<br/>
		/// <br/>
		/// <c>PF2IW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 1C</c><br/>
		/// <br/>
		/// <c>3DNOWEXT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pf2iw() {
			Code op;
			op = Code.D3NOW_Pf2iw_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfacc instruction.<br/>
		/// <br/>
		/// <c>PFACC mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r AE</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfacc() {
			Code op;
			op = Code.D3NOW_Pfacc_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfadd instruction.<br/>
		/// <br/>
		/// <c>PFADD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 9E</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfadd() {
			Code op;
			op = Code.D3NOW_Pfadd_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfcmpeq instruction.<br/>
		/// <br/>
		/// <c>PFCMPEQ mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r B0</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfcmpeq() {
			Code op;
			op = Code.D3NOW_Pfcmpeq_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfcmpge instruction.<br/>
		/// <br/>
		/// <c>PFCMPGE mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 90</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfcmpge() {
			Code op;
			op = Code.D3NOW_Pfcmpge_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfcmpgt instruction.<br/>
		/// <br/>
		/// <c>PFCMPGT mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r A0</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfcmpgt() {
			Code op;
			op = Code.D3NOW_Pfcmpgt_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfmax instruction.<br/>
		/// <br/>
		/// <c>PFMAX mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r A4</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfmax() {
			Code op;
			op = Code.D3NOW_Pfmax_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfmin instruction.<br/>
		/// <br/>
		/// <c>PFMIN mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 94</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfmin() {
			Code op;
			op = Code.D3NOW_Pfmin_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfmul instruction.<br/>
		/// <br/>
		/// <c>PFMUL mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r B4</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfmul() {
			Code op;
			op = Code.D3NOW_Pfmul_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfnacc instruction.<br/>
		/// <br/>
		/// <c>PFNACC mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 8A</c><br/>
		/// <br/>
		/// <c>3DNOWEXT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfnacc() {
			Code op;
			op = Code.D3NOW_Pfnacc_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfpnacc instruction.<br/>
		/// <br/>
		/// <c>PFPNACC mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 8E</c><br/>
		/// <br/>
		/// <c>3DNOWEXT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfpnacc() {
			Code op;
			op = Code.D3NOW_Pfpnacc_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrcp instruction.<br/>
		/// <br/>
		/// <c>PFRCP mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 96</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrcp() {
			Code op;
			op = Code.D3NOW_Pfrcp_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrcpit1 instruction.<br/>
		/// <br/>
		/// <c>PFRCPIT1 mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r A6</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrcpit1() {
			Code op;
			op = Code.D3NOW_Pfrcpit1_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrcpit2 instruction.<br/>
		/// <br/>
		/// <c>PFRCPIT2 mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r B6</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrcpit2() {
			Code op;
			op = Code.D3NOW_Pfrcpit2_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrcpv instruction.<br/>
		/// <br/>
		/// <c>PFRCPV mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 86</c><br/>
		/// <br/>
		/// <c>AMD Geode LX/GX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrcpv() {
			Code op;
			op = Code.D3NOW_Pfrcpv_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrsqit1 instruction.<br/>
		/// <br/>
		/// <c>PFRSQIT1 mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r A7</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrsqit1() {
			Code op;
			op = Code.D3NOW_Pfrsqit1_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrsqrt instruction.<br/>
		/// <br/>
		/// <c>PFRSQRT mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 97</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrsqrt() {
			Code op;
			op = Code.D3NOW_Pfrsqrt_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfrsqrtv instruction.<br/>
		/// <br/>
		/// <c>PFRSQRTV mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 87</c><br/>
		/// <br/>
		/// <c>AMD Geode LX/GX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfrsqrtv() {
			Code op;
			op = Code.D3NOW_Pfrsqrtv_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfsub instruction.<br/>
		/// <br/>
		/// <c>PFSUB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 9A</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfsub() {
			Code op;
			op = Code.D3NOW_Pfsub_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pfsubr instruction.<br/>
		/// <br/>
		/// <c>PFSUBR mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r AA</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pfsubr() {
			Code op;
			op = Code.D3NOW_Pfsubr_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>phaddd instruction.<br/>
		/// <br/>
		/// <c>PHADDD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 02 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHADDD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 02 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phaddd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phaddd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phaddd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phaddd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phaddd instruction.<br/>
		/// <br/>
		/// <c>PHADDD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 02 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHADDD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 02 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phaddd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phaddd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phaddd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phaddd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phaddsw instruction.<br/>
		/// <br/>
		/// <c>PHADDSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 03 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHADDSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 03 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phaddsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phaddsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phaddsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phaddsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phaddsw instruction.<br/>
		/// <br/>
		/// <c>PHADDSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 03 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHADDSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 03 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phaddsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phaddsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phaddsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phaddsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phaddw instruction.<br/>
		/// <br/>
		/// <c>PHADDW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 01 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHADDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 01 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phaddw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phaddw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phaddw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phaddw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phaddw instruction.<br/>
		/// <br/>
		/// <c>PHADDW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 01 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHADDW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 01 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phaddw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phaddw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phaddw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phaddw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phminposuw instruction.<br/>
		/// <br/>
		/// <c>PHMINPOSUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 41 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phminposuw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phminposuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(phminposuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phminposuw instruction.<br/>
		/// <br/>
		/// <c>PHMINPOSUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 41 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phminposuw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phminposuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(phminposuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phsubd instruction.<br/>
		/// <br/>
		/// <c>PHSUBD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 06 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHSUBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 06 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phsubd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phsubd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phsubd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phsubd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phsubd instruction.<br/>
		/// <br/>
		/// <c>PHSUBD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 06 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHSUBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 06 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phsubd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phsubd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phsubd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phsubd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phsubsw instruction.<br/>
		/// <br/>
		/// <c>PHSUBSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 07 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHSUBSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 07 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phsubsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phsubsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phsubsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phsubsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phsubsw instruction.<br/>
		/// <br/>
		/// <c>PHSUBSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 07 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHSUBSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 07 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phsubsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phsubsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phsubsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phsubsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phsubw instruction.<br/>
		/// <br/>
		/// <c>PHSUBW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 05 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHSUBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 05 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phsubw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phsubw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phsubw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phsubw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>phsubw instruction.<br/>
		/// <br/>
		/// <c>PHSUBW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 05 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PHSUBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 05 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void phsubw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Phsubw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Phsubw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(phsubw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pi2fd instruction.<br/>
		/// <br/>
		/// <c>PI2FD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 0D</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pi2fd() {
			Code op;
			op = Code.D3NOW_Pi2fd_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pi2fw instruction.<br/>
		/// <br/>
		/// <c>PI2FW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r 0C</c><br/>
		/// <br/>
		/// <c>3DNOWEXT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pi2fw() {
			Code op;
			op = Code.D3NOW_Pi2fw_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pinsrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pinsrb_xmm_r32m8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrb(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Pinsrb_xmm_r32m8_imm8;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Pinsrb_xmm_r64m8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pinsrd_xmm_rm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pinsrd_xmm_rm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pinsrq_xmm_rm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pinsrq_xmm_rm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pinsrw_xmm_r32m16_imm8;
			} else if (dst.IsMM()) {
				op = Code.Pinsrw_mm_r32m16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pinsrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pinsrw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pinsrw_xmm_r32m16_imm8;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pinsrw_xmm_r64m16_imm8;
			} else if (dst.IsMM() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pinsrw_mm_r32m16_imm8;
			} else if (dst.IsMM() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pinsrw_mm_r64m16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pinsrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pmaddubsw instruction.<br/>
		/// <br/>
		/// <c>PMADDUBSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 04 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMADDUBSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 04 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaddubsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaddubsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaddubsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaddubsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaddubsw instruction.<br/>
		/// <br/>
		/// <c>PMADDUBSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 04 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMADDUBSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 04 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaddubsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaddubsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaddubsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaddubsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaddwd instruction.<br/>
		/// <br/>
		/// <c>PMADDWD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F5 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMADDWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F5 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaddwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaddwd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaddwd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaddwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaddwd instruction.<br/>
		/// <br/>
		/// <c>PMADDWD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F5 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMADDWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F5 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaddwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaddwd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaddwd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaddwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxsb instruction.<br/>
		/// <br/>
		/// <c>PMAXSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3C /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxsb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxsb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxsb instruction.<br/>
		/// <br/>
		/// <c>PMAXSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3C /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxsb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxsb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxsd instruction.<br/>
		/// <br/>
		/// <c>PMAXSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3D /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxsd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxsd instruction.<br/>
		/// <br/>
		/// <c>PMAXSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3D /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxsd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxsw instruction.<br/>
		/// <br/>
		/// <c>PMAXSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EE /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMAXSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EE /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaxsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxsw instruction.<br/>
		/// <br/>
		/// <c>PMAXSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EE /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMAXSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EE /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaxsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxub instruction.<br/>
		/// <br/>
		/// <c>PMAXUB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DE /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMAXUB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DE /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxub(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxub_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaxub_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxub instruction.<br/>
		/// <br/>
		/// <c>PMAXUB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DE /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMAXUB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DE /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxub(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxub_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmaxub_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxud instruction.<br/>
		/// <br/>
		/// <c>PMAXUD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3F /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxud(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxud_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxud), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxud instruction.<br/>
		/// <br/>
		/// <c>PMAXUD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3F /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxud(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxud_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxud), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxuw instruction.<br/>
		/// <br/>
		/// <c>PMAXUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3E /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxuw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmaxuw instruction.<br/>
		/// <br/>
		/// <c>PMAXUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3E /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmaxuw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmaxuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmaxuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminsb instruction.<br/>
		/// <br/>
		/// <c>PMINSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 38 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminsb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminsb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminsb instruction.<br/>
		/// <br/>
		/// <c>PMINSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 38 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminsb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminsb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminsd instruction.<br/>
		/// <br/>
		/// <c>PMINSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 39 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminsd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminsd instruction.<br/>
		/// <br/>
		/// <c>PMINSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 39 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminsd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminsw instruction.<br/>
		/// <br/>
		/// <c>PMINSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EA /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMINSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EA /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pminsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pminsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminsw instruction.<br/>
		/// <br/>
		/// <c>PMINSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EA /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMINSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EA /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pminsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pminsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminub instruction.<br/>
		/// <br/>
		/// <c>PMINUB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DA /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMINUB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DA /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminub(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminub_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pminub_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pminub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminub instruction.<br/>
		/// <br/>
		/// <c>PMINUB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F DA /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMINUB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F DA /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminub(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminub_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pminub_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pminub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminud instruction.<br/>
		/// <br/>
		/// <c>PMINUD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3B /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminud(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminud_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminud), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminud instruction.<br/>
		/// <br/>
		/// <c>PMINUD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3B /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminud(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminud_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminud), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminuw instruction.<br/>
		/// <br/>
		/// <c>PMINUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3A /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminuw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pminuw instruction.<br/>
		/// <br/>
		/// <c>PMINUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 3A /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pminuw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pminuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pminuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovmskb instruction.<br/>
		/// <br/>
		/// <c>PMOVMSKB r32, mm</c><br/>
		/// <br/>
		/// <c>NP 0F D7 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMOVMSKB r64, mm</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F D7 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>PMOVMSKB r32, xmm</c><br/>
		/// <br/>
		/// <c>66 0F D7 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMOVMSKB r64, xmm</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F D7 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pmovmskb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsXMM()) {
				op = Code.Pmovmskb_r64_xmm;
			} else if (dst.IsGPR64() && src.IsMM()) {
				op = Code.Pmovmskb_r64_mm;
			} else if (dst.IsGPR32() && src.IsXMM()) {
				op = Code.Pmovmskb_r32_xmm;
			} else if (dst.IsGPR32() && src.IsMM()) {
				op = Code.Pmovmskb_r32_mm;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovmskb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxbd instruction.<br/>
		/// <br/>
		/// <c>PMOVSXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 21 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxbd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxbd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxbd instruction.<br/>
		/// <br/>
		/// <c>PMOVSXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 21 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxbd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxbd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxbq instruction.<br/>
		/// <br/>
		/// <c>PMOVSXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>66 0F 38 22 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxbq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxbq_xmm_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxbq instruction.<br/>
		/// <br/>
		/// <c>PMOVSXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>66 0F 38 22 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxbq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxbq_xmm_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxbw instruction.<br/>
		/// <br/>
		/// <c>PMOVSXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 20 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxbw_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxbw instruction.<br/>
		/// <br/>
		/// <c>PMOVSXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 20 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxbw_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxdq instruction.<br/>
		/// <br/>
		/// <c>PMOVSXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 25 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxdq_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxdq instruction.<br/>
		/// <br/>
		/// <c>PMOVSXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 25 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxdq_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxwd instruction.<br/>
		/// <br/>
		/// <c>PMOVSXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 23 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxwd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxwd instruction.<br/>
		/// <br/>
		/// <c>PMOVSXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 23 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxwd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxwq instruction.<br/>
		/// <br/>
		/// <c>PMOVSXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 24 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxwq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxwq_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovsxwq instruction.<br/>
		/// <br/>
		/// <c>PMOVSXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 24 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovsxwq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovsxwq_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovsxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxbd instruction.<br/>
		/// <br/>
		/// <c>PMOVZXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 31 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxbd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxbd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxbd instruction.<br/>
		/// <br/>
		/// <c>PMOVZXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 31 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxbd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxbd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxbq instruction.<br/>
		/// <br/>
		/// <c>PMOVZXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>66 0F 38 32 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxbq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxbq_xmm_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxbq instruction.<br/>
		/// <br/>
		/// <c>PMOVZXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>66 0F 38 32 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxbq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxbq_xmm_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxbw instruction.<br/>
		/// <br/>
		/// <c>PMOVZXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 30 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxbw_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxbw instruction.<br/>
		/// <br/>
		/// <c>PMOVZXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 30 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxbw_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxdq instruction.<br/>
		/// <br/>
		/// <c>PMOVZXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 35 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxdq_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxdq instruction.<br/>
		/// <br/>
		/// <c>PMOVZXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 35 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxdq_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxwd instruction.<br/>
		/// <br/>
		/// <c>PMOVZXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 33 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxwd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxwd instruction.<br/>
		/// <br/>
		/// <c>PMOVZXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 38 33 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxwd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxwq instruction.<br/>
		/// <br/>
		/// <c>PMOVZXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 34 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxwq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxwq_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmovzxwq instruction.<br/>
		/// <br/>
		/// <c>PMOVZXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>66 0F 38 34 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmovzxwq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmovzxwq_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(pmovzxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmuldq instruction.<br/>
		/// <br/>
		/// <c>PMULDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 28 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmuldq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmuldq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmuldq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmuldq instruction.<br/>
		/// <br/>
		/// <c>PMULDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 28 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmuldq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmuldq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmuldq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulhrsw instruction.<br/>
		/// <br/>
		/// <c>PMULHRSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 0B /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULHRSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 0B /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhrsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulhrsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmulhrsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulhrsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulhrsw instruction.<br/>
		/// <br/>
		/// <c>PMULHRSW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 0B /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULHRSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 0B /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhrsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulhrsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmulhrsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulhrsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulhrw instruction.<br/>
		/// <br/>
		/// <c>PMULHRW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r B7</c><br/>
		/// <br/>
		/// <c>3DNOW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhrw() {
			Code op;
			op = Code.D3NOW_Pmulhrw_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pmulhuw instruction.<br/>
		/// <br/>
		/// <c>PMULHUW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E4 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULHUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhuw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulhuw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmulhuw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulhuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulhuw instruction.<br/>
		/// <br/>
		/// <c>PMULHUW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E4 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULHUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhuw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulhuw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmulhuw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulhuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulhw instruction.<br/>
		/// <br/>
		/// <c>PMULHW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E5 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULHW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E5 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulhw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmulhw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulhw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulhw instruction.<br/>
		/// <br/>
		/// <c>PMULHW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E5 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULHW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E5 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulhw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulhw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmulhw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulhw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulld instruction.<br/>
		/// <br/>
		/// <c>PMULLD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 40 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulld(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulld_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmulld instruction.<br/>
		/// <br/>
		/// <c>PMULLD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 40 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmulld(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmulld_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(pmulld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmullw instruction.<br/>
		/// <br/>
		/// <c>PMULLW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D5 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULLW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D5 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmullw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmullw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmullw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmullw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmullw instruction.<br/>
		/// <br/>
		/// <c>PMULLW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D5 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULLW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D5 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmullw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmullw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmullw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmullw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmuludq instruction.<br/>
		/// <br/>
		/// <c>PMULUDQ mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULUDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmuludq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmuludq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmuludq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmuludq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pmuludq instruction.<br/>
		/// <br/>
		/// <c>PMULUDQ mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PMULUDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F4 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pmuludq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pmuludq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pmuludq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pmuludq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pop instruction.<br/>
		/// <br/>
		/// <c>POP ES</c><br/>
		/// <br/>
		/// <c>o16 07</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POP CS</c><br/>
		/// <br/>
		/// <c>o16 0F</c><br/>
		/// <br/>
		/// <c>8086</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POP SS</c><br/>
		/// <br/>
		/// <c>o16 17</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POP DS</c><br/>
		/// <br/>
		/// <c>o16 1F</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POP r16</c><br/>
		/// <br/>
		/// <c>o16 58+rw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POP r32</c><br/>
		/// <br/>
		/// <c>o32 58+rd</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POP r64</c><br/>
		/// <br/>
		/// <c>58+ro</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>POP FS</c><br/>
		/// <br/>
		/// <c>o16 0F A1</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POP GS</c><br/>
		/// <br/>
		/// <c>o16 0F A9</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Pop_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Pop_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Pop_r16;
			} else if (dst == Register.ES) {
				op = Bitness >= 32 ? Code.Popd_ES : Code.Popw_ES;
			} else if (dst == Register.CS) {
				op = Bitness >= 32 ? Code.Popw_CS : Code.Popw_CS;
			} else if (dst == Register.SS) {
				op = Bitness >= 32 ? Code.Popd_SS : Code.Popw_SS;
			} else if (dst == Register.DS) {
				op = Bitness >= 32 ? Code.Popd_DS : Code.Popw_DS;
			} else if (dst == Register.FS) {
				op = Bitness >= 32 ? Code.Popd_FS : Code.Popw_FS;
			} else if (dst == Register.GS) {
				op = Bitness >= 32 ? Code.Popd_GS : Code.Popw_GS;
			} else {
				throw NoOpCodeFoundFor(nameof(pop), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>pop instruction.<br/>
		/// <br/>
		/// <c>POP r/m16</c><br/>
		/// <br/>
		/// <c>o16 8F /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POP r/m32</c><br/>
		/// <br/>
		/// <c>o32 8F /0</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POP r/m64</c><br/>
		/// <br/>
		/// <c>8F /0</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Pop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Pop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pop_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(pop), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>popa instruction.<br/>
		/// <br/>
		/// <c>POPA</c><br/>
		/// <br/>
		/// <c>o16 61</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POPAD</c><br/>
		/// <br/>
		/// <c>o32 61</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void popa() {
			Code op;
			if (Bitness >= 32) {
				op = Code.Popad;
			} else if (Bitness >= 16) {
				op = Code.Popaw;
			} else {
				throw NoOpCodeFoundFor(nameof(popa));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>popcnt instruction.<br/>
		/// <br/>
		/// <c>POPCNT r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F3 0F B8 /r</c><br/>
		/// <br/>
		/// <c>POPCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POPCNT r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F3 0F B8 /r</c><br/>
		/// <br/>
		/// <c>POPCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POPCNT r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F B8 /r</c><br/>
		/// <br/>
		/// <c>POPCNT</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void popcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(popcnt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>popcnt instruction.<br/>
		/// <br/>
		/// <c>POPCNT r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F3 0F B8 /r</c><br/>
		/// <br/>
		/// <c>POPCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POPCNT r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F3 0F B8 /r</c><br/>
		/// <br/>
		/// <c>POPCNT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POPCNT r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F B8 /r</c><br/>
		/// <br/>
		/// <c>POPCNT</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void popcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(popcnt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>popf instruction.<br/>
		/// <br/>
		/// <c>POPF</c><br/>
		/// <br/>
		/// <c>o16 9D</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POPFD</c><br/>
		/// <br/>
		/// <c>o32 9D</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>POPFQ</c><br/>
		/// <br/>
		/// <c>9D</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void popf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Popfq;
			} else if (Bitness == 32) {
				op = Code.Popfd;
			} else if (Bitness == 16) {
				op = Code.Popfw;
			} else {
				throw NoOpCodeFoundFor(nameof(popf));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>por instruction.<br/>
		/// <br/>
		/// <c>POR mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EB /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POR xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void por(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Por_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Por_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(por), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>por instruction.<br/>
		/// <br/>
		/// <c>POR mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EB /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>POR xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void por(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Por_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Por_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(por), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>prefetch instruction.<br/>
		/// <br/>
		/// <c>PREFETCH m8</c><br/>
		/// <br/>
		/// <c>0F 0D /0</c><br/>
		/// <br/>
		/// <c>PREFETCHW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetch(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetch_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>prefetchnta instruction.<br/>
		/// <br/>
		/// <c>PREFETCHNTA m8</c><br/>
		/// <br/>
		/// <c>0F 18 /0</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetchnta(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetchnta_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>prefetcht0 instruction.<br/>
		/// <br/>
		/// <c>PREFETCHT0 m8</c><br/>
		/// <br/>
		/// <c>0F 18 /1</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetcht0(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetcht0_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>prefetcht1 instruction.<br/>
		/// <br/>
		/// <c>PREFETCHT1 m8</c><br/>
		/// <br/>
		/// <c>0F 18 /2</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetcht1(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetcht1_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>prefetcht2 instruction.<br/>
		/// <br/>
		/// <c>PREFETCHT2 m8</c><br/>
		/// <br/>
		/// <c>0F 18 /3</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetcht2(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetcht2_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>prefetchw instruction.<br/>
		/// <br/>
		/// <c>PREFETCHW m8</c><br/>
		/// <br/>
		/// <c>0F 0D /1</c><br/>
		/// <br/>
		/// <c>PREFETCHW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetchw(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetchw_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>prefetchwt1 instruction.<br/>
		/// <br/>
		/// <c>PREFETCHWT1 m8</c><br/>
		/// <br/>
		/// <c>0F 0D /2</c><br/>
		/// <br/>
		/// <c>PREFETCHWT1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void prefetchwt1(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Prefetchwt1_m8;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>psadbw instruction.<br/>
		/// <br/>
		/// <c>PSADBW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F6 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSADBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psadbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psadbw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psadbw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psadbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psadbw instruction.<br/>
		/// <br/>
		/// <c>PSADBW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F6 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSADBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F6 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psadbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psadbw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psadbw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psadbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pshufb instruction.<br/>
		/// <br/>
		/// <c>PSHUFB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 00 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSHUFB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 00 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pshufb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshufb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pshufb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pshufb instruction.<br/>
		/// <br/>
		/// <c>PSHUFB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 00 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSHUFB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 00 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pshufb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshufb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pshufb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pshufd instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshufd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshufd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshufd instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshufd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshufd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshufhw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshufhw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshufhw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufhw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshufhw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshufhw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshufhw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufhw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshuflw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshuflw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshuflw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshuflw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshuflw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshuflw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pshuflw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshuflw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshufw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshufw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Pshufw_mm_mmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>pshufw instruction.<br/>
		/// <br/>
		/// </summary>
		public void pshufw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsMM()) {
				op = Code.Pshufw_mm_mmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pshufw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>psignb instruction.<br/>
		/// <br/>
		/// <c>PSIGNB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 08 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSIGNB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 08 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psignb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psignb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psignb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psignb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psignb instruction.<br/>
		/// <br/>
		/// <c>PSIGNB mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 08 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSIGNB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 08 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psignb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psignb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psignb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psignb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psignd instruction.<br/>
		/// <br/>
		/// <c>PSIGND mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 0A /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSIGND xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 0A /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psignd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psignd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psignd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psignd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psignd instruction.<br/>
		/// <br/>
		/// <c>PSIGND mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 0A /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSIGND xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 0A /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psignd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psignd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psignd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psignd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psignw instruction.<br/>
		/// <br/>
		/// <c>PSIGNW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 09 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSIGNW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 09 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psignw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psignw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psignw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psignw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psignw instruction.<br/>
		/// <br/>
		/// <c>PSIGNW mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 38 09 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSIGNW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 09 /r</c><br/>
		/// <br/>
		/// <c>SSSE3</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psignw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psignw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psignw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psignw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pslld instruction.<br/>
		/// <br/>
		/// <c>PSLLD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F2 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSLLD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F2 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pslld(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pslld_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pslld_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pslld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pslld instruction.<br/>
		/// <br/>
		/// <c>PSLLD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F2 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSLLD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F2 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pslld(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pslld_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pslld_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pslld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pslld instruction.<br/>
		/// <br/>
		/// </summary>
		public void pslld(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pslld_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Pslld_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pslld), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>pslldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void pslldq(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pslldq_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(pslldq), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psllq instruction.<br/>
		/// <br/>
		/// <c>PSLLQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F3 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSLLQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psllq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psllq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psllq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psllq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psllq instruction.<br/>
		/// <br/>
		/// <c>PSLLQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F3 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSLLQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psllq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psllq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psllq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psllq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psllq instruction.<br/>
		/// <br/>
		/// </summary>
		public void psllq(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psllq_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psllq_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psllq), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psllw instruction.<br/>
		/// <br/>
		/// <c>PSLLW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F1 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSLLW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F1 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psllw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psllw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psllw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psllw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psllw instruction.<br/>
		/// <br/>
		/// <c>PSLLW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F1 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSLLW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F1 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psllw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psllw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psllw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psllw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psllw instruction.<br/>
		/// <br/>
		/// </summary>
		public void psllw(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psllw_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psllw_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psllw), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psrad instruction.<br/>
		/// <br/>
		/// <c>PSRAD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E2 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRAD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E2 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrad(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrad_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrad_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrad), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrad instruction.<br/>
		/// <br/>
		/// <c>PSRAD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E2 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRAD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E2 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrad(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrad_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrad_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrad), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrad instruction.<br/>
		/// <br/>
		/// </summary>
		public void psrad(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrad_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psrad_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psrad), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psraw instruction.<br/>
		/// <br/>
		/// <c>PSRAW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E1 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRAW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E1 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psraw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psraw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psraw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psraw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psraw instruction.<br/>
		/// <br/>
		/// <c>PSRAW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E1 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRAW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E1 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psraw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psraw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psraw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psraw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psraw instruction.<br/>
		/// <br/>
		/// </summary>
		public void psraw(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psraw_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psraw_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psraw), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psrld instruction.<br/>
		/// <br/>
		/// <c>PSRLD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D2 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRLD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D2 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrld(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrld_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrld_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrld instruction.<br/>
		/// <br/>
		/// <c>PSRLD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D2 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRLD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D2 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrld(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrld_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrld_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrld), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrld instruction.<br/>
		/// <br/>
		/// </summary>
		public void psrld(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrld_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psrld_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psrld), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psrldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void psrldq(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrldq_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psrldq), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psrlq instruction.<br/>
		/// <br/>
		/// <c>PSRLQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D3 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRLQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrlq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrlq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrlq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrlq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrlq instruction.<br/>
		/// <br/>
		/// <c>PSRLQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D3 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRLQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D3 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrlq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrlq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrlq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrlq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrlq instruction.<br/>
		/// <br/>
		/// </summary>
		public void psrlq(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrlq_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psrlq_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psrlq), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psrlw instruction.<br/>
		/// <br/>
		/// <c>PSRLW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D1 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRLW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D1 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrlw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrlw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrlw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrlw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrlw instruction.<br/>
		/// <br/>
		/// <c>PSRLW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D1 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSRLW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D1 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psrlw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrlw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psrlw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psrlw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psrlw instruction.<br/>
		/// <br/>
		/// </summary>
		public void psrlw(Register dst, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psrlw_xmm_imm8;
			} else if (dst.IsMM()) {
				op = Code.Psrlw_mm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(psrlw), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>psubb instruction.<br/>
		/// <br/>
		/// <c>PSUBB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F8 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F8 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubb instruction.<br/>
		/// <br/>
		/// <c>PSUBB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F8 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F8 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubd instruction.<br/>
		/// <br/>
		/// <c>PSUBD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FA /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FA /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubd instruction.<br/>
		/// <br/>
		/// <c>PSUBD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FA /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FA /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubq instruction.<br/>
		/// <br/>
		/// <c>PSUBQ mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubq instruction.<br/>
		/// <br/>
		/// <c>PSUBQ mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>NP 0F FB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F FB /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubsb instruction.<br/>
		/// <br/>
		/// <c>PSUBSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E8 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E8 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubsb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubsb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubsb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubsb instruction.<br/>
		/// <br/>
		/// <c>PSUBSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E8 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E8 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubsb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubsb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubsb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubsw instruction.<br/>
		/// <br/>
		/// <c>PSUBSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E9 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E9 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubsw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubsw instruction.<br/>
		/// <br/>
		/// <c>PSUBSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F E9 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F E9 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubsw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubsw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubusb instruction.<br/>
		/// <br/>
		/// <c>PSUBUSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D8 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBUSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D8 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubusb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubusb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubusb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubusb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubusb instruction.<br/>
		/// <br/>
		/// <c>PSUBUSB mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D8 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBUSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D8 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubusb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubusb_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubusb_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubusb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubusw instruction.<br/>
		/// <br/>
		/// <c>PSUBUSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D9 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBUSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D9 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubusw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubusw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubusw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubusw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubusw instruction.<br/>
		/// <br/>
		/// <c>PSUBUSW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F D9 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBUSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F D9 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubusw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubusw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubusw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubusw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubw instruction.<br/>
		/// <br/>
		/// <c>PSUBW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F9 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F9 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>psubw instruction.<br/>
		/// <br/>
		/// <c>PSUBW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F F9 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PSUBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F F9 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void psubw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Psubw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Psubw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(psubw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pswapd instruction.<br/>
		/// <br/>
		/// <c>PSWAPD mm1, mm2/m64</c><br/>
		/// <br/>
		/// <c>0F 0F /r BB</c><br/>
		/// <br/>
		/// <c>3DNOWEXT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pswapd() {
			Code op;
			op = Code.D3NOW_Pswapd_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>ptest instruction.<br/>
		/// <br/>
		/// <c>PTEST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 17 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ptest(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Ptest_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(ptest), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ptest instruction.<br/>
		/// <br/>
		/// <c>PTEST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 38 17 /r</c><br/>
		/// <br/>
		/// <c>SSE4.1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ptest(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Ptest_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(ptest), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ptwrite instruction.<br/>
		/// <br/>
		/// <c>PTWRITE r/m32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /4</c><br/>
		/// <br/>
		/// <c>PTWRITE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PTWRITE r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /4</c><br/>
		/// <br/>
		/// <c>PTWRITE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ptwrite(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ptwrite_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ptwrite_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(ptwrite), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>ptwrite instruction.<br/>
		/// <br/>
		/// <c>PTWRITE r/m32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /4</c><br/>
		/// <br/>
		/// <c>PTWRITE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PTWRITE r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /4</c><br/>
		/// <br/>
		/// <c>PTWRITE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ptwrite(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ptwrite_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ptwrite_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(ptwrite), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>punpckhbw instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHBW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 68 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKHBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 68 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhbw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckhbw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhbw instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHBW mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 68 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKHBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 68 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhbw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckhbw_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhdq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHDQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 6A /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKHDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhdq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckhdq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhdq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHDQ mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 6A /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKHDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6A /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhdq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckhdq_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhqdq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHQDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhqdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhqdq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhqdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhqdq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHQDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6D /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhqdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhqdq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhqdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhwd instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHWD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 69 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKHWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 69 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhwd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckhwd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckhwd instruction.<br/>
		/// <br/>
		/// <c>PUNPCKHWD mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 69 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKHWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 69 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckhwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckhwd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckhwd_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckhwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpcklbw instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLBW mm, mm/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 60 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKLBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 60 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpcklbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpcklbw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpcklbw_mm_mmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(punpcklbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpcklbw instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLBW mm, mm/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 60 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKLBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 60 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpcklbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpcklbw_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpcklbw_mm_mmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(punpcklbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckldq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLDQ mm, mm/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 62 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKLDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 62 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckldq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckldq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckldq_mm_mmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckldq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpckldq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLDQ mm, mm/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 62 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKLDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 62 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpckldq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpckldq_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpckldq_mm_mmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(punpckldq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpcklqdq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLQDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpcklqdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpcklqdq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(punpcklqdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpcklqdq instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLQDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 6C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpcklqdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpcklqdq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(punpcklqdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpcklwd instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLWD mm, mm/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 61 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKLWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 61 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpcklwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpcklwd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpcklwd_mm_mmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(punpcklwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>punpcklwd instruction.<br/>
		/// <br/>
		/// <c>PUNPCKLWD mm, mm/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 61 /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUNPCKLWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 61 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void punpcklwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Punpcklwd_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Punpcklwd_mm_mmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(punpcklwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>push instruction.<br/>
		/// <br/>
		/// <c>PUSH ES</c><br/>
		/// <br/>
		/// <c>o16 06</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH CS</c><br/>
		/// <br/>
		/// <c>o16 0E</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH SS</c><br/>
		/// <br/>
		/// <c>o16 16</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH DS</c><br/>
		/// <br/>
		/// <c>o16 1E</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH r16</c><br/>
		/// <br/>
		/// <c>o16 50+rw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUSH r32</c><br/>
		/// <br/>
		/// <c>o32 50+rd</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH r64</c><br/>
		/// <br/>
		/// <c>50+ro</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>PUSH FS</c><br/>
		/// <br/>
		/// <c>o16 0F A0</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUSH GS</c><br/>
		/// <br/>
		/// <c>o16 0F A8</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void push(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Push_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Push_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Push_r16;
			} else if (dst == Register.ES) {
				op = Bitness >= 32 ? Code.Pushd_ES : Code.Pushw_ES;
			} else if (dst == Register.CS) {
				op = Bitness >= 32 ? Code.Pushd_CS : Code.Pushw_CS;
			} else if (dst == Register.SS) {
				op = Bitness >= 32 ? Code.Pushd_SS : Code.Pushw_SS;
			} else if (dst == Register.DS) {
				op = Bitness >= 32 ? Code.Pushd_DS : Code.Pushw_DS;
			} else if (dst == Register.FS) {
				op = Bitness >= 32 ? Code.Pushd_FS : Code.Pushw_FS;
			} else if (dst == Register.GS) {
				op = Bitness >= 32 ? Code.Pushd_GS : Code.Pushw_GS;
			} else {
				throw NoOpCodeFoundFor(nameof(push), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>push instruction.<br/>
		/// <br/>
		/// <c>PUSH r/m16</c><br/>
		/// <br/>
		/// <c>o16 FF /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUSH r/m32</c><br/>
		/// <br/>
		/// <c>o32 FF /6</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH r/m64</c><br/>
		/// <br/>
		/// <c>FF /6</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void push(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Push_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Push_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Push_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(push), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>push instruction.<br/>
		/// <br/>
		/// <c>PUSH imm16</c><br/>
		/// <br/>
		/// <c>o16 68 iw</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUSH imm32</c><br/>
		/// <br/>
		/// <c>o32 68 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSH imm32</c><br/>
		/// <br/>
		/// <c>68 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void push(int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (Bitness == 64) {
					op = Code.Pushq_imm8;
				} else if (Bitness == 32) {
					op = Code.Pushd_imm8;
				} else if (Bitness == 16) {
					op = Code.Pushw_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(push), imm);
				}
			}
			else if (Bitness == 64) {
				op = Code.Pushq_imm32;
			} else if (Bitness == 32) {
				op = Code.Pushd_imm32;
			} else if (Bitness == 16) {
				op = Code.Push_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(push), imm);
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>pusha instruction.<br/>
		/// <br/>
		/// <c>PUSHA</c><br/>
		/// <br/>
		/// <c>o16 60</c><br/>
		/// <br/>
		/// <c>186+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSHAD</c><br/>
		/// <br/>
		/// <c>o32 60</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void pusha() {
			Code op;
			if (Bitness >= 32) {
				op = Code.Pushad;
			} else if (Bitness >= 16) {
				op = Code.Pushaw;
			} else {
				throw NoOpCodeFoundFor(nameof(pusha));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pushf instruction.<br/>
		/// <br/>
		/// <c>PUSHF</c><br/>
		/// <br/>
		/// <c>o16 9C</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PUSHFD</c><br/>
		/// <br/>
		/// <c>o32 9C</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>PUSHFQ</c><br/>
		/// <br/>
		/// <c>9C</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void pushf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Pushfq;
			} else if (Bitness == 32) {
				op = Code.Pushfd;
			} else if (Bitness == 16) {
				op = Code.Pushfw;
			} else {
				throw NoOpCodeFoundFor(nameof(pushf));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>pxor instruction.<br/>
		/// <br/>
		/// <c>PXOR mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EF /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PXOR xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EF /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pxor(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pxor_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pxor_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pxor), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>pxor instruction.<br/>
		/// <br/>
		/// <c>PXOR mm, mm/m64</c><br/>
		/// <br/>
		/// <c>NP 0F EF /r</c><br/>
		/// <br/>
		/// <c>MMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>PXOR xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F EF /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void pxor(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Pxor_xmm_xmmm128;
			} else if (dst.IsMM()) {
				op = Code.Pxor_mm_mmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(pxor), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcl instruction.<br/>
		/// <br/>
		/// <c>RCL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /2</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /2</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rcl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rcl_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rcl_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rcl_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rcl_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(rcl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcl instruction.<br/>
		/// <br/>
		/// <c>RCL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /2</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /2</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /2</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rcl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcl_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcl_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcl_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcl_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(rcl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcl instruction.<br/>
		/// <br/>
		/// </summary>
		public void rcl(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rcl_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rcl_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rcl_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rcl_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(rcl), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rcl_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rcl_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rcl_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rcl_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rcl), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>rcl instruction.<br/>
		/// <br/>
		/// </summary>
		public void rcl(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rcl_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rcl_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rcl_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rcl_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(rcl), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcl_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcl_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcl_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcl_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rcl), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>rcpps instruction.<br/>
		/// <br/>
		/// <c>RCPPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 53 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rcpps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rcpps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(rcpps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcpps instruction.<br/>
		/// <br/>
		/// <c>RCPPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 53 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rcpps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rcpps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(rcpps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcpss instruction.<br/>
		/// <br/>
		/// <c>RCPSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 53 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rcpss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rcpss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(rcpss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcpss instruction.<br/>
		/// <br/>
		/// <c>RCPSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 53 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rcpss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rcpss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(rcpss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcr instruction.<br/>
		/// <br/>
		/// <c>RCR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /3</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /3</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rcr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rcr_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rcr_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rcr_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rcr_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(rcr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcr instruction.<br/>
		/// <br/>
		/// <c>RCR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /3</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RCR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /3</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rcr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcr_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcr_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcr_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcr_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(rcr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rcr instruction.<br/>
		/// <br/>
		/// </summary>
		public void rcr(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rcr_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rcr_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rcr_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rcr_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(rcr), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rcr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rcr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rcr_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rcr_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rcr), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>rcr instruction.<br/>
		/// <br/>
		/// </summary>
		public void rcr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rcr_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rcr_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rcr_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rcr_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(rcr), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcr_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcr_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rcr), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>rdfsbase instruction.<br/>
		/// <br/>
		/// <c>RDFSBASE r32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /0</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>RDFSBASE r64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /0</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rdfsbase(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rdfsbase_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Rdfsbase_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(rdfsbase), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdgsbase instruction.<br/>
		/// <br/>
		/// <c>RDGSBASE r32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /1</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>RDGSBASE r64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /1</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rdgsbase(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rdgsbase_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Rdgsbase_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(rdgsbase), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdmsr instruction.<br/>
		/// <br/>
		/// <c>RDMSR</c><br/>
		/// <br/>
		/// <c>0F 32</c><br/>
		/// <br/>
		/// <c>MSR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdmsr() {
			Code op;
			op = Code.Rdmsr;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>rdpid instruction.<br/>
		/// <br/>
		/// <c>RDPID r32</c><br/>
		/// <br/>
		/// <c>F3 0F C7 /7</c><br/>
		/// <br/>
		/// <c>RDPID</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>RDPID r64</c><br/>
		/// <br/>
		/// <c>F3 0F C7 /7</c><br/>
		/// <br/>
		/// <c>RDPID</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rdpid(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rdpid_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Rdpid_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(rdpid), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdpkru instruction.<br/>
		/// <br/>
		/// <c>RDPKRU</c><br/>
		/// <br/>
		/// <c>NP 0F 01 EE</c><br/>
		/// <br/>
		/// <c>PKU</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdpkru() {
			Code op;
			op = Code.Rdpkru;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>rdpmc instruction.<br/>
		/// <br/>
		/// <c>RDPMC</c><br/>
		/// <br/>
		/// <c>0F 33</c><br/>
		/// <br/>
		/// <c>Pentium MMX or later, or Pentium Pro or later</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdpmc() {
			Code op;
			op = Code.Rdpmc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>rdpru instruction.<br/>
		/// <br/>
		/// <c>RDPRU</c><br/>
		/// <br/>
		/// <c>0F 01 FD</c><br/>
		/// <br/>
		/// <c>RDPRU</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdpru() {
			Code op;
			op = Code.Rdpru;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>rdrand instruction.<br/>
		/// <br/>
		/// <c>RDRAND r32</c><br/>
		/// <br/>
		/// <c>o32 0F C7 /6</c><br/>
		/// <br/>
		/// <c>RDRAND</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RDRAND r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F C7 /6</c><br/>
		/// <br/>
		/// <c>RDRAND</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rdrand(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rdrand_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Rdrand_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(rdrand), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdseed instruction.<br/>
		/// <br/>
		/// <c>RDSEED r32</c><br/>
		/// <br/>
		/// <c>o32 0F C7 /7</c><br/>
		/// <br/>
		/// <c>RDSEED</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RDSEED r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F C7 /7</c><br/>
		/// <br/>
		/// <c>RDSEED</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rdseed(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rdseed_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Rdseed_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(rdseed), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdsspd instruction.<br/>
		/// <br/>
		/// <c>RDSSPD r32</c><br/>
		/// <br/>
		/// <c>F3 0F 1E /1</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdsspd(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Rdsspd_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(rdsspd), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdsspq instruction.<br/>
		/// <br/>
		/// <c>RDSSPQ r64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F 1E /1</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rdsspq(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rdsspq_r64;
			} else {
				throw NoOpCodeFoundFor(nameof(rdsspq), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>rdtsc instruction.<br/>
		/// <br/>
		/// <c>RDTSC</c><br/>
		/// <br/>
		/// <c>0F 31</c><br/>
		/// <br/>
		/// <c>TSC</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdtsc() {
			Code op;
			op = Code.Rdtsc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>rdtscp instruction.<br/>
		/// <br/>
		/// <c>RDTSCP</c><br/>
		/// <br/>
		/// <c>0F 01 F9</c><br/>
		/// <br/>
		/// <c>RDTSCP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rdtscp() {
			Code op;
			op = Code.Rdtscp;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>ret instruction.<br/>
		/// <br/>
		/// <c>RET</c><br/>
		/// <br/>
		/// <c>o16 C3</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RET</c><br/>
		/// <br/>
		/// <c>o32 C3</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>RET</c><br/>
		/// <br/>
		/// <c>C3</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Retnq;
			} else if (Bitness == 32) {
				op = Code.Retnd;
			} else if (Bitness == 16) {
				op = Code.Retnw;
			} else {
				throw NoOpCodeFoundFor(nameof(ret));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>ret instruction.<br/>
		/// <br/>
		/// <c>RET imm16</c><br/>
		/// <br/>
		/// <c>o16 C2 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RET imm16</c><br/>
		/// <br/>
		/// <c>o32 C2 iw</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>RET imm16</c><br/>
		/// <br/>
		/// <c>C2 iw</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ret(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Retnq_imm16;
			} else if (Bitness == 32) {
				op = Code.Retnd_imm16;
			} else if (Bitness == 16) {
				op = Code.Retnw_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ret), imm);
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>retf instruction.<br/>
		/// <br/>
		/// <c>RET</c><br/>
		/// <br/>
		/// <c>o16 CB</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RET</c><br/>
		/// <br/>
		/// <c>o32 CB</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RET</c><br/>
		/// <br/>
		/// <c>REX.W CB</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void retf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Retfq;
			} else if (Bitness == 32) {
				op = Code.Retfd;
			} else if (Bitness == 16) {
				op = Code.Retfw;
			} else {
				throw NoOpCodeFoundFor(nameof(retf));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>retf instruction.<br/>
		/// <br/>
		/// <c>RET imm16</c><br/>
		/// <br/>
		/// <c>o16 CA iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RET imm16</c><br/>
		/// <br/>
		/// <c>o32 CA iw</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>RET imm16</c><br/>
		/// <br/>
		/// <c>REX.W CA iw</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void retf(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Retfq_imm16;
			} else if (Bitness == 32) {
				op = Code.Retfd_imm16;
			} else if (Bitness == 16) {
				op = Code.Retfw_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(retf), imm);
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>rol instruction.<br/>
		/// <br/>
		/// <c>ROL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /0</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /0</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rol(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rol_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rol_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rol_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rol_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(rol), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rol instruction.<br/>
		/// <br/>
		/// <c>ROL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /0</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /0</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /0</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void rol(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rol_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rol_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rol_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rol_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(rol), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rol instruction.<br/>
		/// <br/>
		/// </summary>
		public void rol(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rol_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rol_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rol_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rol_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(rol), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rol_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rol_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rol_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rol_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rol), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>rol instruction.<br/>
		/// <br/>
		/// </summary>
		public void rol(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rol_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rol_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rol_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rol_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(rol), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rol_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rol_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rol_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rol_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rol), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>ror instruction.<br/>
		/// <br/>
		/// <c>ROR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /1</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /1</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ror(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ror_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Ror_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Ror_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Ror_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(ror), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ror instruction.<br/>
		/// <br/>
		/// <c>ROR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /1</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /1</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>ROR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /1</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ror(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ror_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ror_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ror_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Ror_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(ror), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ror instruction.<br/>
		/// <br/>
		/// </summary>
		public void ror(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Ror_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Ror_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Ror_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Ror_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(ror), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Ror_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Ror_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Ror_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Ror_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(ror), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>ror instruction.<br/>
		/// <br/>
		/// </summary>
		public void ror(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Ror_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Ror_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Ror_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Ror_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(ror), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ror_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ror_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ror_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Ror_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(ror), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>rorx instruction.<br/>
		/// <br/>
		/// </summary>
		public void rorx(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Rorx_r64_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Rorx_r32_rm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rorx), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>rorx instruction.<br/>
		/// <br/>
		/// </summary>
		public void rorx(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Rorx_r64_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Rorx_r32_rm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(rorx), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundps instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundps instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundsd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundsd_xmm_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundsd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundsd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundsd_xmm_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundsd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundss instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundss(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundss_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundss), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>roundss instruction.<br/>
		/// <br/>
		/// </summary>
		public void roundss(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Roundss_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(roundss), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>rsm instruction.<br/>
		/// <br/>
		/// <c>RSM</c><br/>
		/// <br/>
		/// <c>0F AA</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rsm() {
			Code op;
			op = Code.Rsm;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>rsqrtps instruction.<br/>
		/// <br/>
		/// <c>RSQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 52 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rsqrtps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rsqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(rsqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rsqrtps instruction.<br/>
		/// <br/>
		/// <c>RSQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 52 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rsqrtps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rsqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(rsqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rsqrtss instruction.<br/>
		/// <br/>
		/// <c>RSQRTSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 52 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rsqrtss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rsqrtss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(rsqrtss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rsqrtss instruction.<br/>
		/// <br/>
		/// <c>RSQRTSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 52 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rsqrtss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Rsqrtss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(rsqrtss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>rstorssp instruction.<br/>
		/// <br/>
		/// <c>RSTORSSP m64</c><br/>
		/// <br/>
		/// <c>F3 0F 01 /5</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void rstorssp(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Rstorssp_m64;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sahf instruction.<br/>
		/// <br/>
		/// <c>SAHF</c><br/>
		/// <br/>
		/// <c>9E</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sahf() {
			Code op;
			op = Code.Sahf;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sal instruction.<br/>
		/// <br/>
		/// <c>SAL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /6</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /6</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sal(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sal_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Sal_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Sal_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Sal_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(sal), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sal instruction.<br/>
		/// <br/>
		/// <c>SAL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /6</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /6</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sal(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sal_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sal_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sal_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sal_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(sal), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sal instruction.<br/>
		/// <br/>
		/// </summary>
		public void sal(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Sal_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Sal_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Sal_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Sal_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(sal), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Sal_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Sal_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Sal_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Sal_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sal), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>sal instruction.<br/>
		/// <br/>
		/// </summary>
		public void sal(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sal_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sal_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sal_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sal_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(sal), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sal_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sal_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sal_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sal_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sal), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>salc instruction.<br/>
		/// <br/>
		/// <c>SALC</c><br/>
		/// <br/>
		/// <c>D6</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void salc() {
			Code op;
			op = Code.Salc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sar instruction.<br/>
		/// <br/>
		/// <c>SAR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /7</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /7</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sar(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sar_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Sar_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Sar_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Sar_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(sar), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sar instruction.<br/>
		/// <br/>
		/// <c>SAR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /7</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /7</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SAR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /7</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sar(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sar_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sar_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sar_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sar_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(sar), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sar instruction.<br/>
		/// <br/>
		/// </summary>
		public void sar(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Sar_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Sar_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Sar_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Sar_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(sar), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Sar_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Sar_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Sar_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Sar_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sar), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>sar instruction.<br/>
		/// <br/>
		/// </summary>
		public void sar(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sar_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sar_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sar_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sar_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(sar), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sar_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sar_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sar_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sar_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sar), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>sarx instruction.<br/>
		/// <br/>
		/// <c>SARX r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SARX r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sarx(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Sarx_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Sarx_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(sarx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>sarx instruction.<br/>
		/// <br/>
		/// <c>SARX r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SARX r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F3.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sarx(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Sarx_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Sarx_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(sarx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>saveprevssp instruction.<br/>
		/// <br/>
		/// <c>SAVEPREVSSP</c><br/>
		/// <br/>
		/// <c>F3 0F 01 EA</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void saveprevssp() {
			Code op;
			op = Code.Saveprevssp;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sbb instruction.<br/>
		/// <br/>
		/// <c>SBB r/m8, r8</c><br/>
		/// <br/>
		/// <c>18 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 19 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 19 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 19 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sbb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(sbb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sbb instruction.<br/>
		/// <br/>
		/// <c>SBB r/m8, r8</c><br/>
		/// <br/>
		/// <c>18 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 19 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 19 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 19 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sbb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sbb_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sbb_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sbb_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(sbb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sbb instruction.<br/>
		/// <br/>
		/// <c>SBB r8, r/m8</c><br/>
		/// <br/>
		/// <c>1A /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 1B /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 1B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 1B /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sbb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sbb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sbb instruction.<br/>
		/// <br/>
		/// <c>SBB AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 1D iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 1D id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 1D id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>SBB r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /3 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /3 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /3 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sbb(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Sbb_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Sbb_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Sbb_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Sbb_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Sbb_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(sbb), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Sbb_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Sbb_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Sbb_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Sbb_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(sbb), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>sbb instruction.<br/>
		/// <br/>
		/// <c>SBB r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /3 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /3 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SBB r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /3 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sbb(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sbb_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sbb_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sbb_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sbb_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(sbb), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sbb_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sbb_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sbb_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(sbb), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>scasb instruction.<br/>
		/// <br/>
		/// <c>SCASB</c><br/>
		/// <br/>
		/// <c>AE</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void scasb(Register dst) {
			Code op;
			if (dst == Register.AL) {
				op = Code.Scasb_AL_m8;
			} else {
				throw NoOpCodeFoundFor(nameof(scasb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>scasd instruction.<br/>
		/// <br/>
		/// <c>SCASD</c><br/>
		/// <br/>
		/// <c>o32 AF</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void scasd(Register dst) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.Scasd_EAX_m32;
			} else {
				throw NoOpCodeFoundFor(nameof(scasd), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>scasq instruction.<br/>
		/// <br/>
		/// <c>SCASQ</c><br/>
		/// <br/>
		/// <c>REX.W AF</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void scasq(Register dst) {
			Code op;
			if (dst == Register.RAX) {
				op = Code.Scasq_RAX_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(scasq), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>scasw instruction.<br/>
		/// <br/>
		/// <c>SCASW</c><br/>
		/// <br/>
		/// <c>o16 AF</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void scasw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Scasw_AX_m16;
			} else {
				throw NoOpCodeFoundFor(nameof(scasw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>seta instruction.<br/>
		/// <br/>
		/// <c>SETA r/m8</c><br/>
		/// <br/>
		/// <c>0F 97 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void seta(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Seta_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(seta), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>seta instruction.<br/>
		/// <br/>
		/// <c>SETA r/m8</c><br/>
		/// <br/>
		/// <c>0F 97 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void seta(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Seta_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(seta), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setae instruction.<br/>
		/// <br/>
		/// <c>SETAE r/m8</c><br/>
		/// <br/>
		/// <c>0F 93 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setae(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setae_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setae), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setae instruction.<br/>
		/// <br/>
		/// <c>SETAE r/m8</c><br/>
		/// <br/>
		/// <c>0F 93 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setae(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setae_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setae), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setb instruction.<br/>
		/// <br/>
		/// <c>SETB r/m8</c><br/>
		/// <br/>
		/// <c>0F 92 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setb(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setb_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setb instruction.<br/>
		/// <br/>
		/// <c>SETB r/m8</c><br/>
		/// <br/>
		/// <c>0F 92 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setb(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setb_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setbe instruction.<br/>
		/// <br/>
		/// <c>SETBE r/m8</c><br/>
		/// <br/>
		/// <c>0F 96 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setbe(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setbe_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setbe), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setbe instruction.<br/>
		/// <br/>
		/// <c>SETBE r/m8</c><br/>
		/// <br/>
		/// <c>0F 96 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setbe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setbe_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setbe), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sete instruction.<br/>
		/// <br/>
		/// <c>SETE r/m8</c><br/>
		/// <br/>
		/// <c>0F 94 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sete(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Sete_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sete), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sete instruction.<br/>
		/// <br/>
		/// <c>SETE r/m8</c><br/>
		/// <br/>
		/// <c>0F 94 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sete(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sete_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sete), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setg instruction.<br/>
		/// <br/>
		/// <c>SETG r/m8</c><br/>
		/// <br/>
		/// <c>0F 9F /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setg(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setg_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setg instruction.<br/>
		/// <br/>
		/// <c>SETG r/m8</c><br/>
		/// <br/>
		/// <c>0F 9F /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setg_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setg), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setge instruction.<br/>
		/// <br/>
		/// <c>SETGE r/m8</c><br/>
		/// <br/>
		/// <c>0F 9D /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setge(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setge_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setge), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setge instruction.<br/>
		/// <br/>
		/// <c>SETGE r/m8</c><br/>
		/// <br/>
		/// <c>0F 9D /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setge(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setge_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setge), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setl instruction.<br/>
		/// <br/>
		/// <c>SETL r/m8</c><br/>
		/// <br/>
		/// <c>0F 9C /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setl(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setl_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setl), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setl instruction.<br/>
		/// <br/>
		/// <c>SETL r/m8</c><br/>
		/// <br/>
		/// <c>0F 9C /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setl(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setl_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setl), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setle instruction.<br/>
		/// <br/>
		/// <c>SETLE r/m8</c><br/>
		/// <br/>
		/// <c>0F 9E /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setle(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setle_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setle), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setle instruction.<br/>
		/// <br/>
		/// <c>SETLE r/m8</c><br/>
		/// <br/>
		/// <c>0F 9E /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setle(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setle_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setle), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setne instruction.<br/>
		/// <br/>
		/// <c>SETNE r/m8</c><br/>
		/// <br/>
		/// <c>0F 95 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setne(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setne_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setne), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setne instruction.<br/>
		/// <br/>
		/// <c>SETNE r/m8</c><br/>
		/// <br/>
		/// <c>0F 95 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setne(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setne_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setne), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setno instruction.<br/>
		/// <br/>
		/// <c>SETNO r/m8</c><br/>
		/// <br/>
		/// <c>0F 91 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setno(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setno_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setno), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setno instruction.<br/>
		/// <br/>
		/// <c>SETNO r/m8</c><br/>
		/// <br/>
		/// <c>0F 91 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setno(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setno_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setno), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setnp instruction.<br/>
		/// <br/>
		/// <c>SETNP r/m8</c><br/>
		/// <br/>
		/// <c>0F 9B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setnp(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setnp_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setnp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setnp instruction.<br/>
		/// <br/>
		/// <c>SETNP r/m8</c><br/>
		/// <br/>
		/// <c>0F 9B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setnp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setnp_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setnp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setns instruction.<br/>
		/// <br/>
		/// <c>SETNS r/m8</c><br/>
		/// <br/>
		/// <c>0F 99 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setns(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setns_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setns), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setns instruction.<br/>
		/// <br/>
		/// <c>SETNS r/m8</c><br/>
		/// <br/>
		/// <c>0F 99 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setns(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setns_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setns), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>seto instruction.<br/>
		/// <br/>
		/// <c>SETO r/m8</c><br/>
		/// <br/>
		/// <c>0F 90 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void seto(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Seto_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(seto), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>seto instruction.<br/>
		/// <br/>
		/// <c>SETO r/m8</c><br/>
		/// <br/>
		/// <c>0F 90 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void seto(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Seto_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(seto), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setp instruction.<br/>
		/// <br/>
		/// <c>SETP r/m8</c><br/>
		/// <br/>
		/// <c>0F 9A /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setp(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setp_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setp instruction.<br/>
		/// <br/>
		/// <c>SETP r/m8</c><br/>
		/// <br/>
		/// <c>0F 9A /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setp_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(setp), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sets instruction.<br/>
		/// <br/>
		/// <c>SETS r/m8</c><br/>
		/// <br/>
		/// <c>0F 98 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sets(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Sets_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sets), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sets instruction.<br/>
		/// <br/>
		/// <c>SETS r/m8</c><br/>
		/// <br/>
		/// <c>0F 98 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sets(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sets_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sets), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>setssbsy instruction.<br/>
		/// <br/>
		/// <c>SETSSBSY</c><br/>
		/// <br/>
		/// <c>F3 0F 01 E8</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void setssbsy() {
			Code op;
			op = Code.Setssbsy;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sfence instruction.<br/>
		/// <br/>
		/// <c>SFENCE</c><br/>
		/// <br/>
		/// <c>NP 0F AE F8</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sfence() {
			Code op;
			op = Code.Sfence;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sha1msg1 instruction.<br/>
		/// <br/>
		/// <c>SHA1MSG1 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 C9 /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha1msg1(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1msg1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1msg1), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha1msg1 instruction.<br/>
		/// <br/>
		/// <c>SHA1MSG1 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 C9 /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha1msg1(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1msg1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1msg1), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha1msg2 instruction.<br/>
		/// <br/>
		/// <c>SHA1MSG2 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CA /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha1msg2(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1msg2_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1msg2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha1msg2 instruction.<br/>
		/// <br/>
		/// <c>SHA1MSG2 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CA /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha1msg2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1msg2_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1msg2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha1nexte instruction.<br/>
		/// <br/>
		/// <c>SHA1NEXTE xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 C8 /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha1nexte(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1nexte_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1nexte), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha1nexte instruction.<br/>
		/// <br/>
		/// <c>SHA1NEXTE xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 C8 /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha1nexte(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1nexte_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1nexte), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha1rnds4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void sha1rnds4(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1rnds4_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1rnds4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>sha1rnds4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void sha1rnds4(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha1rnds4_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sha1rnds4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>sha256msg1 instruction.<br/>
		/// <br/>
		/// <c>SHA256MSG1 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CC /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha256msg1(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha256msg1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha256msg1), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha256msg1 instruction.<br/>
		/// <br/>
		/// <c>SHA256MSG1 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CC /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha256msg1(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha256msg1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha256msg1), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha256msg2 instruction.<br/>
		/// <br/>
		/// <c>SHA256MSG2 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CD /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha256msg2(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha256msg2_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha256msg2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha256msg2 instruction.<br/>
		/// <br/>
		/// <c>SHA256MSG2 xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CD /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha256msg2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha256msg2_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha256msg2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha256rnds2 instruction.<br/>
		/// <br/>
		/// <c>SHA256RNDS2 xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CB /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha256rnds2(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha256rnds2_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha256rnds2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sha256rnds2 instruction.<br/>
		/// <br/>
		/// <c>SHA256RNDS2 xmm1, xmm2/m128, &lt;XMM0&gt;</c><br/>
		/// <br/>
		/// <c>NP 0F 38 CB /r</c><br/>
		/// <br/>
		/// <c>SHA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sha256rnds2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sha256rnds2_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sha256rnds2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>shl instruction.<br/>
		/// <br/>
		/// <c>SHL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /4</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /4</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shl_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shl_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shl_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Shl_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>shl instruction.<br/>
		/// <br/>
		/// <c>SHL r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHL r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /4</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHL r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /4</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHL r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /4</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shl_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shl_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shl_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shl_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shl), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>shl instruction.<br/>
		/// <br/>
		/// </summary>
		public void shl(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Shl_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Shl_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Shl_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Shl_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(shl), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Shl_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shl_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shl_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Shl_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shl), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>shl instruction.<br/>
		/// <br/>
		/// </summary>
		public void shl(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Shl_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Shl_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Shl_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Shl_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(shl), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shl_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shl_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shl_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shl_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shl), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>shld instruction.<br/>
		/// <br/>
		/// <c>SHLD r/m16, r16, CL</c><br/>
		/// <br/>
		/// <c>o16 0F A5 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHLD r/m32, r32, CL</c><br/>
		/// <br/>
		/// <c>o32 0F A5 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHLD r/m64, r64, CL</c><br/>
		/// <br/>
		/// <c>REX.W 0F A5 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shld_rm64_r64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shld_rm32_r32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shld_rm16_r16_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shld instruction.<br/>
		/// <br/>
		/// <c>SHLD r/m16, r16, CL</c><br/>
		/// <br/>
		/// <c>o16 0F A5 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHLD r/m32, r32, CL</c><br/>
		/// <br/>
		/// <c>o32 0F A5 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHLD r/m64, r64, CL</c><br/>
		/// <br/>
		/// <c>REX.W 0F A5 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shld(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shld_rm64_r64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shld_rm32_r32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shld_rm16_r16_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shld instruction.<br/>
		/// <br/>
		/// </summary>
		public void shld(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shld_rm64_r64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shld_rm32_r32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shld_rm16_r16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shld instruction.<br/>
		/// <br/>
		/// </summary>
		public void shld(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shld_rm64_r64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shld_rm32_r32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shld_rm16_r16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shlx instruction.<br/>
		/// <br/>
		/// <c>SHLX r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.66.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHLX r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.66.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shlx(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Shlx_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Shlx_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(shlx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shlx instruction.<br/>
		/// <br/>
		/// <c>SHLX r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.66.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHLX r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.66.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shlx(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Shlx_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Shlx_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(shlx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shr instruction.<br/>
		/// <br/>
		/// <c>SHR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /5</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /5</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shr_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shr_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shr_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Shr_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>shr instruction.<br/>
		/// <br/>
		/// <c>SHR r/m8, CL</c><br/>
		/// <br/>
		/// <c>D2 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHR r/m16, CL</c><br/>
		/// <br/>
		/// <c>o16 D3 /5</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHR r/m32, CL</c><br/>
		/// <br/>
		/// <c>o32 D3 /5</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHR r/m64, CL</c><br/>
		/// <br/>
		/// <c>REX.W D3 /5</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shr_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shr_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shr_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shr_rm8_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shr), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>shr instruction.<br/>
		/// <br/>
		/// </summary>
		public void shr(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Shr_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Shr_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Shr_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Shr_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(shr), dst, imm);
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Shr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shr_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Shr_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shr), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>shr instruction.<br/>
		/// <br/>
		/// </summary>
		public void shr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Shr_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Shr_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Shr_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Shr_rm8_1;
				} else {
					throw NoOpCodeFoundFor(nameof(shr), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shr_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shr_rm8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shr), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>shrd instruction.<br/>
		/// <br/>
		/// <c>SHRD r/m16, r16, CL</c><br/>
		/// <br/>
		/// <c>o16 0F AD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHRD r/m32, r32, CL</c><br/>
		/// <br/>
		/// <c>o32 0F AD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHRD r/m64, r64, CL</c><br/>
		/// <br/>
		/// <c>REX.W 0F AD /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shrd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shrd_rm64_r64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shrd_rm32_r32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shrd_rm16_r16_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shrd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shrd instruction.<br/>
		/// <br/>
		/// <c>SHRD r/m16, r16, CL</c><br/>
		/// <br/>
		/// <c>o16 0F AD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHRD r/m32, r32, CL</c><br/>
		/// <br/>
		/// <c>o32 0F AD /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHRD r/m64, r64, CL</c><br/>
		/// <br/>
		/// <c>REX.W 0F AD /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shrd(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shrd_rm64_r64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shrd_rm32_r32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shrd_rm16_r16_CL;
			} else {
				throw NoOpCodeFoundFor(nameof(shrd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void shrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shrd_rm64_r64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shrd_rm32_r32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shrd_rm16_r16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void shrd(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shrd_rm64_r64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shrd_rm32_r32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shrd_rm16_r16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shrx instruction.<br/>
		/// <br/>
		/// <c>SHRX r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHRX r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shrx(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Shrx_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Shrx_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(shrx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shrx instruction.<br/>
		/// <br/>
		/// <c>SHRX r32a, r/m32, r32b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W0 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SHRX r64a, r/m64, r64b</c><br/>
		/// <br/>
		/// <c>VEX.LZ.F2.0F38.W1 F7 /r</c><br/>
		/// <br/>
		/// <c>BMI2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void shrx(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Shrx_r64_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Shrx_r32_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(shrx), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>shufpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void shufpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Shufpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shufpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shufpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void shufpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Shufpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shufpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shufps instruction.<br/>
		/// <br/>
		/// </summary>
		public void shufps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Shufps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shufps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>shufps instruction.<br/>
		/// <br/>
		/// </summary>
		public void shufps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Shufps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(shufps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>skinit instruction.<br/>
		/// <br/>
		/// <c>SKINIT</c><br/>
		/// <br/>
		/// <c>0F 01 DE</c><br/>
		/// <br/>
		/// <c>SKINIT or SVML</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void skinit() {
			Code op;
			op = Code.Skinit;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sldt instruction.<br/>
		/// <br/>
		/// <c>SLDT r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /0</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sldt(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Sldt_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(sldt), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sldt instruction.<br/>
		/// <br/>
		/// <c>SLDT r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /0</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sldt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sldt_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(sldt), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>slwpcb instruction.<br/>
		/// <br/>
		/// <c>SLWPCB r32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 12 /1</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SLWPCB r64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 12 /1</c><br/>
		/// <br/>
		/// <c>LWP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void slwpcb(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Slwpcb_r64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Slwpcb_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(slwpcb), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>smsw instruction.<br/>
		/// <br/>
		/// <c>SMSW r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 01 /4</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void smsw(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Smsw_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(smsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>smsw instruction.<br/>
		/// <br/>
		/// <c>SMSW r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 01 /4</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void smsw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Smsw_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(smsw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sqrtpd instruction.<br/>
		/// <br/>
		/// <c>SQRTPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtpd instruction.<br/>
		/// <br/>
		/// <c>SQRTPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtps instruction.<br/>
		/// <br/>
		/// <c>SQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtps instruction.<br/>
		/// <br/>
		/// <c>SQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtsd instruction.<br/>
		/// <br/>
		/// <c>SQRTSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtsd instruction.<br/>
		/// <br/>
		/// <c>SQRTSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtss instruction.<br/>
		/// <br/>
		/// <c>SQRTSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sqrtss instruction.<br/>
		/// <br/>
		/// <c>SQRTSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 51 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sqrtss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Sqrtss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(sqrtss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>stac instruction.<br/>
		/// <br/>
		/// <c>STAC</c><br/>
		/// <br/>
		/// <c>NP 0F 01 CB</c><br/>
		/// <br/>
		/// <c>SMAP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stac() {
			Code op;
			op = Code.Stac;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>stc instruction.<br/>
		/// <br/>
		/// <c>STC</c><br/>
		/// <br/>
		/// <c>F9</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stc() {
			Code op;
			op = Code.Stc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>std instruction.<br/>
		/// <br/>
		/// <c>STD</c><br/>
		/// <br/>
		/// <c>FD</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void std() {
			Code op;
			op = Code.Std;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>stgi instruction.<br/>
		/// <br/>
		/// <c>STGI</c><br/>
		/// <br/>
		/// <c>0F 01 DC</c><br/>
		/// <br/>
		/// <c>SKINIT or SVML</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stgi() {
			Code op;
			op = Code.Stgi;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sti instruction.<br/>
		/// <br/>
		/// <c>STI</c><br/>
		/// <br/>
		/// <c>FB</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sti() {
			Code op;
			op = Code.Sti;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>stmxcsr instruction.<br/>
		/// <br/>
		/// <c>STMXCSR m32</c><br/>
		/// <br/>
		/// <c>NP 0F AE /3</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stmxcsr(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.Stmxcsr_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>stosb instruction.<br/>
		/// <br/>
		/// <c>STOSB</c><br/>
		/// <br/>
		/// <c>AA</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stosb(Register src) {
			Code op;
			if (src == Register.AL) {
				op = Code.Stosb_m8_AL;
			} else {
				throw NoOpCodeFoundFor(nameof(stosb), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>stosd instruction.<br/>
		/// <br/>
		/// <c>STOSD</c><br/>
		/// <br/>
		/// <c>o32 AB</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stosd(Register src) {
			Code op;
			if (src == Register.EAX) {
				op = Code.Stosd_m32_EAX;
			} else {
				throw NoOpCodeFoundFor(nameof(stosd), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>stosq instruction.<br/>
		/// <br/>
		/// <c>STOSQ</c><br/>
		/// <br/>
		/// <c>REX.W AB</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void stosq(Register src) {
			Code op;
			if (src == Register.RAX) {
				op = Code.Stosq_m64_RAX;
			} else {
				throw NoOpCodeFoundFor(nameof(stosq), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>stosw instruction.<br/>
		/// <br/>
		/// <c>STOSW</c><br/>
		/// <br/>
		/// <c>o16 AB</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void stosw(Register src) {
			Code op;
			if (src == Register.AX) {
				op = Code.Stosw_m16_AX;
			} else {
				throw NoOpCodeFoundFor(nameof(stosw), src);
			}
			AddInstruction(Instruction.Create(op, src));
		}
		/// <summary>str instruction.<br/>
		/// <br/>
		/// <c>STR r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /1</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void str(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Str_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(str), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>str instruction.<br/>
		/// <br/>
		/// <c>STR r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /1</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void str(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Str_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(str), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>sub instruction.<br/>
		/// <br/>
		/// <c>SUB r/m8, r8</c><br/>
		/// <br/>
		/// <c>28 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 29 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 29 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 29 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sub(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(sub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sub instruction.<br/>
		/// <br/>
		/// <c>SUB r/m8, r8</c><br/>
		/// <br/>
		/// <c>28 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 29 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 29 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 29 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sub(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sub_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sub_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sub_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sub_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(sub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sub instruction.<br/>
		/// <br/>
		/// <c>SUB r8, r/m8</c><br/>
		/// <br/>
		/// <c>2A /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 2B /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 2B /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 2B /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sub(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(sub), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>sub instruction.<br/>
		/// <br/>
		/// <c>SUB AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 2D iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 2D id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 2D id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>SUB r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /5 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /5 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /5 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sub(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Sub_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Sub_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Sub_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Sub_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Sub_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(sub), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Sub_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Sub_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Sub_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Sub_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(sub), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>sub instruction.<br/>
		/// <br/>
		/// <c>SUB r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /5 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /5 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SUB r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /5 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sub(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sub_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sub_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sub_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sub_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(sub), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sub_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sub_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sub_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(sub), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>subpd instruction.<br/>
		/// <br/>
		/// <c>SUBPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(subpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subpd instruction.<br/>
		/// <br/>
		/// <c>SUBPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(subpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subps instruction.<br/>
		/// <br/>
		/// <c>SUBPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(subps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subps instruction.<br/>
		/// <br/>
		/// <c>SUBPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(subps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subsd instruction.<br/>
		/// <br/>
		/// <c>SUBSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(subsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subsd instruction.<br/>
		/// <br/>
		/// <c>SUBSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>F2 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(subsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subss instruction.<br/>
		/// <br/>
		/// <c>SUBSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(subss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>subss instruction.<br/>
		/// <br/>
		/// <c>SUBSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>F3 0F 5C /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void subss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Subss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(subss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>swapgs instruction.<br/>
		/// <br/>
		/// <c>SWAPGS</c><br/>
		/// <br/>
		/// <c>0F 01 F8</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void swapgs() {
			Code op;
			op = Code.Swapgs;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>syscall instruction.<br/>
		/// <br/>
		/// <c>SYSCALL</c><br/>
		/// <br/>
		/// <c>0F 05</c><br/>
		/// <br/>
		/// <c>SYSCALL</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void syscall() {
			Code op;
			op = Code.Syscall;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sysenter instruction.<br/>
		/// <br/>
		/// <c>SYSENTER</c><br/>
		/// <br/>
		/// <c>0F 34</c><br/>
		/// <br/>
		/// <c>SEP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void sysenter() {
			Code op;
			op = Code.Sysenter;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sysexit instruction.<br/>
		/// <br/>
		/// <c>SYSEXIT</c><br/>
		/// <br/>
		/// <c>0F 35</c><br/>
		/// <br/>
		/// <c>SEP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SYSEXIT</c><br/>
		/// <br/>
		/// <c>REX.W 0F 35</c><br/>
		/// <br/>
		/// <c>SEP</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sysexit() {
			Code op;
			if (Bitness == 64) {
				op = Code.Sysexitd;
			} else if (Bitness == 64) {
				op = Code.Sysexitq;
			} else {
				throw NoOpCodeFoundFor(nameof(sysexit));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>sysret instruction.<br/>
		/// <br/>
		/// <c>SYSRET</c><br/>
		/// <br/>
		/// <c>0F 07</c><br/>
		/// <br/>
		/// <c>SYSCALL</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>SYSRET</c><br/>
		/// <br/>
		/// <c>REX.W 0F 07</c><br/>
		/// <br/>
		/// <c>SYSCALL</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void sysret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Sysretd;
			} else if (Bitness == 64) {
				op = Code.Sysretq;
			} else {
				throw NoOpCodeFoundFor(nameof(sysret));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>t1mskc instruction.<br/>
		/// <br/>
		/// <c>T1MSKC r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /7</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>T1MSKC r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /7</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void t1mskc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_T1mskc_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_T1mskc_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(t1mskc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>t1mskc instruction.<br/>
		/// <br/>
		/// <c>T1MSKC r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /7</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>T1MSKC r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /7</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void t1mskc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_T1mskc_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_T1mskc_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(t1mskc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>test instruction.<br/>
		/// <br/>
		/// <c>TEST r/m8, r8</c><br/>
		/// <br/>
		/// <c>84 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 85 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 85 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 85 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void test(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Test_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Test_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Test_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Test_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(test), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>test instruction.<br/>
		/// <br/>
		/// <c>TEST r/m8, r8</c><br/>
		/// <br/>
		/// <c>84 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 85 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 85 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 85 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void test(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Test_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Test_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Test_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Test_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(test), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>test instruction.<br/>
		/// <br/>
		/// <c>TEST AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 A9 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 A9 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W A9 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>TEST r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 F7 /0 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 F7 /0 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W F7 /0 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void test(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst == Register.AL) {
					op = Code.Test_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Test_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(test), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Test_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Test_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Test_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Test_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Test_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Test_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(test), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>test instruction.<br/>
		/// <br/>
		/// <c>TEST r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 F7 /0 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 F7 /0 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TEST r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W F7 /0 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void test(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Test_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(test), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Test_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Test_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Test_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(test), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>tpause instruction.<br/>
		/// <br/>
		/// <c>TPAUSE r32, &lt;edx&gt;, &lt;eax&gt;</c><br/>
		/// <br/>
		/// <c>66 0F AE /6</c><br/>
		/// <br/>
		/// <c>WAITPKG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TPAUSE r64, &lt;edx&gt;, &lt;eax&gt;</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F AE /6</c><br/>
		/// <br/>
		/// <c>WAITPKG</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void tpause(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tpause_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Tpause_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(tpause), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>tzcnt instruction.<br/>
		/// <br/>
		/// <c>TZCNT r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F3 0F BC /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TZCNT r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F3 0F BC /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TZCNT r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F BC /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void tzcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(tzcnt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>tzcnt instruction.<br/>
		/// <br/>
		/// <c>TZCNT r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 F3 0F BC /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TZCNT r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 F3 0F BC /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TZCNT r64, r/m64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F BC /r</c><br/>
		/// <br/>
		/// <c>BMI1</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void tzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(tzcnt), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>tzmsk instruction.<br/>
		/// <br/>
		/// <c>TZMSK r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /4</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TZMSK r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /4</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void tzmsk(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Tzmsk_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Tzmsk_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(tzmsk), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>tzmsk instruction.<br/>
		/// <br/>
		/// <c>TZMSK r32, r/m32</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W0 01 /4</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>TZMSK r64, r/m64</c><br/>
		/// <br/>
		/// <c>XOP.L0.X9.W1 01 /4</c><br/>
		/// <br/>
		/// <c>TBM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void tzmsk(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.XOP_Tzmsk_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.XOP_Tzmsk_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(tzmsk), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ucomisd instruction.<br/>
		/// <br/>
		/// <c>UCOMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 2E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ucomisd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Ucomisd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(ucomisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ucomisd instruction.<br/>
		/// <br/>
		/// <c>UCOMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>66 0F 2E /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ucomisd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Ucomisd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(ucomisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ucomiss instruction.<br/>
		/// <br/>
		/// <c>UCOMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 2E /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ucomiss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Ucomiss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(ucomiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ucomiss instruction.<br/>
		/// <br/>
		/// <c>UCOMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 2E /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ucomiss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Ucomiss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(ucomiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ud0 instruction.<br/>
		/// <br/>
		/// <c>UD0 r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F FF /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD0 r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F FF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD0 r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F FF /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ud0(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ud0), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ud0 instruction.<br/>
		/// <br/>
		/// <c>UD0 r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F FF /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD0 r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F FF /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD0 r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F FF /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ud0(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ud0), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ud1 instruction.<br/>
		/// <br/>
		/// <c>UD1 r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F B9 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD1 r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F B9 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD1 r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F B9 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ud1(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ud1), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ud1 instruction.<br/>
		/// <br/>
		/// <c>UD1 r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F B9 /r</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD1 r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F B9 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UD1 r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 0F B9 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void ud1(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(ud1), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>ud2 instruction.<br/>
		/// <br/>
		/// <c>UD2</c><br/>
		/// <br/>
		/// <c>0F 0B</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void ud2() {
			Code op;
			op = Code.Ud2;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>umonitor instruction.<br/>
		/// <br/>
		/// <c>UMONITOR r32</c><br/>
		/// <br/>
		/// <c>a32 F3 0F AE /6</c><br/>
		/// <br/>
		/// <c>WAITPKG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UMONITOR r64</c><br/>
		/// <br/>
		/// <c>F3 0F AE /6</c><br/>
		/// <br/>
		/// <c>WAITPKG</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void umonitor(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Umonitor_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Umonitor_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(umonitor), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>umov instruction.<br/>
		/// <br/>
		/// <c>UMOV r/m8, r8</c><br/>
		/// <br/>
		/// <c>0F 10 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>UMOV r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F 11 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>UMOV r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F 11 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void umov(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(umov), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>umov instruction.<br/>
		/// <br/>
		/// <c>UMOV r/m8, r8</c><br/>
		/// <br/>
		/// <c>0F 10 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>UMOV r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F 11 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>UMOV r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F 11 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void umov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Umov_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Umov_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Umov_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(umov), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>umov instruction.<br/>
		/// <br/>
		/// <c>UMOV r8, r/m8</c><br/>
		/// <br/>
		/// <c>0F 12 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>UMOV r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 13 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>UMOV r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F 13 /r</c><br/>
		/// <br/>
		/// <c>386/486</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void umov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(umov), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>umwait instruction.<br/>
		/// <br/>
		/// <c>UMWAIT r32, &lt;edx&gt;, &lt;eax&gt;</c><br/>
		/// <br/>
		/// <c>F2 0F AE /6</c><br/>
		/// <br/>
		/// <c>WAITPKG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>UMWAIT r64, &lt;edx&gt;, &lt;eax&gt;</c><br/>
		/// <br/>
		/// <c>F2 REX.W 0F AE /6</c><br/>
		/// <br/>
		/// <c>WAITPKG</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void umwait(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Umwait_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Umwait_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(umwait), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>unpckhpd instruction.<br/>
		/// <br/>
		/// <c>UNPCKHPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 15 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpckhpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpckhpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpckhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpckhpd instruction.<br/>
		/// <br/>
		/// <c>UNPCKHPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 15 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpckhpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpckhpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpckhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpckhps instruction.<br/>
		/// <br/>
		/// <c>UNPCKHPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 15 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpckhps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpckhps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpckhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpckhps instruction.<br/>
		/// <br/>
		/// <c>UNPCKHPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 15 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpckhps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpckhps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpckhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpcklpd instruction.<br/>
		/// <br/>
		/// <c>UNPCKLPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 14 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpcklpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpcklpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpcklpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpcklpd instruction.<br/>
		/// <br/>
		/// <c>UNPCKLPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 14 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpcklpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpcklpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpcklpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpcklps instruction.<br/>
		/// <br/>
		/// <c>UNPCKLPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 14 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpcklps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpcklps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpcklps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>unpcklps instruction.<br/>
		/// <br/>
		/// <c>UNPCKLPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 14 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void unpcklps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Unpcklps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(unpcklps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vaddpd instruction.<br/>
		/// <br/>
		/// <c>VADDPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vaddpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaddpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddpd instruction.<br/>
		/// <br/>
		/// <c>VADDPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vaddpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaddpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddps instruction.<br/>
		/// <br/>
		/// <c>VADDPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vaddps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaddps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddps instruction.<br/>
		/// <br/>
		/// <c>VADDPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vaddps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaddps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddsd instruction.<br/>
		/// <br/>
		/// <c>VADDSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vaddsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddsd instruction.<br/>
		/// <br/>
		/// <c>VADDSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaddsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddss instruction.<br/>
		/// <br/>
		/// <c>VADDSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vaddss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddss instruction.<br/>
		/// <br/>
		/// <c>VADDSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 58 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaddss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddsubpd instruction.<br/>
		/// <br/>
		/// <c>VADDSUBPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDSUBPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddsubpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vaddsubpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaddsubpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddsubpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddsubpd instruction.<br/>
		/// <br/>
		/// <c>VADDSUBPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDSUBPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddsubpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vaddsubpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaddsubpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddsubpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddsubps instruction.<br/>
		/// <br/>
		/// <c>VADDSUBPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDSUBPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddsubps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vaddsubps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaddsubps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddsubps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaddsubps instruction.<br/>
		/// <br/>
		/// <c>VADDSUBPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VADDSUBPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG D0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaddsubps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vaddsubps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaddsubps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaddsubps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesdec instruction.<br/>
		/// <br/>
		/// <c>VAESDEC xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDEC ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDEC zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesdec(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesdec_zmm_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vaesdec_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaesdec_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesdec), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesdec instruction.<br/>
		/// <br/>
		/// <c>VAESDEC xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDEC ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDEC xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDEC ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDEC zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesdec(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesdec_zmm_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vaesdec_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vaesdec_ymm_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaesdec_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaesdec_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesdec), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesdeclast instruction.<br/>
		/// <br/>
		/// <c>VAESDECLAST xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDECLAST ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDECLAST zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesdeclast(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesdeclast_zmm_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vaesdeclast_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaesdeclast_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesdeclast), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesdeclast instruction.<br/>
		/// <br/>
		/// <c>VAESDECLAST xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDECLAST ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDECLAST xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDECLAST ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESDECLAST zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesdeclast(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesdeclast_zmm_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vaesdeclast_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vaesdeclast_ymm_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaesdeclast_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaesdeclast_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesdeclast), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesenc instruction.<br/>
		/// <br/>
		/// <c>VAESENC xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENC ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENC zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesenc(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesenc_zmm_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vaesenc_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaesenc_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesenc), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesenc instruction.<br/>
		/// <br/>
		/// <c>VAESENC xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENC ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENC xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENC ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENC zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesenc(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesenc_zmm_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vaesenc_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vaesenc_ymm_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaesenc_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaesenc_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesenc), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesenclast instruction.<br/>
		/// <br/>
		/// <c>VAESENCLAST xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENCLAST ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENCLAST zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesenclast(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesenclast_zmm_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vaesenclast_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vaesenclast_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesenclast), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesenclast instruction.<br/>
		/// <br/>
		/// <c>VAESENCLAST xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENCLAST ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENCLAST xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENCLAST ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VAESENCLAST zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512F and VAES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesenclast(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vaesenclast_zmm_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vaesenclast_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vaesenclast_ymm_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vaesenclast_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vaesenclast_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesenclast), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vaesimc instruction.<br/>
		/// <br/>
		/// <c>VAESIMC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DB /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesimc(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vaesimc_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesimc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vaesimc instruction.<br/>
		/// <br/>
		/// <c>VAESIMC xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG DB /r</c><br/>
		/// <br/>
		/// <c>AES and AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vaesimc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vaesimc_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vaesimc), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vaeskeygenassist instruction.<br/>
		/// <br/>
		/// </summary>
		public void vaeskeygenassist(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vaeskeygenassist_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vaeskeygenassist), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vaeskeygenassist instruction.<br/>
		/// <br/>
		/// </summary>
		public void vaeskeygenassist(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vaeskeygenassist_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vaeskeygenassist), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>valignd instruction.<br/>
		/// <br/>
		/// </summary>
		public void valignd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(valignd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>valignd instruction.<br/>
		/// <br/>
		/// </summary>
		public void valignd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(valignd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>valignq instruction.<br/>
		/// <br/>
		/// </summary>
		public void valignq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(valignq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>valignq instruction.<br/>
		/// <br/>
		/// </summary>
		public void valignq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(valignq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vandnpd instruction.<br/>
		/// <br/>
		/// <c>VANDNPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandnpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vandnpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vandnpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vandnpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandnpd instruction.<br/>
		/// <br/>
		/// <c>VANDNPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandnpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vandnpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vandnpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vandnpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandnps instruction.<br/>
		/// <br/>
		/// <c>VANDNPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandnps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vandnps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vandnps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vandnps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandnps instruction.<br/>
		/// <br/>
		/// <c>VANDNPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 55 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandnps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vandnps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vandnps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vandnps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandpd instruction.<br/>
		/// <br/>
		/// <c>VANDPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vandpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vandpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vandpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandpd instruction.<br/>
		/// <br/>
		/// <c>VANDPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vandpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vandpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vandpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandps instruction.<br/>
		/// <br/>
		/// <c>VANDPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vandps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vandps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vandps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vandps instruction.<br/>
		/// <br/>
		/// <c>VANDPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 54 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vandps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vandps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vandps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vandps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vandps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vandps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vandps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vblendmpd instruction.<br/>
		/// <br/>
		/// <c>VBLENDMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendmpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendmpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vblendmpd instruction.<br/>
		/// <br/>
		/// <c>VBLENDMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendmpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendmpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vblendmps instruction.<br/>
		/// <br/>
		/// <c>VBLENDMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendmps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendmps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vblendmps instruction.<br/>
		/// <br/>
		/// <c>VBLENDMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendmps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendmps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vblendpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vblendpd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendpd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendpd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vblendpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vblendpd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendpd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendpd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vblendps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vblendps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendps_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vblendps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vblendps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendps_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vblendvpd instruction.<br/>
		/// <br/>
		/// <c>VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 4B /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 4B /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendvpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendvpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendvpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendvpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vblendvpd instruction.<br/>
		/// <br/>
		/// <c>VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 4B /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 4B /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendvpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendvpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendvpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendvpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vblendvps instruction.<br/>
		/// <br/>
		/// <c>VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 4A /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 4A /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendvps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendvps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendvps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendvps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vblendvps instruction.<br/>
		/// <br/>
		/// <c>VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 4A /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 4A /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vblendvps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vblendvps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vblendvps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vblendvps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vbroadcastf128 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF128 ymm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 1A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf128(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vbroadcastf128_ymm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf128), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf128 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF128 ymm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 1A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf128(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vbroadcastf128_ymm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf128), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf32x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF32X2 ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTF32X2 zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf32x2(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf32x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf32x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF32X2 ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTF32X2 zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf32x2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf32x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf32x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF32X4 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTF32X4 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf32x4(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf32x4_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcastf32x4_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf32x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf32x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF32X4 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTF32X4 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf32x4(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf32x4_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcastf32x4_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf32x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf32x8 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF32X8 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 1B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf32x8(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf32x8_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf32x8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf32x8 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF32X8 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 1B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf32x8(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf32x8_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf32x8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf64x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF64X2 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTF64X2 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf64x2(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf64x2_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcastf64x2_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf64x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf64x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF64X2 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTF64X2 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 1A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf64x2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf64x2_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcastf64x2_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf64x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf64x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF64X4 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 1B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf64x4(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf64x4_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf64x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastf64x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTF64X4 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 1B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastf64x4(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastf64x4_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastf64x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti128 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI128 ymm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti128(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vbroadcasti128_ymm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti128), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti128 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI128 ymm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti128(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vbroadcasti128_ymm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti128), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti32x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI32X2 xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI32X2 ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI32X2 zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti32x2(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti32x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti32x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI32X2 xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI32X2 ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI32X2 zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti32x2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti32x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti32x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI32X4 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI32X4 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti32x4(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti32x4_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcasti32x4_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti32x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti32x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI32X4 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI32X4 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti32x4(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti32x4_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcasti32x4_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti32x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti32x8 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI32X8 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti32x8(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti32x8_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti32x8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti32x8 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI32X8 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti32x8(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti32x8_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti32x8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti64x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI64X2 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI64X2 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti64x2(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti64x2_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcasti64x2_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti64x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti64x2 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI64X2 ymm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTI64X2 zmm1 {k1}{z}, m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti64x2(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti64x2_zmm_k1z_m128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vbroadcasti64x2_ymm_k1z_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti64x2), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti64x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI64X4 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti64x4(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti64x4_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti64x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcasti64x4 instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTI64X4 zmm1 {k1}{z}, m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcasti64x4(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcasti64x4_zmm_k1z_m256;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcasti64x4), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastsd instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTSD ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 19 /r</c><br/>
		/// <br/>
		/// <c>AVX (reg,mem) or AVX2 (reg,reg)</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSD zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastsd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastsd_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vbroadcastsd_ymm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastsd instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTSD ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 19 /r</c><br/>
		/// <br/>
		/// <c>AVX (reg,mem) or AVX2 (reg,reg)</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSD ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSD zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 19 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastsd_zmm_k1z_xmmm64;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vbroadcastsd_ymm_k1z_xmmm64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vbroadcastsd_ymm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastss instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX (reg,mem) or AVX2 (reg,reg)</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSS ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX (reg,mem) or AVX2 (reg,reg)</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSS zmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastss(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastss_zmm_k1z_xmmm32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vbroadcastss_ymm_xmmm32;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vbroadcastss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vbroadcastss instruction.<br/>
		/// <br/>
		/// <c>VBROADCASTSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX (reg,mem) or AVX2 (reg,reg)</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSS ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX (reg,mem) or AVX2 (reg,reg)</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSS xmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSS ymm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VBROADCASTSS zmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 18 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vbroadcastss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vbroadcastss_zmm_k1z_xmmm32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vbroadcastss_ymm_xmmm32;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vbroadcastss_ymm_k1z_xmmm32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vbroadcastss_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vbroadcastss_xmm_k1z_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vbroadcastss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcmppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmppd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vcmppd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcmppd_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vcmppd_k_k1_zmm_zmmm512b64_imm8_sae;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vcmppd_k_k1_ymm_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vcmppd_k_k1_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmppd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmppd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vcmppd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcmppd_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vcmppd_k_k1_zmm_zmmm512b64_imm8_sae;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vcmppd_k_k1_ymm_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vcmppd_k_k1_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmppd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmpps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vcmpps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcmpps_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vcmpps_k_k1_zmm_zmmm512b32_imm8_sae;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vcmpps_k_k1_ymm_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vcmpps_k_k1_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmpps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmpps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vcmpps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcmpps_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vcmpps_k_k1_zmm_zmmm512b32_imm8_sae;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vcmpps_k_k1_ymm_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vcmpps_k_k1_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmpps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmpsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmpsd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcmpsd_xmm_xmm_xmmm64_imm8;
			} else if (dst.IsK()) {
				op = Code.EVEX_Vcmpsd_k_k1_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmpsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmpsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmpsd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcmpsd_xmm_xmm_xmmm64_imm8;
			} else if (dst.IsK()) {
				op = Code.EVEX_Vcmpsd_k_k1_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmpsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmpss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmpss(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcmpss_xmm_xmm_xmmm32_imm8;
			} else if (dst.IsK()) {
				op = Code.EVEX_Vcmpss_k_k1_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmpss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcmpss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcmpss(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcmpss_xmm_xmm_xmmm32_imm8;
			} else if (dst.IsK()) {
				op = Code.EVEX_Vcmpss_k_k1_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcmpss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vcomisd instruction.<br/>
		/// <br/>
		/// <c>VCOMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F.WIG 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcomisd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcomisd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcomisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcomisd instruction.<br/>
		/// <br/>
		/// <c>VCOMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F.WIG 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMISD xmm1, xmm2/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F.W1 2F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcomisd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcomisd_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcomisd_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcomisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcomiss instruction.<br/>
		/// <br/>
		/// <c>VCOMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.0F.WIG 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcomiss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcomiss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcomiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcomiss instruction.<br/>
		/// <br/>
		/// <c>VCOMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.0F.WIG 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMISS xmm1, xmm2/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.0F.W0 2F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcomiss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcomiss_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcomiss_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcomiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcompresspd instruction.<br/>
		/// <br/>
		/// <c>VCOMPRESSPD xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPD ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPD zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcompresspd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcompresspd_zmmm512_k1z_zmm;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcompresspd_ymmm256_k1z_ymm;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcompresspd_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vcompresspd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcompresspd instruction.<br/>
		/// <br/>
		/// <c>VCOMPRESSPD xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPD ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPD zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcompresspd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vcompresspd_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcompresspd_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcompresspd_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vcompresspd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcompressps instruction.<br/>
		/// <br/>
		/// <c>VCOMPRESSPS xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPS ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPS zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcompressps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcompressps_zmmm512_k1z_zmm;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcompressps_ymmm256_k1z_ymm;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcompressps_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vcompressps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcompressps instruction.<br/>
		/// <br/>
		/// <c>VCOMPRESSPS xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPS ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCOMPRESSPS zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcompressps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vcompressps_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcompressps_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcompressps_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vcompressps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtdq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTDQ2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtdq2pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vcvtdq2pd_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcvtdq2pd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtdq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtdq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTDQ2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtdq2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vcvtdq2pd_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtdq2pd_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtdq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtdq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTDQ2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtdq2ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vcvtdq2ps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcvtdq2ps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtdq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtdq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTDQ2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtdq2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vcvtdq2ps_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtdq2ps_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtdq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtne2ps2bf16 instruction.<br/>
		/// <br/>
		/// <c>VCVTNE2PS2BF16 xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNE2PS2BF16 ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNE2PS2BF16 zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtne2ps2bf16(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtne2ps2bf16), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtne2ps2bf16 instruction.<br/>
		/// <br/>
		/// <c>VCVTNE2PS2BF16 xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNE2PS2BF16 ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNE2PS2BF16 zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtne2ps2bf16(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtne2ps2bf16), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtneps2bf16 instruction.<br/>
		/// <br/>
		/// <c>VCVTNEPS2BF16 xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNEPS2BF16 xmm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNEPS2BF16 ymm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtneps2bf16(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtneps2bf16), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtneps2bf16 instruction.<br/>
		/// <br/>
		/// <c>VCVTNEPS2BF16 xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNEPS2BF16 xmm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTNEPS2BF16 ymm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtneps2bf16(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtneps2bf16), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2DQ xmm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2dq(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vcvtpd2dq_xmm_ymmm256;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vcvtpd2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2DQ xmm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2DQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2DQ xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtpd2dq_xmm_ymmm256;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vcvtpd2dq_xmm_xmmm128;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2PS xmm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2ps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vcvtpd2ps_xmm_ymmm256;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vcvtpd2ps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2PS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2PS xmm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2PS xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2PS xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtpd2ps_xmm_ymmm256;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vcvtpd2ps_xmm_xmmm128;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2qq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2qq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2udq(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2udq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2uqq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtpd2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtpd2uqq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtpd2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtph2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTPH2PS xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>F16C</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPH2PS ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>F16C</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPH2PS zmm1 {k1}{z}, ymm2/m256{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtph2ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vcvtph2ps_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcvtph2ps_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtph2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtph2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTPH2PS xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>F16C</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPH2PS ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>F16C</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPH2PS xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPH2PS ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPH2PS zmm1 {k1}{z}, ymm2/m256{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtph2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vcvtph2ps_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vcvtph2ps_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtph2ps_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtph2ps_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtph2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2DQ ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2dq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vcvtps2dq_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcvtps2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2DQ ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vcvtps2dq_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtps2dq_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2PD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2PD zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vcvtps2pd_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcvtps2pd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2PD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2PD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2PD xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2PD ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2PD zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vcvtps2pd_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtps2pd_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2ph instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcvtps2ph(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vcvtps2ph_xmmm128_ymm_imm8;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vcvtps2ph_xmmm64_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2ph), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vcvtps2ph instruction.<br/>
		/// <br/>
		/// </summary>
		public void vcvtps2ph(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vcvtps2ph_xmmm128_ymm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vcvtps2ph_xmmm64_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2ph), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vcvtps2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2qq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2qq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2udq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2udq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2uqq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtps2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtps2uqq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtps2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtqq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtqq2pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtqq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtqq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtqq2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtqq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtqq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtqq2ps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtqq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtqq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W1 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtqq2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtqq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtsd2si instruction.<br/>
		/// <br/>
		/// <c>VCVTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsd2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vcvtsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vcvtsd2si_r32_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtsd2si instruction.<br/>
		/// <br/>
		/// <c>VCVTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VCVTSD2SI r32, xmm1/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSD2SI r64, xmm1/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsd2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && PreferVex) {
				op = Code.VEX_Vcvtsd2si_r64_xmmm64;
			} else if (dst.IsGPR64() && !PreferVex) {
				op = Code.EVEX_Vcvtsd2si_r64_xmmm64_er;
			} else if (dst.IsGPR32() && PreferVex) {
				op = Code.VEX_Vcvtsd2si_r32_xmmm64;
			} else if (dst.IsGPR32() && !PreferVex) {
				op = Code.EVEX_Vcvtsd2si_r32_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtsd2ss instruction.<br/>
		/// <br/>
		/// <c>VCVTSD2SS xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtsd2ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcvtsd2ss_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsd2ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtsd2ss instruction.<br/>
		/// <br/>
		/// <c>VCVTSD2SS xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSD2SS xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtsd2ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsd2ss_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsd2ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtsd2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTSD2USI r32, xmm1/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSD2USI r64, xmm1/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsd2usi(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvtsd2usi_r64_xmmm64_er;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvtsd2usi_r32_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsd2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtsd2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTSD2USI r32, xmm1/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSD2USI r64, xmm1/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsd2usi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvtsd2usi_r64_xmmm64_er;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvtsd2usi_r32_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsd2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtsi2sd instruction.<br/>
		/// <br/>
		/// <c>VCVTSI2SD xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSI2SD xmm1, xmm2, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsi2sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2sd_xmm_xmm_rm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2sd_xmm_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsi2sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtsi2sd instruction.<br/>
		/// <br/>
		/// <c>VCVTSI2SD xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSI2SD xmm1, xmm2, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VCVTSI2SD xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSI2SD xmm1, xmm2, r/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsi2sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2sd_xmm_xmm_rm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtsi2sd_xmm_xmm_rm64_er;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2sd_xmm_xmm_rm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtsi2sd_xmm_xmm_rm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsi2sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtsi2ss instruction.<br/>
		/// <br/>
		/// <c>VCVTSI2SS xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSI2SS xmm1, xmm2, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsi2ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2ss_xmm_xmm_rm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2ss_xmm_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsi2ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtsi2ss instruction.<br/>
		/// <br/>
		/// <c>VCVTSI2SS xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSI2SS xmm1, xmm2, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VCVTSI2SS xmm1, xmm2, r/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSI2SS xmm1, xmm2, r/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtsi2ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2ss_xmm_xmm_rm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtsi2ss_xmm_xmm_rm64_er;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtsi2ss_xmm_xmm_rm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtsi2ss_xmm_xmm_rm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtsi2ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtss2sd instruction.<br/>
		/// <br/>
		/// <c>VCVTSS2SD xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtss2sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vcvtss2sd_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtss2sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtss2sd instruction.<br/>
		/// <br/>
		/// <c>VCVTSS2SD xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSS2SD xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 5A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtss2sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvtss2sd_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtss2sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtss2si instruction.<br/>
		/// <br/>
		/// <c>VCVTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtss2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vcvtss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vcvtss2si_r32_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtss2si instruction.<br/>
		/// <br/>
		/// <c>VCVTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VCVTSS2SI r32, xmm1/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSS2SI r64, xmm1/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtss2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && PreferVex) {
				op = Code.VEX_Vcvtss2si_r64_xmmm32;
			} else if (dst.IsGPR64() && !PreferVex) {
				op = Code.EVEX_Vcvtss2si_r64_xmmm32_er;
			} else if (dst.IsGPR32() && PreferVex) {
				op = Code.VEX_Vcvtss2si_r32_xmmm32;
			} else if (dst.IsGPR32() && !PreferVex) {
				op = Code.EVEX_Vcvtss2si_r32_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtss2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTSS2USI r32, xmm1/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSS2USI r64, xmm1/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtss2usi(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvtss2usi_r64_xmmm32_er;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvtss2usi_r32_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtss2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtss2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTSS2USI r32, xmm1/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTSS2USI r64, xmm1/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtss2usi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvtss2usi_r64_xmmm32_er;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvtss2usi_r32_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtss2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2DQ xmm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2dq(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vcvttpd2dq_xmm_ymmm256;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vcvttpd2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2DQ xmm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2DQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2DQ xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 E6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvttpd2dq_xmm_ymmm256;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vcvttpd2dq_xmm_xmmm128;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2qq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2qq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2udq(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2UDQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UDQ xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UDQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2udq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2uqq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttpd2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttpd2uqq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttpd2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2DQ ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2dq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vcvttps2dq_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vcvttps2dq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2dq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2DQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2DQ ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 5B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 5B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2dq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vcvttps2dq_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vcvttps2dq_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2dq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2qq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2qq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2qq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2qq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2udq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2udq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2udq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2udq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2uqq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttps2uqq instruction.<br/>
		/// <br/>
		/// <c>VCVTTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvttps2uqq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttps2uqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttsd2si instruction.<br/>
		/// <br/>
		/// <c>VCVTTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttsd2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vcvttsd2si_r64_xmmm64;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vcvttsd2si_r32_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttsd2si instruction.<br/>
		/// <br/>
		/// <c>VCVTTSD2SI r32, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSD2SI r64, xmm1/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VCVTTSD2SI r32, xmm1/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSD2SI r64, xmm1/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttsd2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && PreferVex) {
				op = Code.VEX_Vcvttsd2si_r64_xmmm64;
			} else if (dst.IsGPR64() && !PreferVex) {
				op = Code.EVEX_Vcvttsd2si_r64_xmmm64_sae;
			} else if (dst.IsGPR32() && PreferVex) {
				op = Code.VEX_Vcvttsd2si_r32_xmmm64;
			} else if (dst.IsGPR32() && !PreferVex) {
				op = Code.EVEX_Vcvttsd2si_r32_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttsd2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttsd2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTTSD2USI r32, xmm1/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSD2USI r64, xmm1/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttsd2usi(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvttsd2usi_r64_xmmm64_sae;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvttsd2usi_r32_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttsd2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttsd2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTTSD2USI r32, xmm1/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSD2USI r64, xmm1/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttsd2usi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvttsd2usi_r64_xmmm64_sae;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvttsd2usi_r32_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttsd2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttss2si instruction.<br/>
		/// <br/>
		/// <c>VCVTTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttss2si(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vcvttss2si_r64_xmmm32;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vcvttss2si_r32_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttss2si instruction.<br/>
		/// <br/>
		/// <c>VCVTTSS2SI r32, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSS2SI r64, xmm1/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VCVTTSS2SI r32, xmm1/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSS2SI r64, xmm1/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttss2si(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && PreferVex) {
				op = Code.VEX_Vcvttss2si_r64_xmmm32;
			} else if (dst.IsGPR64() && !PreferVex) {
				op = Code.EVEX_Vcvttss2si_r64_xmmm32_sae;
			} else if (dst.IsGPR32() && PreferVex) {
				op = Code.VEX_Vcvttss2si_r32_xmmm32;
			} else if (dst.IsGPR32() && !PreferVex) {
				op = Code.EVEX_Vcvttss2si_r32_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttss2si), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttss2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTTSS2USI r32, xmm1/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSS2USI r64, xmm1/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttss2usi(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvttss2usi_r64_xmmm32_sae;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvttss2usi_r32_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttss2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvttss2usi instruction.<br/>
		/// <br/>
		/// <c>VCVTTSS2USI r32, xmm1/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTTSS2USI r64, xmm1/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvttss2usi(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.EVEX_Vcvttss2usi_r64_xmmm32_sae;
			} else if (dst.IsGPR32()) {
				op = Code.EVEX_Vcvttss2usi_r32_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvttss2usi), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtudq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTUDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtudq2pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtudq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtudq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTUDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtudq2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtudq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtudq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTUDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtudq2ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtudq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtudq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTUDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtudq2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtudq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtuqq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTUQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtuqq2pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtuqq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtuqq2pd instruction.<br/>
		/// <br/>
		/// <c>VCVTUQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtuqq2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtuqq2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtuqq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTUQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtuqq2ps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtuqq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtuqq2ps instruction.<br/>
		/// <br/>
		/// <c>VCVTUQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vcvtuqq2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtuqq2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vcvtusi2sd instruction.<br/>
		/// <br/>
		/// <c>VCVTUSI2SD xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUSI2SD xmm1, xmm2, r/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtusi2sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2sd_xmm_xmm_rm64_er;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2sd_xmm_xmm_rm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtusi2sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtusi2sd instruction.<br/>
		/// <br/>
		/// <c>VCVTUSI2SD xmm1, xmm2, r/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUSI2SD xmm1, xmm2, r/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtusi2sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2sd_xmm_xmm_rm64_er;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2sd_xmm_xmm_rm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtusi2sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtusi2ss instruction.<br/>
		/// <br/>
		/// <c>VCVTUSI2SS xmm1, xmm2, r/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUSI2SS xmm1, xmm2, r/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtusi2ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2ss_xmm_xmm_rm64_er;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2ss_xmm_xmm_rm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtusi2ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vcvtusi2ss instruction.<br/>
		/// <br/>
		/// <c>VCVTUSI2SS xmm1, xmm2, r/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VCVTUSI2SS xmm1, xmm2, r/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W1 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vcvtusi2ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2ss_xmm_xmm_rm64_er;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vcvtusi2ss_xmm_xmm_rm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vcvtusi2ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdbpsadbw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vdbpsadbw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vdbpsadbw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vdbpsadbw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vdbpsadbw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vdbpsadbw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vdivpd instruction.<br/>
		/// <br/>
		/// <c>VDIVPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vdivpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vdivpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivpd instruction.<br/>
		/// <br/>
		/// <c>VDIVPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vdivpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vdivpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivps instruction.<br/>
		/// <br/>
		/// <c>VDIVPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vdivps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vdivps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivps instruction.<br/>
		/// <br/>
		/// <c>VDIVPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vdivps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vdivps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivsd instruction.<br/>
		/// <br/>
		/// <c>VDIVSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vdivsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivsd instruction.<br/>
		/// <br/>
		/// <c>VDIVSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vdivsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivss instruction.<br/>
		/// <br/>
		/// <c>VDIVSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vdivss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdivss instruction.<br/>
		/// <br/>
		/// <c>VDIVSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDIVSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 5E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdivss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vdivss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vdivss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdpbf16ps instruction.<br/>
		/// <br/>
		/// <c>VDPBF16PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDPBF16PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDPBF16PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdpbf16ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vdpbf16ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdpbf16ps instruction.<br/>
		/// <br/>
		/// <c>VDPBF16PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDPBF16PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VDPBF16PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BF16</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vdpbf16ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vdpbf16ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vdppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vdppd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vdppd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vdppd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vdppd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vdppd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vdppd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vdppd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vdpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vdpps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vdpps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vdpps_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vdpps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vdpps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vdpps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vdpps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vdpps_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vdpps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>verr instruction.<br/>
		/// <br/>
		/// <c>VERR r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /4</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void verr(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Verr_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(verr), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>verr instruction.<br/>
		/// <br/>
		/// <c>VERR r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /4</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void verr(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Verr_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(verr), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>verw instruction.<br/>
		/// <br/>
		/// <c>VERW r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /5</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void verw(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Verw_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(verw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>verw instruction.<br/>
		/// <br/>
		/// <c>VERW r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F 00 /5</c><br/>
		/// <br/>
		/// <c>286+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void verw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Verw_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(verw), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vexp2pd instruction.<br/>
		/// <br/>
		/// <c>VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C8 /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexp2pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vexp2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexp2pd instruction.<br/>
		/// <br/>
		/// <c>VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C8 /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexp2pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vexp2pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexp2ps instruction.<br/>
		/// <br/>
		/// <c>VEXP2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C8 /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexp2ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vexp2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexp2ps instruction.<br/>
		/// <br/>
		/// <c>VEXP2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C8 /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexp2ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vexp2ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexpandpd instruction.<br/>
		/// <br/>
		/// <c>VEXPANDPD xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPD ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexpandpd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexpandpd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vexpandpd_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vexpandpd_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vexpandpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexpandpd instruction.<br/>
		/// <br/>
		/// <c>VEXPANDPD xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPD ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexpandpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexpandpd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vexpandpd_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vexpandpd_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vexpandpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexpandps instruction.<br/>
		/// <br/>
		/// <c>VEXPANDPS xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPS ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPS zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexpandps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexpandps_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vexpandps_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vexpandps_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vexpandps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vexpandps instruction.<br/>
		/// <br/>
		/// <c>VEXPANDPS xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPS ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VEXPANDPS zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 88 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vexpandps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vexpandps_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vexpandps_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vexpandps_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vexpandps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vextractf128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf128(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vextractf128_xmmm128_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf128), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf128(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vextractf128_xmmm128_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf128), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf32x4(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf32x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf32x4(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf32x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf32x8(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf32x8), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf32x8(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf32x8), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf64x2(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf64x2), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf64x2(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf64x2), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf64x4(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf64x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractf64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractf64x4(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractf64x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti128(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vextracti128_xmmm128_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti128), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti128(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vextracti128_xmmm128_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti128), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti32x4(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti32x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti32x4(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti32x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti32x8(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti32x8), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti32x8(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti32x8), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti64x2(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti64x2), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti64x2(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti64x2), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti64x4(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti64x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextracti64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextracti64x4(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextracti64x4), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vextractps_r64m32_xmm_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vextractps_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vextractps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vextractps(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr && PreferVex) {
				op = Code.VEX_Vextractps_r64m32_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.QwordPtr && !PreferVex) {
				op = Code.EVEX_Vextractps_r64m32_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr && PreferVex) {
				op = Code.VEX_Vextractps_rm32_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr && !PreferVex) {
				op = Code.EVEX_Vextractps_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vextractps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfixupimmpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmpd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmpd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmsd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmsd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmss(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfixupimmss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfixupimmss(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vfixupimmss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vfmadd132pd instruction.<br/>
		/// <br/>
		/// <c>VFMADD132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmadd132pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd132pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132pd instruction.<br/>
		/// <br/>
		/// <c>VFMADD132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmadd132pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd132pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132ps instruction.<br/>
		/// <br/>
		/// <c>VFMADD132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmadd132ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd132ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132ps instruction.<br/>
		/// <br/>
		/// <c>VFMADD132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 98 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmadd132ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd132ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132sd instruction.<br/>
		/// <br/>
		/// <c>VFMADD132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 99 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd132sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132sd instruction.<br/>
		/// <br/>
		/// <c>VFMADD132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 99 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 99 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd132sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132ss instruction.<br/>
		/// <br/>
		/// <c>VFMADD132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 99 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd132ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd132ss instruction.<br/>
		/// <br/>
		/// <c>VFMADD132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 99 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 99 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd132ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd132ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213pd instruction.<br/>
		/// <br/>
		/// <c>VFMADD213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmadd213pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd213pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213pd instruction.<br/>
		/// <br/>
		/// <c>VFMADD213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmadd213pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd213pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213ps instruction.<br/>
		/// <br/>
		/// <c>VFMADD213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmadd213ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd213ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213ps instruction.<br/>
		/// <br/>
		/// <c>VFMADD213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmadd213ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd213ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213sd instruction.<br/>
		/// <br/>
		/// <c>VFMADD213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 A9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd213sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213sd instruction.<br/>
		/// <br/>
		/// <c>VFMADD213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 A9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 A9 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd213sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213ss instruction.<br/>
		/// <br/>
		/// <c>VFMADD213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 A9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd213ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd213ss instruction.<br/>
		/// <br/>
		/// <c>VFMADD213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 A9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 A9 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd213ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd213ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231pd instruction.<br/>
		/// <br/>
		/// <c>VFMADD231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmadd231pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd231pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231pd instruction.<br/>
		/// <br/>
		/// <c>VFMADD231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmadd231pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd231pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231ps instruction.<br/>
		/// <br/>
		/// <c>VFMADD231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmadd231ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd231ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231ps instruction.<br/>
		/// <br/>
		/// <c>VFMADD231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 B8 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmadd231ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd231ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231sd instruction.<br/>
		/// <br/>
		/// <c>VFMADD231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 B9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd231sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231sd instruction.<br/>
		/// <br/>
		/// <c>VFMADD231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 B9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 B9 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd231sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231ss instruction.<br/>
		/// <br/>
		/// <c>VFMADD231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 B9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmadd231ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmadd231ss instruction.<br/>
		/// <br/>
		/// <c>VFMADD231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 B9 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 B9 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmadd231ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmadd231ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmadd231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddpd instruction.<br/>
		/// <br/>
		/// <c>VFMADDPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 69 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 69 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddpd instruction.<br/>
		/// <br/>
		/// <c>VFMADDPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 69 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 69 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddpd instruction.<br/>
		/// <br/>
		/// <c>VFMADDPD xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 69 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDPD ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 69 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddpd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddpd_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddpd_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddps instruction.<br/>
		/// <br/>
		/// <c>VFMADDPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 68 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 68 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddps instruction.<br/>
		/// <br/>
		/// <c>VFMADDPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 68 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 68 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddps instruction.<br/>
		/// <br/>
		/// <c>VFMADDPS xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 68 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDPS ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 68 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddps_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddps_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6B /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6B /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSD xmm1, xmm2, xmm3, xmm4/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 6B /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsd_xmm_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddss instruction.<br/>
		/// <br/>
		/// <c>VFMADDSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6A /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddss(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddss instruction.<br/>
		/// <br/>
		/// <c>VFMADDSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6A /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddss(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddss instruction.<br/>
		/// <br/>
		/// <c>VFMADDSS xmm1, xmm2, xmm3, xmm4/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 6A /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddss(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddss_xmm_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsub132pd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub132pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsub132pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsub132pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub132pd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub132pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub132pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub132pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub132ps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub132ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsub132ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsub132ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub132ps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 96 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub132ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub132ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub132ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub213pd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub213pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsub213pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsub213pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub213pd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub213pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub213pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub213pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub213ps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub213ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsub213ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsub213ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub213ps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub213ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub213ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub213ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub231pd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub231pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsub231pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsub231pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub231pd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub231pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub231pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub231pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub231ps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub231ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsub231ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsub231ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsub231ps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUB231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 B6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsub231ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub231ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmaddsub231ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsub231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmaddsubpd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUBPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUBPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsubpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsubpd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUBPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUBPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsubpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsubpd instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUBPD xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 5D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUBPD ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 5D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsubpd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsubpd_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsubpd_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsubps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUBPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUBPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsubps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsubps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUBPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUBPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsubps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmaddsubps instruction.<br/>
		/// <br/>
		/// <c>VFMADDSUBPS xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 5C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMADDSUBPS ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 5C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmaddsubps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmaddsubps_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmaddsubps_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmaddsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsub132pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsub132pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub132pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsub132pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub132pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsub132ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub132ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 9A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsub132ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub132ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132sd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 9B /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub132sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132sd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 9B /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 9B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub132sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132ss instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 9B /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub132ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub132ss instruction.<br/>
		/// <br/>
		/// <c>VFMSUB132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 9B /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 9B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub132ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub132ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsub213pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub213pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsub213pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub213pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsub213ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub213ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 AA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsub213ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub213ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213sd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 AB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub213sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213sd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 AB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 AB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub213sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213ss instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 AB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub213ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub213ss instruction.<br/>
		/// <br/>
		/// <c>VFMSUB213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 AB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 AB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub213ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub213ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsub231pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub231pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsub231pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub231pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsub231ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub231ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 BA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsub231ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub231ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231sd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 BB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub231sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231sd instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 BB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 BB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub231sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231ss instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 BB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsub231ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsub231ss instruction.<br/>
		/// <br/>
		/// <c>VFMSUB231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 BB /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 BB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsub231ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsub231ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsub231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd132pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd132pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubadd132pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubadd132pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd132pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd132pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd132pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd132pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd132ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd132ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubadd132ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubadd132ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd132ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 97 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd132ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd132ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd132ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd213pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd213pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubadd213pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubadd213pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd213pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd213pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd213pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd213pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd213ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd213ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubadd213ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubadd213ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd213ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd213ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd213ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd213ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd231pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd231pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubadd231pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubadd231pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd231pd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd231pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd231pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd231pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd231ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd231ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubadd231ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubadd231ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubadd231ps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADD231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 B7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubadd231ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd231ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfmsubadd231ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubadd231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfmsubaddpd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADDPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADDPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubaddpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubaddpd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADDPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADDPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubaddpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubaddpd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADDPD xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 5F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADDPD ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 5F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubaddpd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubaddpd_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubaddpd_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubaddps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADDPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADDPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubaddps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubaddps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADDPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 5E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADDPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 5E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubaddps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubaddps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBADDPS xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 5E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBADDPS ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 5E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubaddps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubaddps_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubaddps_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubpd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 6D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 6D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubpd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 6D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 6D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubpd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBPD xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 6D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBPD ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 6D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubpd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubpd_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubpd_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 6C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 6C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 6C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 6C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubps instruction.<br/>
		/// <br/>
		/// <c>VFMSUBPS xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 6C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFMSUBPS ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 6C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfmsubps_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubps_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubsd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubsd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubsd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubsd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubsd instruction.<br/>
		/// <br/>
		/// <c>VFMSUBSD xmm1, xmm2, xmm3, xmm4/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 6F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubsd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubsd_xmm_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubss instruction.<br/>
		/// <br/>
		/// <c>VFMSUBSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubss(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubss instruction.<br/>
		/// <br/>
		/// <c>VFMSUBSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 6E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubss(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfmsubss instruction.<br/>
		/// <br/>
		/// <c>VFMSUBSS xmm1, xmm2, xmm3, xmm4/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 6E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfmsubss(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfmsubss_xmm_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfmsubss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmadd132pd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmadd132pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd132pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132pd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmadd132pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd132pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132ps instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmadd132ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd132ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132ps instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 9C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmadd132ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd132ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132sd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 9D /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd132sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132sd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 9D /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 9D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd132sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132ss instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 9D /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd132ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd132ss instruction.<br/>
		/// <br/>
		/// <c>VFNMADD132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 9D /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 9D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd132ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd132ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213pd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmadd213pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd213pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213pd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmadd213pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd213pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213ps instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmadd213ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd213ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213ps instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 AC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmadd213ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd213ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213sd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 AD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd213sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213sd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 AD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 AD /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd213sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213ss instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 AD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd213ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd213ss instruction.<br/>
		/// <br/>
		/// <c>VFNMADD213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 AD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 AD /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd213ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd213ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231pd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmadd231pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd231pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231pd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmadd231pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd231pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231ps instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmadd231ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd231ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231ps instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 BC /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmadd231ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd231ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231sd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 BD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd231sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231sd instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 BD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 BD /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd231sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231ss instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 BD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmadd231ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmadd231ss instruction.<br/>
		/// <br/>
		/// <c>VFNMADD231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 BD /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 BD /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmadd231ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmadd231ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmadd231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmaddpd instruction.<br/>
		/// <br/>
		/// <c>VFNMADDPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 79 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADDPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 79 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddpd instruction.<br/>
		/// <br/>
		/// <c>VFNMADDPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 79 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADDPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 79 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddpd instruction.<br/>
		/// <br/>
		/// <c>VFNMADDPD xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 79 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADDPD ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 79 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddpd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmaddpd_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddpd_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddps instruction.<br/>
		/// <br/>
		/// <c>VFNMADDPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 78 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADDPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 78 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddps instruction.<br/>
		/// <br/>
		/// <c>VFNMADDPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 78 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADDPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 78 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddps instruction.<br/>
		/// <br/>
		/// <c>VFNMADDPS xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 78 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMADDPS ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 78 /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmaddps_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddps_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddsd instruction.<br/>
		/// <br/>
		/// <c>VFNMADDSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7B /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddsd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddsd instruction.<br/>
		/// <br/>
		/// <c>VFNMADDSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7B /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddsd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddsd instruction.<br/>
		/// <br/>
		/// <c>VFNMADDSD xmm1, xmm2, xmm3, xmm4/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 7B /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddsd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddsd_xmm_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddss instruction.<br/>
		/// <br/>
		/// <c>VFNMADDSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7A /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddss(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddss instruction.<br/>
		/// <br/>
		/// <c>VFNMADDSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7A /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddss(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmaddss instruction.<br/>
		/// <br/>
		/// <c>VFNMADDSS xmm1, xmm2, xmm3, xmm4/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 7A /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmaddss(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmaddss_xmm_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmaddss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsub132pd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsub132pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub132pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132pd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmsub132pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub132pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132ps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsub132ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub132ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132ps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 9E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmsub132ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub132ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132sd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 9F /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub132sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132sd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 9F /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 9F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub132sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132ss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 9F /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub132ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub132ss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB132SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 9F /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 9F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub132ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub132ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub132ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213pd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsub213pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub213pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213pd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmsub213pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub213pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213ps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsub213ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub213ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213ps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 AE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmsub213ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub213ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213sd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 AF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub213sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213sd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 AF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 AF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub213sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213ss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 AF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub213ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub213ss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB213SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 AF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 AF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub213ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub213ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub213ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231pd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsub231pd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub231pd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231pd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231PD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmsub231pd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub231pd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231ps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsub231ps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub231ps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231ps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231PS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 BE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vfnmsub231ps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub231ps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231sd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 BF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub231sd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231sd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231SD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W1 BF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 BF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub231sd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231ss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 BF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsub231ss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsub231ss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUB231SS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F38.W0 BF /r</c><br/>
		/// <br/>
		/// <c>FMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 BF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsub231ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vfnmsub231ss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsub231ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vfnmsubpd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 7D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUBPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 7D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubpd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubpd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBPD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 7D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUBPD ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 7D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubpd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubpd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBPD xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 7D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUBPD ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 7D /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubpd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsubpd_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubpd_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubpd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 7C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUBPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 7C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubps(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBPS xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 7C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUBPS ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 7C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubps instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBPS xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W1 7C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFNMSUBPS ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W1 7C /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vfnmsubps_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubps_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubps), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubsd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubsd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubsd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBSD xmm1, xmm2, xmm3/m64, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubsd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubsd instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBSD xmm1, xmm2, xmm3, xmm4/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 7F /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubsd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubsd_xmm_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubsd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubss(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBSS xmm1, xmm2, xmm3/m32, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W0 7E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubss(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfnmsubss instruction.<br/>
		/// <br/>
		/// <c>VFNMSUBSS xmm1, xmm2, xmm3, xmm4/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F3A.W1 7E /r /is4</c><br/>
		/// <br/>
		/// <c>FMA4</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfnmsubss(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vfnmsubss_xmm_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfnmsubss), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vfpclasspd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclasspd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vfpclasspd_k_k1_zmmm512b64_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vfpclasspd_k_k1_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vfpclasspd_k_k1_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclasspd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclasspd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclasspd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsK() && src.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vfpclasspd_k_k1_zmmm512b64_imm8;
			} else if (dst.IsK() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vfpclasspd_k_k1_ymmm256b64_imm8;
			} else if (dst.IsK() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vfpclasspd_k_k1_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclasspd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclassps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclassps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vfpclassps_k_k1_zmmm512b32_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vfpclassps_k_k1_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vfpclassps_k_k1_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclassps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclassps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclassps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsK() && src.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vfpclassps_k_k1_zmmm512b32_imm8;
			} else if (dst.IsK() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vfpclassps_k_k1_ymmm256b32_imm8;
			} else if (dst.IsK() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vfpclassps_k_k1_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclassps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclasssd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclasssd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.EVEX_Vfpclasssd_k_k1_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclasssd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclasssd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclasssd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.EVEX_Vfpclasssd_k_k1_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclasssd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclassss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclassss(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.EVEX_Vfpclassss_k_k1_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclassss), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfpclassss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vfpclassss(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsK()) {
				op = Code.EVEX_Vfpclassss_k_k1_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vfpclassss), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vfrczpd instruction.<br/>
		/// <br/>
		/// <c>VFRCZPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 81 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFRCZPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>XOP.256.X9.W0 81 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczpd(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vfrczpd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vfrczpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczpd instruction.<br/>
		/// <br/>
		/// <c>VFRCZPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 81 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFRCZPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>XOP.256.X9.W0 81 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vfrczpd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vfrczpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczps instruction.<br/>
		/// <br/>
		/// <c>VFRCZPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 80 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFRCZPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>XOP.256.X9.W0 80 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vfrczps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vfrczps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczps instruction.<br/>
		/// <br/>
		/// <c>VFRCZPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 80 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VFRCZPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>XOP.256.X9.W0 80 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vfrczps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vfrczps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczsd instruction.<br/>
		/// <br/>
		/// <c>VFRCZSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 83 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vfrczsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczsd instruction.<br/>
		/// <br/>
		/// <c>VFRCZSD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 83 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vfrczsd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczss instruction.<br/>
		/// <br/>
		/// <c>VFRCZSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 82 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vfrczss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vfrczss instruction.<br/>
		/// <br/>
		/// <c>VFRCZSS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 82 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vfrczss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vfrczss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vfrczss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgatherdpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERDPD xmm1 {k1}, vm32x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 92 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERDPD ymm1 {k1}, vm32x</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 92 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERDPD zmm1 {k1}, vm32y</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 92 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherdpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgatherdpd_zmm_k1_vm32y;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgatherdpd_ymm_k1_vm32x;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgatherdpd_xmm_k1_vm32x;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherdpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgatherdpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERDPD xmm1, vm32x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 92 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERDPD ymm1, vm32x, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 92 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherdpd(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vgatherdpd_ymm_vm32x_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vgatherdpd_xmm_vm32x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherdpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgatherdps instruction.<br/>
		/// <br/>
		/// <c>VGATHERDPS xmm1 {k1}, vm32x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 92 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERDPS ymm1 {k1}, vm32y</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 92 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERDPS zmm1 {k1}, vm32z</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 92 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherdps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgatherdps_zmm_k1_vm32z;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgatherdps_ymm_k1_vm32y;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgatherdps_xmm_k1_vm32x;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherdps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgatherdps instruction.<br/>
		/// <br/>
		/// <c>VGATHERDPS xmm1, vm32x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 92 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERDPS ymm1, vm32y, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 92 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherdps(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vgatherdps_ymm_vm32y_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vgatherdps_xmm_vm32x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherdps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgatherpf0dpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF0DPD vm32y {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C6 /1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf0dpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf0dpd_vm32y_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf0dps instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF0DPS vm32z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C6 /1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf0dps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf0dps_vm32z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf0qpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF0QPD vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C7 /1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf0qpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf0qpd_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf0qps instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF0QPS vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C7 /1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf0qps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf0qps_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf1dpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF1DPD vm32y {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C6 /2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf1dpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf1dpd_vm32y_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf1dps instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF1DPS vm32z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C6 /2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf1dps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf1dps_vm32z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf1qpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF1QPD vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C7 /2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf1qpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf1qpd_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherpf1qps instruction.<br/>
		/// <br/>
		/// <c>VGATHERPF1QPS vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C7 /2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherpf1qps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vgatherpf1qps_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vgatherqpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERQPD xmm1 {k1}, vm64x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 93 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERQPD ymm1 {k1}, vm64y</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 93 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERQPD zmm1 {k1}, vm64z</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 93 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherqpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgatherqpd_zmm_k1_vm64z;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgatherqpd_ymm_k1_vm64y;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgatherqpd_xmm_k1_vm64x;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherqpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgatherqpd instruction.<br/>
		/// <br/>
		/// <c>VGATHERQPD xmm1, vm64x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 93 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERQPD ymm1, vm64y, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 93 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherqpd(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vgatherqpd_ymm_vm64y_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vgatherqpd_xmm_vm64x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherqpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgatherqps instruction.<br/>
		/// <br/>
		/// <c>VGATHERQPS xmm1 {k1}, vm64x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 93 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERQPS xmm1 {k1}, vm64y</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 93 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERQPS ymm1 {k1}, vm64z</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 93 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherqps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vgatherqps_ymm_k1_vm64z;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vgatherqps_xmm_k1_vm64y;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vgatherqps_xmm_k1_vm64x;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherqps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgatherqps instruction.<br/>
		/// <br/>
		/// <c>VGATHERQPS xmm1, vm64x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 93 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGATHERQPS xmm1, vm64y, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 93 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgatherqps(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.VEX_Vgatherqps_xmm_vm64y_xmm;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vgatherqps_xmm_vm64x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vgatherqps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgetexppd instruction.<br/>
		/// <br/>
		/// <c>VGETEXPPD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexppd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetexppd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexppd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexppd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgetexppd instruction.<br/>
		/// <br/>
		/// <c>VGETEXPPD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexppd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetexppd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexppd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexppd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgetexpps instruction.<br/>
		/// <br/>
		/// <c>VGETEXPPS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexpps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetexpps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexpps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexpps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgetexpps instruction.<br/>
		/// <br/>
		/// <c>VGETEXPPS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGETEXPPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 42 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexpps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetexpps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexpps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexpps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vgetexpsd instruction.<br/>
		/// <br/>
		/// <c>VGETEXPSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 43 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexpsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexpsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgetexpsd instruction.<br/>
		/// <br/>
		/// <c>VGETEXPSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 43 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexpsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexpsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgetexpss instruction.<br/>
		/// <br/>
		/// <c>VGETEXPSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 43 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexpss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexpss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgetexpss instruction.<br/>
		/// <br/>
		/// <c>VGETEXPSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 43 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgetexpss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetexpss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgetmantpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vgetmantpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vgetmantps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vgetmantps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vgetmantsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantsd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgetmantsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantsd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgetmantss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantss(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgetmantss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgetmantss(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vgetmantss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgf2p8affineinvqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgf2p8affineinvqb(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgf2p8affineinvqb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgf2p8affineinvqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgf2p8affineinvqb(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgf2p8affineinvqb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgf2p8affineqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgf2p8affineqb(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgf2p8affineqb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgf2p8affineqb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vgf2p8affineqb(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vgf2p8affineqb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vgf2p8mulb instruction.<br/>
		/// <br/>
		/// <c>VGF2P8MULB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGF2P8MULB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGF2P8MULB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX512F and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgf2p8mulb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vgf2p8mulb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vgf2p8mulb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vgf2p8mulb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vgf2p8mulb instruction.<br/>
		/// <br/>
		/// <c>VGF2P8MULB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGF2P8MULB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGF2P8MULB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGF2P8MULB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VGF2P8MULB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 CF /r</c><br/>
		/// <br/>
		/// <c>AVX512F and GFNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vgf2p8mulb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vgf2p8mulb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vgf2p8mulb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vgf2p8mulb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhaddpd instruction.<br/>
		/// <br/>
		/// <c>VHADDPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHADDPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhaddpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhaddpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhaddpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhaddpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhaddpd instruction.<br/>
		/// <br/>
		/// <c>VHADDPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHADDPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhaddpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhaddpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhaddpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhaddpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhaddps instruction.<br/>
		/// <br/>
		/// <c>VHADDPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHADDPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhaddps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhaddps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhaddps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhaddps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhaddps instruction.<br/>
		/// <br/>
		/// <c>VHADDPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHADDPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG 7C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhaddps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhaddps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhaddps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhaddps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhsubpd instruction.<br/>
		/// <br/>
		/// <c>VHSUBPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHSUBPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhsubpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhsubpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhsubpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhsubpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhsubpd instruction.<br/>
		/// <br/>
		/// <c>VHSUBPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHSUBPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhsubpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhsubpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhsubpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhsubpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhsubps instruction.<br/>
		/// <br/>
		/// <c>VHSUBPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHSUBPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhsubps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhsubps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhsubps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhsubps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vhsubps instruction.<br/>
		/// <br/>
		/// <c>VHSUBPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VHSUBPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG 7D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vhsubps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vhsubps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vhsubps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vhsubps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vinsertf128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf128(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vinsertf128_ymm_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf128(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vinsertf128_ymm_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf32x4(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf32x4(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf32x8(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf32x8), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf32x8(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf32x8), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf64x2(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf64x2(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf64x4(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf64x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertf64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertf64x4(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertf64x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti128(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vinserti128_ymm_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti128(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vinserti128_ymm_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti32x4(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti32x4(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti32x8(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti32x8), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti32x8 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti32x8(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti32x8), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti64x2(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti64x2(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti64x4(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti64x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinserti64x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinserti64x4(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinserti64x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vinsertps_xmm_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vinsertps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vinsertps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vinsertps_xmm_xmm_xmmm32_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vinsertps_xmm_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vinsertps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vlddqu instruction.<br/>
		/// <br/>
		/// <c>VLDDQU xmm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG F0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VLDDQU ymm1, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG F0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vlddqu(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vlddqu_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vlddqu_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vlddqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vlddqu instruction.<br/>
		/// <br/>
		/// <c>VLDDQU xmm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG F0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VLDDQU ymm1, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG F0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vlddqu(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vlddqu_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vlddqu_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vlddqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vldmxcsr instruction.<br/>
		/// <br/>
		/// <c>VLDMXCSR m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F.WIG AE /2</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vldmxcsr(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.VEX_Vldmxcsr_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmaskmovpd instruction.<br/>
		/// <br/>
		/// <c>VMASKMOVPD xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPD ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPD m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaskmovpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmaskmovpd_ymm_ymm_m256;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vmaskmovpd_m256_ymm_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vmaskmovpd_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaskmovpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaskmovpd instruction.<br/>
		/// <br/>
		/// <c>VMASKMOVPD m128, xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPD m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaskmovpd(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vmaskmovpd_m256_ymm_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vmaskmovpd_m128_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaskmovpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaskmovpd instruction.<br/>
		/// <br/>
		/// <c>VMASKMOVPD xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPD ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaskmovpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmaskmovpd_ymm_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmaskmovpd_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaskmovpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaskmovps instruction.<br/>
		/// <br/>
		/// <c>VMASKMOVPS xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPS ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPS m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaskmovps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmaskmovps_ymm_ymm_m256;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vmaskmovps_m256_ymm_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vmaskmovps_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaskmovps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaskmovps instruction.<br/>
		/// <br/>
		/// <c>VMASKMOVPS m128, xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPS m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaskmovps(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vmaskmovps_m256_ymm_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vmaskmovps_m128_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaskmovps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaskmovps instruction.<br/>
		/// <br/>
		/// <c>VMASKMOVPS xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMASKMOVPS ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaskmovps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmaskmovps_ymm_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmaskmovps_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaskmovps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxpd instruction.<br/>
		/// <br/>
		/// <c>VMAXPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmaxpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmaxpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxpd instruction.<br/>
		/// <br/>
		/// <c>VMAXPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmaxpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmaxpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxps instruction.<br/>
		/// <br/>
		/// <c>VMAXPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmaxps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmaxps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxps instruction.<br/>
		/// <br/>
		/// <c>VMAXPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmaxps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmaxps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxsd instruction.<br/>
		/// <br/>
		/// <c>VMAXSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmaxsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxsd instruction.<br/>
		/// <br/>
		/// <c>VMAXSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmaxsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxss instruction.<br/>
		/// <br/>
		/// <c>VMAXSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmaxss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmaxss instruction.<br/>
		/// <br/>
		/// <c>VMAXSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMAXSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 5F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmaxss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmaxss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vmaxss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmcall instruction.<br/>
		/// <br/>
		/// <c>VMCALL</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C1</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmcall() {
			Code op;
			op = Code.Vmcall;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmclear instruction.<br/>
		/// <br/>
		/// <c>VMCLEAR m64</c><br/>
		/// <br/>
		/// <c>66 0F C7 /6</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmclear(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Vmclear_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmclear), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmclear instruction.<br/>
		/// <br/>
		/// <c>VMCLEAR m64</c><br/>
		/// <br/>
		/// <c>66 0F C7 /6</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmclear(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Vmclear_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmclear), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmfunc instruction.<br/>
		/// <br/>
		/// <c>VMFUNC</c><br/>
		/// <br/>
		/// <c>NP 0F 01 D4</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmfunc() {
			Code op;
			op = Code.Vmfunc;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vminpd instruction.<br/>
		/// <br/>
		/// <c>VMINPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vminpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vminpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vminpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminpd instruction.<br/>
		/// <br/>
		/// <c>VMINPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vminpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vminpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vminpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminps instruction.<br/>
		/// <br/>
		/// <c>VMINPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vminps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vminps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vminps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminps instruction.<br/>
		/// <br/>
		/// <c>VMINPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vminps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vminps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vminps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vminps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vminps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminsd instruction.<br/>
		/// <br/>
		/// <c>VMINSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vminsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vminsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminsd instruction.<br/>
		/// <br/>
		/// <c>VMINSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vminsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vminsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminss instruction.<br/>
		/// <br/>
		/// <c>VMINSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vminss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vminss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vminss instruction.<br/>
		/// <br/>
		/// <c>VMINSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMINSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 5D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vminss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vminss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vminss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmlaunch instruction.<br/>
		/// <br/>
		/// <c>VMLAUNCH</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C2</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmlaunch() {
			Code op;
			op = Code.Vmlaunch;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmload instruction.<br/>
		/// <br/>
		/// <c>VMLOAD</c><br/>
		/// <br/>
		/// <c>a16 0F 01 DA</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMLOAD</c><br/>
		/// <br/>
		/// <c>a32 0F 01 DA</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMLOAD</c><br/>
		/// <br/>
		/// <c>0F 01 DA</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmload() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmloadq;
			} else if (Bitness == 32) {
				op = Code.Vmloadd;
			} else if (Bitness == 16) {
				op = Code.Vmloadw;
			} else {
				throw NoOpCodeFoundFor(nameof(vmload));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmmcall instruction.<br/>
		/// <br/>
		/// <c>VMMCALL</c><br/>
		/// <br/>
		/// <c>0F 01 D9</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmmcall() {
			Code op;
			op = Code.Vmmcall;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmovapd instruction.<br/>
		/// <br/>
		/// <c>VMOVAPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovapd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovapd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovapd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovapd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovapd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovapd instruction.<br/>
		/// <br/>
		/// <c>VMOVAPD xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD ymm2/m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovapd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovapd_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && PreferVex) {
				op = Code.VEX_Vmovapd_ymmm256_ymm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovapd_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovapd_xmmm128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovapd_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovapd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovapd instruction.<br/>
		/// <br/>
		/// <c>VMOVAPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovapd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovapd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovapd_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovapd_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovapd_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovapd_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovapd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovaps instruction.<br/>
		/// <br/>
		/// <c>VMOVAPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovaps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovaps_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovaps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovaps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovaps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovaps instruction.<br/>
		/// <br/>
		/// <c>VMOVAPS xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS ymm2/m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovaps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovaps_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && PreferVex) {
				op = Code.VEX_Vmovaps_ymmm256_ymm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovaps_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovaps_xmmm128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovaps_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovaps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovaps instruction.<br/>
		/// <br/>
		/// <c>VMOVAPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVAPS zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovaps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovaps_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovaps_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovaps_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovaps_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovaps_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovaps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovd instruction.<br/>
		/// <br/>
		/// <c>VMOVD xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W0 6E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVD r/m32, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovd_xmm_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vmovd_rm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovd instruction.<br/>
		/// <br/>
		/// <c>VMOVD r/m32, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVD r/m32, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr && PreferVex) {
				op = Code.VEX_Vmovd_rm32_xmm;
			} else if (dst.Size == MemoryOperandSize.DwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovd_rm32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovd instruction.<br/>
		/// <br/>
		/// <c>VMOVD xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W0 6E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVD xmm1, r/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 6E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovd_xmm_rm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovd_xmm_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovddup instruction.<br/>
		/// <br/>
		/// <c>VMOVDDUP xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDDUP ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDDUP zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovddup(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovddup_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovddup_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovddup_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovddup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovddup instruction.<br/>
		/// <br/>
		/// <c>VMOVDDUP xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.F2.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDDUP ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F2.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDDUP xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDDUP ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDDUP zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovddup(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovddup_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovddup_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovddup_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovddup_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovddup_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovddup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmovdqa_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovdqa_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 7F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA ymm2/m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 7F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.VEX_Vmovdqa_ymmm256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vmovdqa_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmovdqa_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovdqa_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa32 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA32 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA32 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA32 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa32(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqa32_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqa32_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqa32_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa32 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA32 xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA32 ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA32 zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa32(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovdqa32_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vmovdqa32_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vmovdqa32_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa32 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA32 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA32 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA32 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa32(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqa32_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqa32_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqa32_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa64 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA64 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA64 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA64 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa64(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqa64_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqa64_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqa64_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa64), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa64 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA64 xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA64 ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA64 zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa64(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovdqa64_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vmovdqa64_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vmovdqa64_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa64), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqa64 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQA64 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA64 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQA64 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqa64(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqa64_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqa64_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqa64_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqa64), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmovdqu_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovdqu_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 7F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU ymm2/m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 7F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.VEX_Vmovdqu_ymmm256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vmovdqu_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 6F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmovdqu_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovdqu_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu16 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU16 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU16 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU16 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu16(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu16_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu16_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu16_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu16), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu16 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU16 xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU16 ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU16 zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu16(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovdqu16_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vmovdqu16_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vmovdqu16_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu16), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu16 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU16 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU16 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU16 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu16(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu16_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu16_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu16_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu16), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu32 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU32 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU32 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU32 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu32(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu32_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu32_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu32_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu32 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU32 xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU32 ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU32 zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu32(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovdqu32_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vmovdqu32_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vmovdqu32_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu32 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU32 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU32 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU32 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu32(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu32_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu32_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu32_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu32), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu64 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU64 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU64 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU64 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu64(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu64_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu64_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu64_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu64), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu64 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU64 xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU64 ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU64 zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu64(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovdqu64_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vmovdqu64_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vmovdqu64_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu64), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu64 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU64 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU64 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU64 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W1 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu64(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu64_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu64_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu64_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu64), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu8 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU8 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU8 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU8 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu8(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu8_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu8_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu8_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu8 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU8 xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU8 ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU8 zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu8(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovdqu8_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vmovdqu8_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vmovdqu8_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovdqu8 instruction.<br/>
		/// <br/>
		/// <c>VMOVDQU8 xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F2.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU8 ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F2.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVDQU8 zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F2.0F.W0 6F /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovdqu8(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovdqu8_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vmovdqu8_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vmovdqu8_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovdqu8), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovhlps instruction.<br/>
		/// <br/>
		/// <c>VMOVHLPS xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVHLPS xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhlps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovhlps_xmm_xmm_xmm;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovhlps_xmm_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhlps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovhpd instruction.<br/>
		/// <br/>
		/// <c>VMOVHPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovhpd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovhpd instruction.<br/>
		/// <br/>
		/// <c>VMOVHPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVHPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 17 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovhpd_m64_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovhpd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovhpd instruction.<br/>
		/// <br/>
		/// <c>VMOVHPD xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovhpd_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovhpd instruction.<br/>
		/// <br/>
		/// <c>VMOVHPD xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVHPD xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovhpd_xmm_xmm_m64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovhpd_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovhps instruction.<br/>
		/// <br/>
		/// <c>VMOVHPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovhps_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovhps instruction.<br/>
		/// <br/>
		/// <c>VMOVHPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVHPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 17 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovhps_m64_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovhps_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovhps instruction.<br/>
		/// <br/>
		/// <c>VMOVHPS xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovhps_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovhps instruction.<br/>
		/// <br/>
		/// <c>VMOVHPS xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVHPS xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovhps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovhps_xmm_xmm_m64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovhps_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovhps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovlhps instruction.<br/>
		/// <br/>
		/// <c>VMOVLHPS xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVLHPS xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlhps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovlhps_xmm_xmm_xmm;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovlhps_xmm_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlhps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovlpd instruction.<br/>
		/// <br/>
		/// <c>VMOVLPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 13 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovlpd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovlpd instruction.<br/>
		/// <br/>
		/// <c>VMOVLPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 13 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVLPD m64, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovlpd_m64_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovlpd_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovlpd instruction.<br/>
		/// <br/>
		/// <c>VMOVLPD xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovlpd_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovlpd instruction.<br/>
		/// <br/>
		/// <c>VMOVLPD xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVLPD xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovlpd_xmm_xmm_m64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovlpd_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovlps instruction.<br/>
		/// <br/>
		/// <c>VMOVLPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 13 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovlps_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovlps instruction.<br/>
		/// <br/>
		/// <c>VMOVLPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 13 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVLPS m64, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovlps_m64_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovlps_m64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovlps instruction.<br/>
		/// <br/>
		/// <c>VMOVLPS xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovlps_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovlps instruction.<br/>
		/// <br/>
		/// <c>VMOVLPS xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVLPS xmm2, xmm1, m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovlps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovlps_xmm_xmm_m64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovlps_xmm_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovlps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovmskpd instruction.<br/>
		/// <br/>
		/// <c>VMOVMSKPD r32, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVMSKPD r64, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W1 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVMSKPD r32, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVMSKPD r64, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.W1 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmovmskpd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsYMM()) {
				op = Code.VEX_Vmovmskpd_r64_ymm;
			} else if (dst.IsGPR64() && src.IsXMM()) {
				op = Code.VEX_Vmovmskpd_r64_xmm;
			} else if (dst.IsGPR32() && src.IsYMM()) {
				op = Code.VEX_Vmovmskpd_r32_ymm;
			} else if (dst.IsGPR32() && src.IsXMM()) {
				op = Code.VEX_Vmovmskpd_r32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovmskpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovmskps instruction.<br/>
		/// <br/>
		/// <c>VMOVMSKPS r32, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVMSKPS r64, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.W1 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVMSKPS r32, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVMSKPS r64, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.W1 50 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmovmskps(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsYMM()) {
				op = Code.VEX_Vmovmskps_r64_ymm;
			} else if (dst.IsGPR64() && src.IsXMM()) {
				op = Code.VEX_Vmovmskps_r64_xmm;
			} else if (dst.IsGPR32() && src.IsYMM()) {
				op = Code.VEX_Vmovmskps_r32_ymm;
			} else if (dst.IsGPR32() && src.IsXMM()) {
				op = Code.VEX_Vmovmskps_r32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovmskps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntdq instruction.<br/>
		/// <br/>
		/// <c>VMOVNTDQ m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E7 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQ m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E7 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQ m512, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 E7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vmovntdq_m512_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vmovntdq_m256_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vmovntdq_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntdq instruction.<br/>
		/// <br/>
		/// <c>VMOVNTDQ m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E7 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQ m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E7 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQ m128, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 E7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQ m256, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 E7 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQ m512, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 E7 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntdq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vmovntdq_m512_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vmovntdq_m256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vmovntdq_m256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vmovntdq_m128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vmovntdq_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntdqa instruction.<br/>
		/// <br/>
		/// <c>VMOVNTDQA xmm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQA ymm1, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 2A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQA zmm1, m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntdqa(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovntdqa_zmm_m512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovntdqa_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovntdqa_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntdqa instruction.<br/>
		/// <br/>
		/// <c>VMOVNTDQA xmm1, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 2A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQA ymm1, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 2A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQA xmm1, m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQA ymm1, m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTDQA zmm1, m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntdqa(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovntdqa_zmm_m512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovntdqa_ymm_m256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovntdqa_ymm_m256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovntdqa_xmm_m128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovntdqa_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntdqa), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntpd instruction.<br/>
		/// <br/>
		/// <c>VMOVNTPD m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPD m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPD m512, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vmovntpd_m512_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vmovntpd_m256_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vmovntpd_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntpd instruction.<br/>
		/// <br/>
		/// <c>VMOVNTPD m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPD m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPD m128, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPD m256, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPD m512, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vmovntpd_m512_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vmovntpd_m256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vmovntpd_m256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vmovntpd_m128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vmovntpd_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntps instruction.<br/>
		/// <br/>
		/// <c>VMOVNTPS m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPS m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPS m512, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vmovntps_m512_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vmovntps_m256_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vmovntps_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovntps instruction.<br/>
		/// <br/>
		/// <c>VMOVNTPS m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPS m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPS m128, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPS m256, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVNTPS m512, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovntps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vmovntps_m512_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vmovntps_m256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vmovntps_m256_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vmovntps_m128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vmovntps_m128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovntps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovq instruction.<br/>
		/// <br/>
		/// <c>VMOVQ xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W1 6E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVQ r/m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 7E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vmovq_xmm_xmmm64;
			} else if (dst.IsXMM() && src.IsGPR64()) {
				op = Code.VEX_Vmovq_xmm_rm64;
			} else if (dst.IsGPR64()) {
				op = Code.VEX_Vmovq_rm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovq instruction.<br/>
		/// <br/>
		/// <c>VMOVQ r/m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVQ r/m64, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVQ xmm1/m64, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVQ xmm1/m64, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 D6 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovq_xmmm64_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovq_xmmm64_xmm;
			} else if (dst.Size == MemoryOperandSize.QwordPtr && PreferVex) {
				op = Code.VEX_Vmovq_rm64_xmm;
			} else if (dst.Size == MemoryOperandSize.QwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovq_rm64_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovq instruction.<br/>
		/// <br/>
		/// <c>VMOVQ xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W1 6E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVQ xmm1, r/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 6E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VMOVQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 7E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovq_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovq_xmm_xmmm64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.VEX_Vmovq_xmm_rm64;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.EVEX_Vmovq_xmm_rm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovsd instruction.<br/>
		/// <br/>
		/// <c>VMOVSD xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovsd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovsd_xmm_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovsd instruction.<br/>
		/// <br/>
		/// <c>VMOVSD m64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSD m64 {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovsd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovsd_m64_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovsd_m64_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovsd instruction.<br/>
		/// <br/>
		/// <c>VMOVSD xmm1, m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSD xmm1 {k1}{z}, m64</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovsd_xmm_m64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovsd_xmm_k1z_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovsd instruction.<br/>
		/// <br/>
		/// <c>VMOVSD xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSD xmm1 {k1}{z}, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSD xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSD xmm1 {k1}{z}, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovsd_xmm_xmm_xmm;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovsd_xmm_k1z_xmm_xmm;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovsd_xmm_xmm_xmm_0F11;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovsd_xmm_k1z_xmm_xmm_0F11;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovshdup instruction.<br/>
		/// <br/>
		/// <c>VMOVSHDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSHDUP ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSHDUP zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovshdup(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovshdup_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovshdup_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovshdup_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovshdup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovshdup instruction.<br/>
		/// <br/>
		/// <c>VMOVSHDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSHDUP ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 16 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSHDUP xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSHDUP ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSHDUP zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovshdup(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovshdup_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovshdup_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovshdup_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovshdup_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovshdup_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovshdup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovsldup instruction.<br/>
		/// <br/>
		/// <c>VMOVSLDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSLDUP ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSLDUP zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovsldup(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovsldup_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovsldup_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovsldup_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovsldup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovsldup instruction.<br/>
		/// <br/>
		/// <c>VMOVSLDUP xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.F3.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSLDUP ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.F3.0F.WIG 12 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSLDUP xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSLDUP ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSLDUP zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovsldup(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovsldup_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovsldup_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovsldup_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovsldup_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovsldup_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovsldup), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovss instruction.<br/>
		/// <br/>
		/// <c>VMOVSS xmm1, m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmovss_xmm_m32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovss instruction.<br/>
		/// <br/>
		/// <c>VMOVSS m32, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSS m32 {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovss(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovss_m32_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovss_m32_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovss instruction.<br/>
		/// <br/>
		/// <c>VMOVSS xmm1, m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSS xmm1 {k1}{z}, m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovss_xmm_m32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovss_xmm_k1z_m32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovss instruction.<br/>
		/// <br/>
		/// <c>VMOVSS xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSS xmm1 {k1}{z}, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSS xmm1, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVSS xmm1 {k1}{z}, xmm2, xmm3</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovss_xmm_xmm_xmm;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovss_xmm_k1z_xmm_xmm;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovss_xmm_xmm_xmm_0F11;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovss_xmm_k1z_xmm_xmm_0F11;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmovupd instruction.<br/>
		/// <br/>
		/// <c>VMOVUPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovupd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovupd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovupd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovupd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovupd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovupd instruction.<br/>
		/// <br/>
		/// <c>VMOVUPD xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD ymm2/m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovupd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovupd_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && PreferVex) {
				op = Code.VEX_Vmovupd_ymmm256_ymm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovupd_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovupd_xmmm128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovupd_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovupd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovupd instruction.<br/>
		/// <br/>
		/// <c>VMOVUPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovupd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovupd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovupd_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovupd_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovupd_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovupd_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovupd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovups instruction.<br/>
		/// <br/>
		/// <c>VMOVUPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovups(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovups_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmovups_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmovups_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovups), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovups instruction.<br/>
		/// <br/>
		/// <c>VMOVUPS xmm2/m128, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS ymm2/m256, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 11 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS xmm2/m128 {k1}{z}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS ymm2/m256 {k1}{z}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS zmm2/m512 {k1}{z}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovups(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vmovups_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && PreferVex) {
				op = Code.VEX_Vmovups_ymmm256_ymm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovups_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && PreferVex) {
				op = Code.VEX_Vmovups_xmmm128_xmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && !PreferVex) {
				op = Code.EVEX_Vmovups_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovups), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmovups instruction.<br/>
		/// <br/>
		/// <c>VMOVUPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 10 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMOVUPS zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmovups(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmovups_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmovups_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmovups_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmovups_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmovups_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmovups), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmpsadbw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vmpsadbw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vmpsadbw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vmpsadbw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vmpsadbw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vmpsadbw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vmptrld instruction.<br/>
		/// <br/>
		/// <c>VMPTRLD m64</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /6</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmptrld(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Vmptrld_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmptrld), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmptrld instruction.<br/>
		/// <br/>
		/// <c>VMPTRLD m64</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /6</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmptrld(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Vmptrld_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmptrld), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmptrst instruction.<br/>
		/// <br/>
		/// <c>VMPTRST m64</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /7</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmptrst(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Vmptrst_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmptrst), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmptrst instruction.<br/>
		/// <br/>
		/// <c>VMPTRST m64</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /7</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmptrst(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Vmptrst_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmptrst), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmread instruction.<br/>
		/// <br/>
		/// <c>VMREAD r/m32, r32</c><br/>
		/// <br/>
		/// <c>NP 0F 78 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMREAD r/m64, r64</c><br/>
		/// <br/>
		/// <c>NP 0F 78 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmread(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmread_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmread), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmread instruction.<br/>
		/// <br/>
		/// <c>VMREAD r/m32, r32</c><br/>
		/// <br/>
		/// <c>NP 0F 78 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMREAD r/m64, r64</c><br/>
		/// <br/>
		/// <c>NP 0F 78 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmread(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Vmread_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmread), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmresume instruction.<br/>
		/// <br/>
		/// <c>VMRESUME</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C3</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmresume() {
			Code op;
			op = Code.Vmresume;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmrun instruction.<br/>
		/// <br/>
		/// <c>VMRUN</c><br/>
		/// <br/>
		/// <c>a16 0F 01 D8</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMRUN</c><br/>
		/// <br/>
		/// <c>a32 0F 01 D8</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMRUN</c><br/>
		/// <br/>
		/// <c>0F 01 D8</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmrun() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmrunq;
			} else if (Bitness == 32) {
				op = Code.Vmrund;
			} else if (Bitness == 16) {
				op = Code.Vmrunw;
			} else {
				throw NoOpCodeFoundFor(nameof(vmrun));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmsave instruction.<br/>
		/// <br/>
		/// <c>VMSAVE</c><br/>
		/// <br/>
		/// <c>a16 0F 01 DB</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMSAVE</c><br/>
		/// <br/>
		/// <c>a32 0F 01 DB</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMSAVE</c><br/>
		/// <br/>
		/// <c>0F 01 DB</c><br/>
		/// <br/>
		/// <c>SVM</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmsave() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmsaveq;
			} else if (Bitness == 32) {
				op = Code.Vmsaved;
			} else if (Bitness == 16) {
				op = Code.Vmsavew;
			} else {
				throw NoOpCodeFoundFor(nameof(vmsave));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmulpd instruction.<br/>
		/// <br/>
		/// <c>VMULPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmulpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmulpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulpd instruction.<br/>
		/// <br/>
		/// <c>VMULPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmulpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmulpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulps instruction.<br/>
		/// <br/>
		/// <c>VMULPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vmulps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vmulps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulps instruction.<br/>
		/// <br/>
		/// <c>VMULPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vmulps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmulps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulsd instruction.<br/>
		/// <br/>
		/// <c>VMULSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmulsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulsd instruction.<br/>
		/// <br/>
		/// <c>VMULSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmulsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulss instruction.<br/>
		/// <br/>
		/// <c>VMULSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vmulss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmulss instruction.<br/>
		/// <br/>
		/// <c>VMULSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 59 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VMULSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmulss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vmulss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vmulss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vmwrite instruction.<br/>
		/// <br/>
		/// <c>VMWRITE r32, r/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 79 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMWRITE r64, r/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 79 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmwrite(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmwrite), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmwrite instruction.<br/>
		/// <br/>
		/// <c>VMWRITE r32, r/m32</c><br/>
		/// <br/>
		/// <c>NP 0F 79 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>VMWRITE r64, r/m64</c><br/>
		/// <br/>
		/// <c>NP 0F 79 /r</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vmwrite(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vmwrite), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vmxoff instruction.<br/>
		/// <br/>
		/// <c>VMXOFF</c><br/>
		/// <br/>
		/// <c>NP 0F 01 C4</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmxoff() {
			Code op;
			op = Code.Vmxoff;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vmxon instruction.<br/>
		/// <br/>
		/// <c>VMXON m64</c><br/>
		/// <br/>
		/// <c>F3 0F C7 /6</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmxon(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Vmxon_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmxon), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vmxon instruction.<br/>
		/// <br/>
		/// <c>VMXON m64</c><br/>
		/// <br/>
		/// <c>F3 0F C7 /6</c><br/>
		/// <br/>
		/// <c>VMX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vmxon(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Vmxon_m64;
			} else {
				throw NoOpCodeFoundFor(nameof(vmxon), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vorpd instruction.<br/>
		/// <br/>
		/// <c>VORPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vorpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vorpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vorpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vorpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vorpd instruction.<br/>
		/// <br/>
		/// <c>VORPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vorpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vorpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vorpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vorpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vorps instruction.<br/>
		/// <br/>
		/// <c>VORPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vorps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vorps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vorps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vorps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vorps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vorps instruction.<br/>
		/// <br/>
		/// <c>VORPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 56 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 56 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vorps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vorps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vorps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vorps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vorps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vorps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vorps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpabsb instruction.<br/>
		/// <br/>
		/// <c>VPABSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSB ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSB zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsb(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsb_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpabsb_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpabsb_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsb instruction.<br/>
		/// <br/>
		/// <c>VPABSB xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSB ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSB xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSB ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSB zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 1C /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsb_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpabsb_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpabsb_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpabsb_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpabsb_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsd instruction.<br/>
		/// <br/>
		/// <c>VPABSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 1E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 1E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 1E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpabsd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpabsd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsd instruction.<br/>
		/// <br/>
		/// <c>VPABSD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 1E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 1E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 1E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 1E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 1E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpabsd_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpabsd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpabsd_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpabsd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsq instruction.<br/>
		/// <br/>
		/// <c>VPABSQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 1F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 1F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 1F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpabsq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpabsq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsq instruction.<br/>
		/// <br/>
		/// <c>VPABSQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 1F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 1F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 1F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpabsq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpabsq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsw instruction.<br/>
		/// <br/>
		/// <c>VPABSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSW ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSW zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsw_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpabsw_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpabsw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpabsw instruction.<br/>
		/// <br/>
		/// <c>VPABSW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSW ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSW xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSW ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPABSW zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 1D /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpabsw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpabsw_zmm_k1z_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpabsw_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpabsw_ymm_k1z_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpabsw_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpabsw_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpabsw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpackssdw instruction.<br/>
		/// <br/>
		/// <c>VPACKSSDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSDW zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 6B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpackssdw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpackssdw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpackssdw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpackssdw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpackssdw instruction.<br/>
		/// <br/>
		/// <c>VPACKSSDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSDW xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 6B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSDW ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 6B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSDW zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 6B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpackssdw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpackssdw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpackssdw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpackssdw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpacksswb instruction.<br/>
		/// <br/>
		/// <c>VPACKSSWB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSWB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSWB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpacksswb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpacksswb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpacksswb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpacksswb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpacksswb instruction.<br/>
		/// <br/>
		/// <c>VPACKSSWB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSWB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSWB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSWB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKSSWB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpacksswb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpacksswb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpacksswb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpacksswb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpackusdw instruction.<br/>
		/// <br/>
		/// <c>VPACKUSDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSDW zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpackusdw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpackusdw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpackusdw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpackusdw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpackusdw instruction.<br/>
		/// <br/>
		/// <c>VPACKUSDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 2B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSDW xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSDW ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSDW zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 2B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpackusdw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpackusdw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpackusdw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpackusdw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpackuswb instruction.<br/>
		/// <br/>
		/// <c>VPACKUSWB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSWB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSWB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpackuswb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpackuswb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpackuswb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpackuswb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpackuswb instruction.<br/>
		/// <br/>
		/// <c>VPACKUSWB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSWB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSWB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSWB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPACKUSWB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 67 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpackuswb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpackuswb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpackuswb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpackuswb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddb instruction.<br/>
		/// <br/>
		/// <c>VPADDB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddb instruction.<br/>
		/// <br/>
		/// <c>VPADDB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG FC /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddd instruction.<br/>
		/// <br/>
		/// <c>VPADDD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FE /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FE /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 FE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddd instruction.<br/>
		/// <br/>
		/// <c>VPADDD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FE /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FE /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 FE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 FE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 FE /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddq instruction.<br/>
		/// <br/>
		/// <c>VPADDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D4 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D4 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 D4 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddq instruction.<br/>
		/// <br/>
		/// <c>VPADDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D4 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D4 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 D4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 D4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 D4 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddsb instruction.<br/>
		/// <br/>
		/// <c>VPADDSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddsb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddsb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddsb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddsb instruction.<br/>
		/// <br/>
		/// <c>VPADDSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG EC /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddsb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddsb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddsb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddsw instruction.<br/>
		/// <br/>
		/// <c>VPADDSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddsw instruction.<br/>
		/// <br/>
		/// <c>VPADDSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG ED /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddsw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddsw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddusb instruction.<br/>
		/// <br/>
		/// <c>VPADDUSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddusb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddusb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddusb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddusb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddusb instruction.<br/>
		/// <br/>
		/// <c>VPADDUSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DC /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddusb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddusb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddusb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddusb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddusw instruction.<br/>
		/// <br/>
		/// <c>VPADDUSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddusw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddusw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddusw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddusw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddusw instruction.<br/>
		/// <br/>
		/// <c>VPADDUSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDUSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DD /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddusw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddusw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddusw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddusw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddw instruction.<br/>
		/// <br/>
		/// <c>VPADDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpaddw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpaddw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpaddw instruction.<br/>
		/// <br/>
		/// <c>VPADDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPADDW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG FD /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpaddw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpaddw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpaddw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpaddw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpaddw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpaddw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpaddw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpalignr instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpalignr(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpalignr_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpalignr_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpalignr), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpalignr instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpalignr(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpalignr_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpalignr_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpalignr), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpand instruction.<br/>
		/// <br/>
		/// <c>VPAND xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DB /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAND ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DB /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpand(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpand_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpand_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpand), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpand instruction.<br/>
		/// <br/>
		/// <c>VPAND xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DB /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAND ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DB /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpand(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpand_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpand_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpand), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandd instruction.<br/>
		/// <br/>
		/// <c>VPANDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandd instruction.<br/>
		/// <br/>
		/// <c>VPANDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandn instruction.<br/>
		/// <br/>
		/// <c>VPANDN xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDN ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandn(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpandn_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpandn_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandn), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandn instruction.<br/>
		/// <br/>
		/// <c>VPANDN xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDN ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DF /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandn(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpandn_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpandn_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandn), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandnd instruction.<br/>
		/// <br/>
		/// <c>VPANDND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandnd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandnd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandnd instruction.<br/>
		/// <br/>
		/// <c>VPANDND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandnd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandnd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandnq instruction.<br/>
		/// <br/>
		/// <c>VPANDNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandnq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandnq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandnq instruction.<br/>
		/// <br/>
		/// <c>VPANDNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 DF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandnq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandnq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandq instruction.<br/>
		/// <br/>
		/// <c>VPANDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpandq instruction.<br/>
		/// <br/>
		/// <c>VPANDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPANDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 DB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpandq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpandq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpavgb instruction.<br/>
		/// <br/>
		/// <c>VPAVGB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpavgb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpavgb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpavgb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpavgb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpavgb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpavgb instruction.<br/>
		/// <br/>
		/// <c>VPAVGB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E0 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpavgb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpavgb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpavgb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpavgb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpavgb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpavgb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpavgb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpavgw instruction.<br/>
		/// <br/>
		/// <c>VPAVGW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpavgw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpavgw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpavgw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpavgw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpavgw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpavgw instruction.<br/>
		/// <br/>
		/// <c>VPAVGW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPAVGW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E3 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpavgw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpavgw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpavgw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpavgw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpavgw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpavgw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpavgw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpblendd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpblendd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpblendd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpblendd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpblendd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpblendd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpblendd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpblendmb instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmb instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmd instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmd instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmq instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmq instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmw instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendmw instruction.<br/>
		/// <br/>
		/// <c>VPBLENDMW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDMW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendmw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendmw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpblendvb instruction.<br/>
		/// <br/>
		/// <c>VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 4C /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 4C /r /is4</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendvb(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpblendvb_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpblendvb_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendvb), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpblendvb instruction.<br/>
		/// <br/>
		/// <c>VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F3A.W0 4C /r /is4</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F3A.W0 4C /r /is4</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpblendvb(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpblendvb_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpblendvb_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendvb), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpblendw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpblendw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpblendw_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpblendw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpblendw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpblendw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpblendw_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpblendw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpblendw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpbroadcastb instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTB xmm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB ymm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB zmm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7A /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB xmm1, xmm2/m8</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB ymm1, xmm2/m8</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB zmm1 {k1}{z}, xmm2/m8</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastb(Register dst, Register src) {
			Code op;
			if (dst.IsZMM() && src.IsXMM()) {
				op = Code.EVEX_Vpbroadcastb_zmm_k1z_xmmm8;
			} else if (dst.IsZMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastb_zmm_k1z_r32;
			} else if (dst.IsYMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastb_ymm_xmmm8;
			} else if (dst.IsYMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastb_ymm_k1z_r32;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastb_xmm_xmmm8;
			} else if (dst.IsXMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastb_xmm_k1z_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastb instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTB xmm1, xmm2/m8</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB ymm1, xmm2/m8</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB xmm1 {k1}{z}, xmm2/m8</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB ymm1 {k1}{z}, xmm2/m8</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTB zmm1 {k1}{z}, xmm2/m8</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 78 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpbroadcastb_zmm_k1z_xmmm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastb_ymm_xmmm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastb_ymm_k1z_xmmm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastb_xmm_xmmm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastb_xmm_k1z_xmmm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastd instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTD xmm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD ymm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD zmm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD zmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM() && src.IsXMM()) {
				op = Code.EVEX_Vpbroadcastd_zmm_k1z_xmmm32;
			} else if (dst.IsZMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastd_zmm_k1z_r32;
			} else if (dst.IsYMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastd_ymm_xmmm32;
			} else if (dst.IsYMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastd_ymm_k1z_r32;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastd_xmm_xmmm32;
			} else if (dst.IsXMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastd_xmm_k1z_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastd instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD xmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD ymm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTD zmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 58 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpbroadcastd_zmm_k1z_xmmm32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastd_ymm_xmmm32;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastd_ymm_k1z_xmmm32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastd_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastd_xmm_k1z_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastmb2q instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTMB2Q xmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTMB2Q ymm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTMB2Q zmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 2A /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastmb2q(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpbroadcastmb2q_zmm_k;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpbroadcastmb2q_ymm_k;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpbroadcastmb2q_xmm_k;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastmb2q), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastmw2d instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTMW2D xmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTMW2D ymm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTMW2D zmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastmw2d(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpbroadcastmw2d_zmm_k;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpbroadcastmw2d_ymm_k;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpbroadcastmw2d_xmm_k;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastmw2d), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastq instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTQ xmm1 {k1}{z}, r64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VPBROADCASTQ ymm1 {k1}{z}, r64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VPBROADCASTQ zmm1 {k1}{z}, r64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VPBROADCASTQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTQ ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTQ zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM() && src.IsXMM()) {
				op = Code.EVEX_Vpbroadcastq_zmm_k1z_xmmm64;
			} else if (dst.IsZMM() && src.IsGPR64()) {
				op = Code.EVEX_Vpbroadcastq_zmm_k1z_r64;
			} else if (dst.IsYMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastq_ymm_xmmm64;
			} else if (dst.IsYMM() && src.IsGPR64()) {
				op = Code.EVEX_Vpbroadcastq_ymm_k1z_r64;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastq_xmm_xmmm64;
			} else if (dst.IsXMM() && src.IsGPR64()) {
				op = Code.EVEX_Vpbroadcastq_xmm_k1z_r64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastq instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTQ ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 59 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTQ xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTQ ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTQ zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 59 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpbroadcastq_zmm_k1z_xmmm64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastq_ymm_xmmm64;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastq_ymm_k1z_xmmm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastq_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastq_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastw instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTW xmm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW ymm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW zmm1 {k1}{z}, r32</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW ymm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW zmm1 {k1}{z}, xmm2/m16</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM() && src.IsXMM()) {
				op = Code.EVEX_Vpbroadcastw_zmm_k1z_xmmm16;
			} else if (dst.IsZMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastw_zmm_k1z_r32;
			} else if (dst.IsYMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastw_ymm_xmmm16;
			} else if (dst.IsYMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastw_ymm_k1z_r32;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vpbroadcastw_xmm_xmmm16;
			} else if (dst.IsXMM() && src.IsGPR32()) {
				op = Code.EVEX_Vpbroadcastw_xmm_k1z_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpbroadcastw instruction.<br/>
		/// <br/>
		/// <c>VPBROADCASTW xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW ymm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW xmm1 {k1}{z}, xmm2/m16</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW ymm1 {k1}{z}, xmm2/m16</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPBROADCASTW zmm1 {k1}{z}, xmm2/m16</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 79 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpbroadcastw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpbroadcastw_zmm_k1z_xmmm16;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastw_ymm_xmmm16;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastw_ymm_k1z_xmmm16;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpbroadcastw_xmm_xmmm16;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpbroadcastw_xmm_k1z_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(vpbroadcastw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpclmulqdq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpclmulqdq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpclmulqdq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpclmulqdq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpclmulqdq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpclmulqdq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmov instruction.<br/>
		/// <br/>
		/// <c>VPCMOV xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 A2 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMOV ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>XOP.256.X8.W0 A2 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmov(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vpcmov_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vpcmov_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmov), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpcmov instruction.<br/>
		/// <br/>
		/// <c>VPCMOV xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 A2 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMOV ymm1, ymm2, ymm3/m256, ymm4</c><br/>
		/// <br/>
		/// <c>XOP.256.X8.W0 A2 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmov(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vpcmov_ymm_ymm_ymmm256_ymm;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vpcmov_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmov), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpcmov instruction.<br/>
		/// <br/>
		/// <c>VPCMOV xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W1 A2 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMOV ymm1, ymm2, ymm3, ymm4/m256</c><br/>
		/// <br/>
		/// <c>XOP.256.X8.W1 A2 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmov(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.XOP_Vpcmov_ymm_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.XOP_Vpcmov_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmov), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpcmpb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpb(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpb_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpb_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpb_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpb(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpb_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpb_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpb_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpd_k_k1_zmm_zmmm512b32_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpd_k_k1_ymm_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpd_k_k1_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpd_k_k1_zmm_zmmm512b32_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpd_k_k1_ymm_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpd_k_k1_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpeqb instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqb_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqb instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQB k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 74 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqb_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqd instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 76 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 76 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD k1 {k2}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD k1 {k2}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqd_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqd instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 76 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 76 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD k1 {k2}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD k1 {k2}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqd_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqq instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ k1 {k2}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ k1 {k2}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ k1 {k2}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqq_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqq instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 29 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ k1 {k2}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ k1 {k2}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQQ k1 {k2}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqq_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqw instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqw_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpeqw instruction.<br/>
		/// <br/>
		/// <c>VPCMPEQW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPEQW k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpeqw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpeqw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpeqw_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpeqw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpeqw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpeqw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpeqw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpestri instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestri(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestri instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestri(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestri64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestri64(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestri64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestri64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestri64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestri64(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestri64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestri64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestrm(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestrm(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestrm64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestrm64(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestrm64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestrm64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpestrm64 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpestrm64(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpestrm64_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpestrm64), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpgtb instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtb_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtb instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTB k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 64 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtb_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtd instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 66 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 66 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD k1 {k2}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD k1 {k2}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD k1 {k2}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtd_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtd instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 66 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 66 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD k1 {k2}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD k1 {k2}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTD k1 {k2}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 66 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtd_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtq instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 37 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 37 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ k1 {k2}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 37 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ k1 {k2}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 37 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ k1 {k2}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 37 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtq_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtq instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 37 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 37 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ k1 {k2}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 37 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ k1 {k2}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 37 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTQ k1 {k2}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 37 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtq_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtw instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtw_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpgtw instruction.<br/>
		/// <br/>
		/// <c>VPCMPGTW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCMPGTW k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 65 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcmpgtw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpcmpgtw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpgtw_xmm_xmm_xmmm128;
			} else if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpgtw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpgtw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpgtw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpgtw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpcmpistri instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpistri(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpistri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpistri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpistri instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpistri(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpistri_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpistri), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpistrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpistrm(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpistrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpistrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpistrm instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpistrm(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpcmpistrm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpistrm), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpcmpq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpq_k_k1_zmm_zmmm512b64_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpq_k_k1_ymm_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpq_k_k1_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpq_k_k1_zmm_zmmm512b64_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpq_k_k1_ymm_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpq_k_k1_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpub instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpub(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpub_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpub_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpub_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpub), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpub instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpub(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpub_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpub_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpub_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpub), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpud instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpud(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpud_k_k1_zmm_zmmm512b32_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpud_k_k1_ymm_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpud_k_k1_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpud), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpud instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpud(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpud_k_k1_zmm_zmmm512b32_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpud_k_k1_ymm_ymmm256b32_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpud_k_k1_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpud), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpuq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpuq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpuq_k_k1_zmm_zmmm512b64_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpuq_k_k1_ymm_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpuq_k_k1_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpuq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpuq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpuq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpuq_k_k1_zmm_zmmm512b64_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpuq_k_k1_ymm_ymmm256b64_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpuq_k_k1_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpuq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpuw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpuw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpuw_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpuw_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpuw_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpuw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpuw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpuw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpuw_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpuw_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpuw_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpuw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpw_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpw_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpw_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcmpw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcmpw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpcmpw_k_k1_zmm_zmmm512_imm8;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpcmpw_k_k1_ymm_ymmm256_imm8;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpcmpw_k_k1_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcmpw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomb(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomb_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomb(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomb_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcompressb instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSB xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSB ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSB zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressb(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpcompressb_zmmm512_k1z_zmm;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpcompressb_ymmm256_k1z_ymm;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpcompressb_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressb instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSB xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSB ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSB zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vpcompressb_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpcompressb_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vpcompressb_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressd instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSD xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSD ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSD zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpcompressd_zmmm512_k1z_zmm;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpcompressd_ymmm256_k1z_ymm;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpcompressd_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressd instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSD xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSD ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSD zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vpcompressd_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpcompressd_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vpcompressd_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressq instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSQ xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSQ ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSQ zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpcompressq_zmmm512_k1z_zmm;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpcompressq_ymmm256_k1z_ymm;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpcompressq_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressq instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSQ xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSQ ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSQ zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 8B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vpcompressq_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpcompressq_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vpcompressq_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressw instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSW xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSW ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSW zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpcompressw_zmmm512_k1z_zmm;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpcompressw_ymmm256_k1z_ymm;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpcompressw_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcompressw instruction.<br/>
		/// <br/>
		/// <c>VPCOMPRESSW xmm1/m128 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSW ymm1/m256 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCOMPRESSW zmm1/m512 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 63 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpcompressw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.ZwordPtr) {
				op = Code.EVEX_Vpcompressw_zmmm512_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpcompressw_ymmm256_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vpcompressw_xmmm128_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcompressw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpcomq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomq_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomq_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomub instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomub(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomub_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomub), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomub instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomub(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomub_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomub), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomud instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomud(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomud_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomud), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomud instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomud(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomud_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomud), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomuq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomuq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomuq_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomuq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomuq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomuq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomuq_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomuq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomuw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomuw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomuw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomuw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomuw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomuw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomuw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomuw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpcomw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpcomw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpcomw_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpcomw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpconflictd instruction.<br/>
		/// <br/>
		/// <c>VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpconflictd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpconflictd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpconflictd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpconflictd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpconflictd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpconflictd instruction.<br/>
		/// <br/>
		/// <c>VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpconflictd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpconflictd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpconflictd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpconflictd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpconflictd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpconflictq instruction.<br/>
		/// <br/>
		/// <c>VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpconflictq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpconflictq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpconflictq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpconflictq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpconflictq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpconflictq instruction.<br/>
		/// <br/>
		/// <c>VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C4 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpconflictq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpconflictq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpconflictq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpconflictq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpconflictq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpdpbusd instruction.<br/>
		/// <br/>
		/// <c>VPDPBUSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpbusd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpbusd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpbusd instruction.<br/>
		/// <br/>
		/// <c>VPDPBUSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 50 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpbusd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpbusd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpbusds instruction.<br/>
		/// <br/>
		/// <c>VPDPBUSDS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSDS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSDS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpbusds(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpbusds), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpbusds instruction.<br/>
		/// <br/>
		/// <c>VPDPBUSDS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSDS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPBUSDS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpbusds(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpbusds), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpwssd instruction.<br/>
		/// <br/>
		/// <c>VPDPWSSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpwssd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpwssd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpwssd instruction.<br/>
		/// <br/>
		/// <c>VPDPWSSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 52 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpwssd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpwssd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpwssds instruction.<br/>
		/// <br/>
		/// <c>VPDPWSSDS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 53 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSDS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 53 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSDS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 53 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpwssds(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpwssds), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpdpwssds instruction.<br/>
		/// <br/>
		/// <c>VPDPWSSDS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 53 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSDS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 53 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPDPWSSDS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 53 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VNNI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpdpwssds(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpdpwssds), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vperm2f128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vperm2f128(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vperm2f128_ymm_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vperm2f128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vperm2f128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vperm2f128(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vperm2f128_ymm_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vperm2f128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vperm2i128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vperm2i128(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vperm2i128_ymm_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vperm2i128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vperm2i128 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vperm2i128(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vperm2i128_ymm_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vperm2i128), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpermb instruction.<br/>
		/// <br/>
		/// <c>VPERMB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermb instruction.<br/>
		/// <br/>
		/// <c>VPERMB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermd instruction.<br/>
		/// <br/>
		/// <c>VPERMD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 36 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermd_ymm_ymm_ymmm256;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermd instruction.<br/>
		/// <br/>
		/// <c>VPERMD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 36 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermd_ymm_ymm_ymmm256;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2b instruction.<br/>
		/// <br/>
		/// <c>VPERMI2B xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2B ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2B zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2b(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2b), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2b instruction.<br/>
		/// <br/>
		/// <c>VPERMI2B xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2B ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2B zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2b(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2b), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2d instruction.<br/>
		/// <br/>
		/// <c>VPERMI2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2d(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2d), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2d instruction.<br/>
		/// <br/>
		/// <c>VPERMI2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2d(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2d), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2pd instruction.<br/>
		/// <br/>
		/// <c>VPERMI2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2pd instruction.<br/>
		/// <br/>
		/// <c>VPERMI2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2ps instruction.<br/>
		/// <br/>
		/// <c>VPERMI2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2ps instruction.<br/>
		/// <br/>
		/// <c>VPERMI2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 77 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2q instruction.<br/>
		/// <br/>
		/// <c>VPERMI2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2q(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2q), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2q instruction.<br/>
		/// <br/>
		/// <c>VPERMI2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 76 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2q(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2q), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2w instruction.<br/>
		/// <br/>
		/// <c>VPERMI2W xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2W ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2W zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2w(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2w), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermi2w instruction.<br/>
		/// <br/>
		/// <c>VPERMI2W xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2W ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMI2W zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 75 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermi2w(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermi2w), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermil2pd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermil2pd(Register dst, Register src, Register arg2, Register arg3, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm2;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm2;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermil2pd), dst, src, arg2, arg3, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3, imm));
		}
		/// <summary>vpermil2pd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermil2pd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm2;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm2;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermil2pd), dst, src, arg2, arg3, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3, imm));
		}
		/// <summary>vpermil2pd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermil2pd(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm2;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm2;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermil2pd), dst, src, arg2, arg3, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3, imm));
		}
		/// <summary>vpermil2ps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermil2ps(Register dst, Register src, Register arg2, Register arg3, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm2;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm2;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermil2ps), dst, src, arg2, arg3, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3, imm));
		}
		/// <summary>vpermil2ps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermil2ps(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm2;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm2;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermil2ps), dst, src, arg2, arg3, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3, imm));
		}
		/// <summary>vpermil2ps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermil2ps(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm2;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm2;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermil2ps), dst, src, arg2, arg3, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3, imm));
		}
		/// <summary>vpermilpd instruction.<br/>
		/// <br/>
		/// <c>VPERMILPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 0D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermilpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermilpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermilpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermilpd instruction.<br/>
		/// <br/>
		/// <c>VPERMILPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 0D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 0D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 0D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermilpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermilpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpermilpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermilpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermilpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermilpd_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermilpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermilpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermilpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermilpd_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpermilpd_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermilps instruction.<br/>
		/// <br/>
		/// <c>VPERMILPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermilps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermilps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermilps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermilps instruction.<br/>
		/// <br/>
		/// <c>VPERMILPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMILPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 0C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermilps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermilps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpermilps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermilps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermilps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermilps_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpermilps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermilps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermilps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermilps_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpermilps_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermilps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermpd instruction.<br/>
		/// <br/>
		/// <c>VPERMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermpd instruction.<br/>
		/// <br/>
		/// <c>VPERMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermpd_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermpd_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermps instruction.<br/>
		/// <br/>
		/// <c>VPERMPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermps_ymm_ymm_ymmm256;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermps instruction.<br/>
		/// <br/>
		/// <c>VPERMPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 16 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermps_ymm_ymm_ymmm256;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermq instruction.<br/>
		/// <br/>
		/// <c>VPERMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermq instruction.<br/>
		/// <br/>
		/// <c>VPERMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 36 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpermq_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpermq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpermq_ymm_ymmm256_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpermt2b instruction.<br/>
		/// <br/>
		/// <c>VPERMT2B xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2B ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2B zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2b(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2b), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2b instruction.<br/>
		/// <br/>
		/// <c>VPERMT2B xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2B ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2B zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2b(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2b), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2d instruction.<br/>
		/// <br/>
		/// <c>VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2d(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2d), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2d instruction.<br/>
		/// <br/>
		/// <c>VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2d(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2d), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2pd instruction.<br/>
		/// <br/>
		/// <c>VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2pd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2pd instruction.<br/>
		/// <br/>
		/// <c>VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2pd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2pd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2ps instruction.<br/>
		/// <br/>
		/// <c>VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2ps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2ps instruction.<br/>
		/// <br/>
		/// <c>VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 7F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2ps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2ps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2q instruction.<br/>
		/// <br/>
		/// <c>VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2q(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2q), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2q instruction.<br/>
		/// <br/>
		/// <c>VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2q(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2q), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2w instruction.<br/>
		/// <br/>
		/// <c>VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2w(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2w), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermt2w instruction.<br/>
		/// <br/>
		/// <c>VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 7D /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermt2w(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermt2w), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermw instruction.<br/>
		/// <br/>
		/// <c>VPERMW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpermw instruction.<br/>
		/// <br/>
		/// <c>VPERMW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPERMW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 8D /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpermw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpermw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpermw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpermw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpermw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpexpandb instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDB xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDB ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDB zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandb(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandb_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandb_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandb_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandb instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDB xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDB ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDB zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandb_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandb_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandb_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandd instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDD xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDD ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandd_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandd_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandd instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDD xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDD ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDD zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandd_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandd_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandd_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandq instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDQ xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDQ ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDQ zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandq_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandq_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandq_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandq instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDQ xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDQ ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDQ zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 89 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandq_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandq_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandq_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandw instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDW xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDW ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDW zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandw_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandw_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandw_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpexpandw instruction.<br/>
		/// <br/>
		/// <c>VPEXPANDW xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDW ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPEXPANDW zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpexpandw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpexpandw_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpexpandw_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpexpandw_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpexpandw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpextrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.VEX_Vpextrb_r32m8_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrb(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr && PreferVex) {
				op = Code.VEX_Vpextrb_r32m8_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr && PreferVex) {
				op = Code.VEX_Vpextrb_r64m8_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr && !PreferVex) {
				op = Code.EVEX_Vpextrb_r32m8_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr && !PreferVex) {
				op = Code.EVEX_Vpextrb_r64m8_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.VEX_Vpextrd_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrd(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr && PreferVex) {
				op = Code.VEX_Vpextrd_rm32_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr && !PreferVex) {
				op = Code.EVEX_Vpextrd_rm32_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vpextrq_rm64_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrq(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr && PreferVex) {
				op = Code.VEX_Vpextrq_rm64_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.QwordPtr && !PreferVex) {
				op = Code.EVEX_Vpextrq_rm64_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.VEX_Vpextrw_r64_xmm_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.VEX_Vpextrw_r32_xmm_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.VEX_Vpextrw_r32m16_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpextrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpextrw(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr && PreferVex) {
				op = Code.VEX_Vpextrw_r32m16_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr && PreferVex) {
				op = Code.VEX_Vpextrw_r64m16_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr && !PreferVex) {
				op = Code.EVEX_Vpextrw_r32m16_xmm_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr && !PreferVex) {
				op = Code.EVEX_Vpextrw_r64m16_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpextrw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpgatherdd instruction.<br/>
		/// <br/>
		/// <c>VPGATHERDD xmm1 {k1}, vm32x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 90 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERDD ymm1 {k1}, vm32y</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 90 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERDD zmm1 {k1}, vm32z</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 90 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherdd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpgatherdd_zmm_k1_vm32z;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpgatherdd_ymm_k1_vm32y;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpgatherdd_xmm_k1_vm32x;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherdd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpgatherdd instruction.<br/>
		/// <br/>
		/// <c>VPGATHERDD xmm1, vm32x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 90 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERDD ymm1, vm32y, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 90 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherdd(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpgatherdd_ymm_vm32y_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpgatherdd_xmm_vm32x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherdd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpgatherdq instruction.<br/>
		/// <br/>
		/// <c>VPGATHERDQ xmm1 {k1}, vm32x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 90 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERDQ ymm1 {k1}, vm32x</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 90 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERDQ zmm1 {k1}, vm32y</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 90 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpgatherdq_zmm_k1_vm32y;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpgatherdq_ymm_k1_vm32x;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpgatherdq_xmm_k1_vm32x;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpgatherdq instruction.<br/>
		/// <br/>
		/// <c>VPGATHERDQ xmm1, vm32x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 90 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERDQ ymm1, vm32x, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 90 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherdq(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpgatherdq_ymm_vm32x_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpgatherdq_xmm_vm32x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpgatherqd instruction.<br/>
		/// <br/>
		/// <c>VPGATHERQD xmm1 {k1}, vm64x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 91 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERQD xmm1 {k1}, vm64y</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 91 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERQD ymm1 {k1}, vm64z</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 91 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherqd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpgatherqd_ymm_k1_vm64z;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpgatherqd_xmm_k1_vm64y;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vpgatherqd_xmm_k1_vm64x;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpgatherqd instruction.<br/>
		/// <br/>
		/// <c>VPGATHERQD xmm1, vm64x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 91 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERQD xmm1, vm64y, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 91 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherqd(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM() && src.Size == MemoryOperandSize.YwordPtr) {
				op = Code.VEX_Vpgatherqd_xmm_vm64y_xmm;
			} else if (dst.IsXMM() && src.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.VEX_Vpgatherqd_xmm_vm64x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherqd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpgatherqq instruction.<br/>
		/// <br/>
		/// <c>VPGATHERQQ xmm1 {k1}, vm64x</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 91 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERQQ ymm1 {k1}, vm64y</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 91 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERQQ zmm1 {k1}, vm64z</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 91 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherqq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpgatherqq_zmm_k1_vm64z;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpgatherqq_ymm_k1_vm64y;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpgatherqq_xmm_k1_vm64x;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpgatherqq instruction.<br/>
		/// <br/>
		/// <c>VPGATHERQQ xmm1, vm64x, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 91 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPGATHERQQ ymm1, vm64y, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 91 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpgatherqq(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpgatherqq_ymm_vm64y_ymm;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpgatherqq_xmm_vm64x_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpgatherqq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphaddbd instruction.<br/>
		/// <br/>
		/// <c>VPHADDBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C2 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddbd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddbd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddbd instruction.<br/>
		/// <br/>
		/// <c>VPHADDBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C2 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddbd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddbd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddbq instruction.<br/>
		/// <br/>
		/// <c>VPHADDBQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C3 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddbq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddbq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddbq instruction.<br/>
		/// <br/>
		/// <c>VPHADDBQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C3 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddbq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddbq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddbw instruction.<br/>
		/// <br/>
		/// <c>VPHADDBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C1 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddbw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddbw instruction.<br/>
		/// <br/>
		/// <c>VPHADDBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C1 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddbw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddd instruction.<br/>
		/// <br/>
		/// <c>VPHADDD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 02 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHADDD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 02 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphaddd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphaddd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphaddd instruction.<br/>
		/// <br/>
		/// <c>VPHADDD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 02 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHADDD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 02 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphaddd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphaddd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphadddq instruction.<br/>
		/// <br/>
		/// <c>VPHADDDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 CB /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphadddq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphadddq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphadddq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphadddq instruction.<br/>
		/// <br/>
		/// <c>VPHADDDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 CB /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphadddq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphadddq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphadddq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddsw instruction.<br/>
		/// <br/>
		/// <c>VPHADDSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 03 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHADDSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 03 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphaddsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphaddsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphaddsw instruction.<br/>
		/// <br/>
		/// <c>VPHADDSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 03 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHADDSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 03 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphaddsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphaddsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphaddubd instruction.<br/>
		/// <br/>
		/// <c>VPHADDUBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D2 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddubd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddubd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddubd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddubd instruction.<br/>
		/// <br/>
		/// <c>VPHADDUBD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D2 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddubd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddubd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddubd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddubq instruction.<br/>
		/// <br/>
		/// <c>VPHADDUBQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D3 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddubq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddubq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddubq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddubq instruction.<br/>
		/// <br/>
		/// <c>VPHADDUBQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D3 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddubq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddubq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddubq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddubw instruction.<br/>
		/// <br/>
		/// <c>VPHADDUBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D1 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddubw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddubw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddubw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddubw instruction.<br/>
		/// <br/>
		/// <c>VPHADDUBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D1 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddubw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddubw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddubw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddudq instruction.<br/>
		/// <br/>
		/// <c>VPHADDUDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 DB /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddudq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddudq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddudq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddudq instruction.<br/>
		/// <br/>
		/// <c>VPHADDUDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 DB /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddudq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddudq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddudq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphadduwd instruction.<br/>
		/// <br/>
		/// <c>VPHADDUWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D6 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphadduwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphadduwd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphadduwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphadduwd instruction.<br/>
		/// <br/>
		/// <c>VPHADDUWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D6 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphadduwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphadduwd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphadduwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphadduwq instruction.<br/>
		/// <br/>
		/// <c>VPHADDUWQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D7 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphadduwq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphadduwq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphadduwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphadduwq instruction.<br/>
		/// <br/>
		/// <c>VPHADDUWQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 D7 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphadduwq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphadduwq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphadduwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddw instruction.<br/>
		/// <br/>
		/// <c>VPHADDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 01 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHADDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 01 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphaddw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphaddw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphaddw instruction.<br/>
		/// <br/>
		/// <c>VPHADDW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 01 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHADDW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 01 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphaddw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphaddw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphaddwd instruction.<br/>
		/// <br/>
		/// <c>VPHADDWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C6 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddwd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddwd instruction.<br/>
		/// <br/>
		/// <c>VPHADDWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C6 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddwd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddwq instruction.<br/>
		/// <br/>
		/// <c>VPHADDWQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C7 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddwq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddwq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphaddwq instruction.<br/>
		/// <br/>
		/// <c>VPHADDWQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 C7 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphaddwq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphaddwq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphaddwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphminposuw instruction.<br/>
		/// <br/>
		/// <c>VPHMINPOSUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 41 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphminposuw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vphminposuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphminposuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphminposuw instruction.<br/>
		/// <br/>
		/// <c>VPHMINPOSUW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 41 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphminposuw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vphminposuw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphminposuw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphsubbw instruction.<br/>
		/// <br/>
		/// <c>VPHSUBBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 E1 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubbw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphsubbw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphsubbw instruction.<br/>
		/// <br/>
		/// <c>VPHSUBBW xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 E1 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphsubbw_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphsubd instruction.<br/>
		/// <br/>
		/// <c>VPHSUBD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 06 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHSUBD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 06 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphsubd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphsubd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphsubd instruction.<br/>
		/// <br/>
		/// <c>VPHSUBD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 06 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHSUBD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 06 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphsubd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphsubd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphsubdq instruction.<br/>
		/// <br/>
		/// <c>VPHSUBDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 E3 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubdq(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphsubdq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphsubdq instruction.<br/>
		/// <br/>
		/// <c>VPHSUBDQ xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 E3 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphsubdq_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphsubsw instruction.<br/>
		/// <br/>
		/// <c>VPHSUBSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 07 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHSUBSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 07 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphsubsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphsubsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphsubsw instruction.<br/>
		/// <br/>
		/// <c>VPHSUBSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 07 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHSUBSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 07 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphsubsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphsubsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphsubw instruction.<br/>
		/// <br/>
		/// <c>VPHSUBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 05 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHSUBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 05 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphsubw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphsubw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphsubw instruction.<br/>
		/// <br/>
		/// <c>VPHSUBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 05 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPHSUBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 05 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vphsubw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vphsubw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vphsubwd instruction.<br/>
		/// <br/>
		/// <c>VPHSUBWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 E2 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubwd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphsubwd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vphsubwd instruction.<br/>
		/// <br/>
		/// <c>VPHSUBWD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 E2 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vphsubwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vphsubwd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vphsubwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpinsrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrb(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpinsrb_xmm_xmm_r32m8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrb(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpinsrb_xmm_xmm_r32m8_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpinsrb_xmm_xmm_r64m8_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpinsrb_xmm_xmm_r32m8_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpinsrb_xmm_xmm_r64m8_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrb), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpinsrd_xmm_xmm_rm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpinsrd_xmm_xmm_rm32_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpinsrd_xmm_xmm_rm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpinsrq_xmm_xmm_rm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpinsrq_xmm_xmm_rm64_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpinsrq_xmm_xmm_rm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vpinsrw_xmm_xmm_r32m16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpinsrw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpinsrw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpinsrw_xmm_xmm_r32m16_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpinsrw_xmm_xmm_r64m16_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpinsrw_xmm_xmm_r32m16_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpinsrw_xmm_xmm_r64m16_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpinsrw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vplzcntd instruction.<br/>
		/// <br/>
		/// <c>VPLZCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vplzcntd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vplzcntd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vplzcntd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vplzcntd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vplzcntd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vplzcntd instruction.<br/>
		/// <br/>
		/// <c>VPLZCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vplzcntd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vplzcntd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vplzcntd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vplzcntd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vplzcntd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vplzcntq instruction.<br/>
		/// <br/>
		/// <c>VPLZCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vplzcntq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vplzcntq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vplzcntq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vplzcntq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vplzcntq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vplzcntq instruction.<br/>
		/// <br/>
		/// <c>VPLZCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPLZCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 44 /r</c><br/>
		/// <br/>
		/// <c>AVX512CD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vplzcntq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vplzcntq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vplzcntq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vplzcntq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vplzcntq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmacsdd instruction.<br/>
		/// <br/>
		/// <c>VPMACSDD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 9E /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsdd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsdd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsdd instruction.<br/>
		/// <br/>
		/// <c>VPMACSDD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 9E /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsdd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsdd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsdqh instruction.<br/>
		/// <br/>
		/// <c>VPMACSDQH xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 9F /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsdqh(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsdqh), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsdqh instruction.<br/>
		/// <br/>
		/// <c>VPMACSDQH xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 9F /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsdqh(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsdqh), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsdql instruction.<br/>
		/// <br/>
		/// <c>VPMACSDQL xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 97 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsdql(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsdql), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsdql instruction.<br/>
		/// <br/>
		/// <c>VPMACSDQL xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 97 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsdql(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsdql), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssdd instruction.<br/>
		/// <br/>
		/// <c>VPMACSSDD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 8E /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssdd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssdd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssdd instruction.<br/>
		/// <br/>
		/// <c>VPMACSSDD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 8E /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssdd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssdd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssdqh instruction.<br/>
		/// <br/>
		/// <c>VPMACSSDQH xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 8F /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssdqh(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssdqh), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssdqh instruction.<br/>
		/// <br/>
		/// <c>VPMACSSDQH xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 8F /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssdqh(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssdqh), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssdql instruction.<br/>
		/// <br/>
		/// <c>VPMACSSDQL xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 87 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssdql(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssdql), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssdql instruction.<br/>
		/// <br/>
		/// <c>VPMACSSDQL xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 87 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssdql(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssdql), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsswd instruction.<br/>
		/// <br/>
		/// <c>VPMACSSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 86 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsswd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsswd instruction.<br/>
		/// <br/>
		/// <c>VPMACSSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 86 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsswd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssww instruction.<br/>
		/// <br/>
		/// <c>VPMACSSWW xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 85 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssww(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssww_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssww), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacssww instruction.<br/>
		/// <br/>
		/// <c>VPMACSSWW xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 85 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacssww(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacssww_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacssww), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacswd instruction.<br/>
		/// <br/>
		/// <c>VPMACSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 96 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacswd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacswd instruction.<br/>
		/// <br/>
		/// <c>VPMACSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 96 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacswd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsww instruction.<br/>
		/// <br/>
		/// <c>VPMACSWW xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 95 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsww(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsww_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsww), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmacsww instruction.<br/>
		/// <br/>
		/// <c>VPMACSWW xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 95 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmacsww(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmacsww_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmacsww), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmadcsswd instruction.<br/>
		/// <br/>
		/// <c>VPMADCSSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 A6 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadcsswd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadcsswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmadcsswd instruction.<br/>
		/// <br/>
		/// <c>VPMADCSSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 A6 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadcsswd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadcsswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmadcswd instruction.<br/>
		/// <br/>
		/// <c>VPMADCSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 B6 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadcswd(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadcswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmadcswd instruction.<br/>
		/// <br/>
		/// <c>VPMADCSWD xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 B6 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadcswd(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadcswd), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpmadd52huq instruction.<br/>
		/// <br/>
		/// <c>VPMADD52HUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52HUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52HUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B5 /r</c><br/>
		/// <br/>
		/// <c>AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadd52huq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadd52huq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmadd52huq instruction.<br/>
		/// <br/>
		/// <c>VPMADD52HUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52HUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52HUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B5 /r</c><br/>
		/// <br/>
		/// <c>AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadd52huq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadd52huq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmadd52luq instruction.<br/>
		/// <br/>
		/// <c>VPMADD52LUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52LUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52LUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B4 /r</c><br/>
		/// <br/>
		/// <c>AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadd52luq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadd52luq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmadd52luq instruction.<br/>
		/// <br/>
		/// <c>VPMADD52LUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 B4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52LUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 B4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADD52LUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 B4 /r</c><br/>
		/// <br/>
		/// <c>AVX512_IFMA</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmadd52luq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmadd52luq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaddubsw instruction.<br/>
		/// <br/>
		/// <c>VPMADDUBSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDUBSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDUBSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaddubsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaddubsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaddubsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaddubsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaddubsw instruction.<br/>
		/// <br/>
		/// <c>VPMADDUBSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDUBSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDUBSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDUBSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDUBSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 04 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaddubsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaddubsw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaddubsw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaddubsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaddwd instruction.<br/>
		/// <br/>
		/// <c>VPMADDWD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDWD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDWD zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaddwd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaddwd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaddwd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaddwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaddwd instruction.<br/>
		/// <br/>
		/// <c>VPMADDWD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDWD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDWD xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDWD ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMADDWD zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F5 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaddwd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaddwd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaddwd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaddwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaskmovd instruction.<br/>
		/// <br/>
		/// <c>VPMASKMOVD xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVD ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVD m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 8E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaskmovd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpmaskmovd_ymm_ymm_m256;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vpmaskmovd_m256_ymm_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vpmaskmovd_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaskmovd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaskmovd instruction.<br/>
		/// <br/>
		/// <c>VPMASKMOVD m128, xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 8E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVD m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 8E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaskmovd(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vpmaskmovd_m256_ymm_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vpmaskmovd_m128_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaskmovd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaskmovd instruction.<br/>
		/// <br/>
		/// <c>VPMASKMOVD xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVD ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaskmovd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpmaskmovd_ymm_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaskmovd_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaskmovd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaskmovq instruction.<br/>
		/// <br/>
		/// <c>VPMASKMOVQ xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVQ ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVQ m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 8E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaskmovq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpmaskmovq_ymm_ymm_m256;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.VEX_Vpmaskmovq_m256_ymm_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.VEX_Vpmaskmovq_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaskmovq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaskmovq instruction.<br/>
		/// <br/>
		/// <c>VPMASKMOVQ m128, xmm1, xmm2</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 8E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVQ m256, ymm1, ymm2</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 8E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaskmovq(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.VEX_Vpmaskmovq_m256_ymm_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.VEX_Vpmaskmovq_m128_xmm_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaskmovq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaskmovq instruction.<br/>
		/// <br/>
		/// <c>VPMASKMOVQ xmm1, xmm2, m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMASKMOVQ ymm1, ymm2, m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 8C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaskmovq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpmaskmovq_ymm_ymm_m256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaskmovq_xmm_xmm_m128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaskmovq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsb instruction.<br/>
		/// <br/>
		/// <c>VPMAXSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaxsb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaxsb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsb instruction.<br/>
		/// <br/>
		/// <c>VPMAXSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 3C /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaxsb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaxsb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsd instruction.<br/>
		/// <br/>
		/// <c>VPMAXSD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3D /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaxsd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaxsd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsd instruction.<br/>
		/// <br/>
		/// <c>VPMAXSD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3D /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaxsd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaxsd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsq instruction.<br/>
		/// <br/>
		/// <c>VPMAXSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsq instruction.<br/>
		/// <br/>
		/// <c>VPMAXSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 3D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsw instruction.<br/>
		/// <br/>
		/// <c>VPMAXSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaxsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaxsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxsw instruction.<br/>
		/// <br/>
		/// <c>VPMAXSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG EE /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaxsw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaxsw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxub instruction.<br/>
		/// <br/>
		/// <c>VPMAXUB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxub(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaxub_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaxub_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxub), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxub instruction.<br/>
		/// <br/>
		/// <c>VPMAXUB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DE /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxub(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaxub_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaxub_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxub), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxud instruction.<br/>
		/// <br/>
		/// <c>VPMAXUD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3F /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxud(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaxud_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaxud_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxud), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxud instruction.<br/>
		/// <br/>
		/// <c>VPMAXUD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3F /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxud(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaxud_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaxud_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxud), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxuq instruction.<br/>
		/// <br/>
		/// <c>VPMAXUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxuq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxuq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxuq instruction.<br/>
		/// <br/>
		/// <c>VPMAXUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 3F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxuq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxuq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxuw instruction.<br/>
		/// <br/>
		/// <c>VPMAXUW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxuw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmaxuw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmaxuw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxuw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmaxuw instruction.<br/>
		/// <br/>
		/// <c>VPMAXUW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMAXUW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 3E /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmaxuw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmaxuw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmaxuw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmaxuw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsb instruction.<br/>
		/// <br/>
		/// <c>VPMINSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpminsb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpminsb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsb instruction.<br/>
		/// <br/>
		/// <c>VPMINSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpminsb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpminsb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpminsb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpminsb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsd instruction.<br/>
		/// <br/>
		/// <c>VPMINSD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 39 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 39 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpminsd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpminsd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsd instruction.<br/>
		/// <br/>
		/// <c>VPMINSD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 39 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 39 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpminsd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpminsd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsq instruction.<br/>
		/// <br/>
		/// <c>VPMINSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsq instruction.<br/>
		/// <br/>
		/// <c>VPMINSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsw instruction.<br/>
		/// <br/>
		/// <c>VPMINSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpminsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpminsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminsw instruction.<br/>
		/// <br/>
		/// <c>VPMINSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG EA /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpminsw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpminsw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpminsw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpminsw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminub instruction.<br/>
		/// <br/>
		/// <c>VPMINUB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminub(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminub_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpminub_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpminub_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminub), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminub instruction.<br/>
		/// <br/>
		/// <c>VPMINUB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG DA /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminub(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminub_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpminub_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpminub_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpminub_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpminub_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminub), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminud instruction.<br/>
		/// <br/>
		/// <c>VPMINUD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminud(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpminud_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpminud_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminud), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminud instruction.<br/>
		/// <br/>
		/// <c>VPMINUD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminud(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpminud_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpminud_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminud), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminuq instruction.<br/>
		/// <br/>
		/// <c>VPMINUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminuq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminuq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminuq instruction.<br/>
		/// <br/>
		/// <c>VPMINUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 3B /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminuq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminuq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminuw instruction.<br/>
		/// <br/>
		/// <c>VPMINUW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminuw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminuw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpminuw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpminuw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminuw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpminuw instruction.<br/>
		/// <br/>
		/// <c>VPMINUW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMINUW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 3A /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpminuw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpminuw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpminuw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpminuw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpminuw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpminuw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpminuw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmovb2m instruction.<br/>
		/// <br/>
		/// <c>VPMOVB2M k1, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVB2M k1, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVB2M k1, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovb2m(Register dst, Register src) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpmovb2m_k_zmm;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpmovb2m_k_ymm;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpmovb2m_k_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovb2m), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovd2m instruction.<br/>
		/// <br/>
		/// <c>VPMOVD2M k1, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVD2M k1, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVD2M k1, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovd2m(Register dst, Register src) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpmovd2m_k_zmm;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpmovd2m_k_ymm;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpmovd2m_k_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovd2m), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovdb instruction.<br/>
		/// <br/>
		/// <c>VPMOVDB xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDB xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDB xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovdb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovdb_xmmm128_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovdb_xmmm64_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovdb_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovdb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovdb instruction.<br/>
		/// <br/>
		/// <c>VPMOVDB xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDB xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDB xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovdb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovdb_xmmm128_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovdb_xmmm64_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovdb_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovdb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovdw instruction.<br/>
		/// <br/>
		/// <c>VPMOVDW xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDW xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDW ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovdw(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovdw_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovdw_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovdw_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovdw instruction.<br/>
		/// <br/>
		/// <c>VPMOVDW xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDW xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVDW ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovdw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovdw_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovdw_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovdw_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovm2b instruction.<br/>
		/// <br/>
		/// <c>VPMOVM2B xmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2B ymm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2B zmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovm2b(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovm2b_zmm_k;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovm2b_ymm_k;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmovm2b_xmm_k;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovm2b), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovm2d instruction.<br/>
		/// <br/>
		/// <c>VPMOVM2D xmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2D ymm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2D zmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovm2d(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovm2d_zmm_k;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovm2d_ymm_k;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmovm2d_xmm_k;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovm2d), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovm2q instruction.<br/>
		/// <br/>
		/// <c>VPMOVM2Q xmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2Q ymm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2Q zmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 38 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovm2q(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovm2q_zmm_k;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovm2q_ymm_k;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmovm2q_xmm_k;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovm2q), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovm2w instruction.<br/>
		/// <br/>
		/// <c>VPMOVM2W xmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2W ymm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVM2W zmm1, k1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovm2w(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovm2w_zmm_k;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovm2w_ymm_k;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmovm2w_xmm_k;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovm2w), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovmskb instruction.<br/>
		/// <br/>
		/// <c>VPMOVMSKB r32, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W0 D7 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVMSKB r64, xmm1</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.W1 D7 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>VPMOVMSKB r32, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.W0 D7 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVMSKB r64, ymm1</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.W1 D7 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void vpmovmskb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsYMM()) {
				op = Code.VEX_Vpmovmskb_r64_ymm;
			} else if (dst.IsGPR64() && src.IsXMM()) {
				op = Code.VEX_Vpmovmskb_r64_xmm;
			} else if (dst.IsGPR32() && src.IsYMM()) {
				op = Code.VEX_Vpmovmskb_r32_ymm;
			} else if (dst.IsGPR32() && src.IsXMM()) {
				op = Code.VEX_Vpmovmskb_r32_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovmskb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovq2m instruction.<br/>
		/// <br/>
		/// <c>VPMOVQ2M k1, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQ2M k1, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQ2M k1, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 39 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovq2m(Register dst, Register src) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpmovq2m_k_zmm;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpmovq2m_k_ymm;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpmovq2m_k_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovq2m), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovqb instruction.<br/>
		/// <br/>
		/// <c>VPMOVQB xmm1/m16 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQB xmm1/m32 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQB xmm1/m64 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovqb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovqb_xmmm64_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovqb_xmmm32_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovqb_xmmm16_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovqb instruction.<br/>
		/// <br/>
		/// <c>VPMOVQB xmm1/m16 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQB xmm1/m32 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQB xmm1/m64 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovqb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovqb_xmmm64_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovqb_xmmm32_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovqb_xmmm16_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovqd instruction.<br/>
		/// <br/>
		/// <c>VPMOVQD xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQD xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQD ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovqd(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovqd_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovqd_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovqd_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovqd instruction.<br/>
		/// <br/>
		/// <c>VPMOVQD xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQD xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQD ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovqd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovqd_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovqd_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovqd_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovqw instruction.<br/>
		/// <br/>
		/// <c>VPMOVQW xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQW xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQW xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovqw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovqw_xmmm128_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovqw_xmmm64_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovqw_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovqw instruction.<br/>
		/// <br/>
		/// <c>VPMOVQW xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQW xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVQW xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovqw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovqw_xmmm128_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovqw_xmmm64_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovqw_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsdb instruction.<br/>
		/// <br/>
		/// <c>VPMOVSDB xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDB xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDB xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsdb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovsdb_xmmm128_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovsdb_xmmm64_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovsdb_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsdb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsdb instruction.<br/>
		/// <br/>
		/// <c>VPMOVSDB xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDB xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDB xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsdb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovsdb_xmmm128_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovsdb_xmmm64_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovsdb_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsdb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsdw instruction.<br/>
		/// <br/>
		/// <c>VPMOVSDW xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDW xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDW ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsdw(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovsdw_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovsdw_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovsdw_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsdw instruction.<br/>
		/// <br/>
		/// <c>VPMOVSDW xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDW xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSDW ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsdw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovsdw_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovsdw_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovsdw_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsqb instruction.<br/>
		/// <br/>
		/// <c>VPMOVSQB xmm1/m16 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQB xmm1/m32 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQB xmm1/m64 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsqb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovsqb_xmmm64_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovsqb_xmmm32_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovsqb_xmmm16_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsqb instruction.<br/>
		/// <br/>
		/// <c>VPMOVSQB xmm1/m16 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQB xmm1/m32 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQB xmm1/m64 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsqb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovsqb_xmmm64_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovsqb_xmmm32_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovsqb_xmmm16_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsqd instruction.<br/>
		/// <br/>
		/// <c>VPMOVSQD xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQD xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQD ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsqd(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovsqd_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovsqd_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovsqd_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsqd instruction.<br/>
		/// <br/>
		/// <c>VPMOVSQD xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQD xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQD ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsqd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovsqd_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovsqd_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovsqd_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsqw instruction.<br/>
		/// <br/>
		/// <c>VPMOVSQW xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQW xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQW xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsqw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovsqw_xmmm128_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovsqw_xmmm64_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovsqw_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsqw instruction.<br/>
		/// <br/>
		/// <c>VPMOVSQW xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQW xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSQW xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsqw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovsqw_xmmm128_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovsqw_xmmm64_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovsqw_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovswb instruction.<br/>
		/// <br/>
		/// <c>VPMOVSWB xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSWB xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSWB ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovswb(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovswb_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovswb_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovswb_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovswb instruction.<br/>
		/// <br/>
		/// <c>VPMOVSWB xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSWB xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSWB ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovswb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovswb_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovswb_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovswb_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxbd instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBD ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBD zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxbd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxbd_zmm_k1z_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovsxbd_ymm_xmmm64;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovsxbd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxbd instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBD ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBD xmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBD ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBD zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 21 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxbd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxbd_zmm_k1z_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovsxbd_ymm_xmmm64;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxbd_ymm_k1z_xmmm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovsxbd_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxbd_xmm_k1z_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxbq instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBQ ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBQ zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxbq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxbq_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovsxbq_ymm_xmmm32;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovsxbq_xmm_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxbq instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBQ ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBQ xmm1 {k1}{z}, xmm2/m16</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBQ ymm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBQ zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 22 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxbq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxbq_zmm_k1z_xmmm64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovsxbq_ymm_xmmm32;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxbq_ymm_k1z_xmmm32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovsxbq_xmm_xmmm16;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxbq_xmm_k1z_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxbw instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBW ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBW zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxbw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxbw_zmm_k1z_ymmm256;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovsxbw_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovsxbw_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxbw instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBW ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBW xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBW ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXBW zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 20 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxbw_zmm_k1z_ymmm256;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovsxbw_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxbw_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovsxbw_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxbw_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxdq instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 25 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXDQ ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 25 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXDQ zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxdq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxdq_zmm_k1z_ymmm256;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovsxdq_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovsxdq_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxdq instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 25 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXDQ ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 25 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXDQ xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXDQ ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXDQ zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 25 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxdq_zmm_k1z_ymmm256;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovsxdq_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxdq_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovsxdq_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxdq_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxwd instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWD zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxwd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxwd_zmm_k1z_ymmm256;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovsxwd_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovsxwd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxwd instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWD xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWD ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWD zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 23 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxwd_zmm_k1z_ymmm256;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovsxwd_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxwd_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovsxwd_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxwd_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxwq instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWQ ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWQ zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxwq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxwq_zmm_k1z_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovsxwq_ymm_xmmm64;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovsxwq_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovsxwq instruction.<br/>
		/// <br/>
		/// <c>VPMOVSXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWQ ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWQ xmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWQ ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVSXWQ zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 24 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovsxwq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovsxwq_zmm_k1z_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovsxwq_ymm_xmmm64;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxwq_ymm_k1z_xmmm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovsxwq_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovsxwq_xmm_k1z_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovsxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusdb instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSDB xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDB xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDB xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusdb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovusdb_xmmm128_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovusdb_xmmm64_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovusdb_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusdb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusdb instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSDB xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDB xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDB xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusdb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovusdb_xmmm128_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovusdb_xmmm64_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovusdb_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusdb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusdw instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSDW xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDW xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDW ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusdw(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovusdw_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovusdw_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovusdw_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusdw instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSDW xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDW xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSDW ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 13 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusdw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovusdw_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovusdw_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovusdw_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusdw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusqb instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSQB xmm1/m16 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQB xmm1/m32 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQB xmm1/m64 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusqb(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovusqb_xmmm64_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovusqb_xmmm32_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovusqb_xmmm16_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusqb instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSQB xmm1/m16 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQB xmm1/m32 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQB xmm1/m64 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusqb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovusqb_xmmm64_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovusqb_xmmm32_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovusqb_xmmm16_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusqb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusqd instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSQD xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQD xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQD ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusqd(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovusqd_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovusqd_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovusqd_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusqd instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSQD xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQD xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQD ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusqd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovusqd_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovusqd_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovusqd_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusqw instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSQW xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQW xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQW xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusqw(Register dst, Register src) {
			Code op;
			if (dst.IsXMM() && src.IsZMM()) {
				op = Code.EVEX_Vpmovusqw_xmmm128_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovusqw_xmmm64_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovusqw_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovusqw instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSQW xmm1/m32 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQW xmm1/m64 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSQW xmm1/m128 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovusqw(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsZMM()) {
				op = Code.EVEX_Vpmovusqw_xmmm128_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovusqw_xmmm64_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovusqw_xmmm32_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovusqw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovuswb instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSWB xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSWB xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSWB ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovuswb(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovuswb_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovuswb_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovuswb_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovuswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovuswb instruction.<br/>
		/// <br/>
		/// <c>VPMOVUSWB xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSWB xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVUSWB ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovuswb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovuswb_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovuswb_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovuswb_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovuswb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovw2m instruction.<br/>
		/// <br/>
		/// <c>VPMOVW2M k1, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVW2M k1, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVW2M k1, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 29 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovw2m(Register dst, Register src) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpmovw2m_k_zmm;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpmovw2m_k_ymm;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpmovw2m_k_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovw2m), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovwb instruction.<br/>
		/// <br/>
		/// <c>VPMOVWB xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVWB xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVWB ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovwb(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.EVEX_Vpmovwb_ymmm256_k1z_zmm;
			} else if (dst.IsXMM() && src.IsYMM()) {
				op = Code.EVEX_Vpmovwb_xmmm128_k1z_ymm;
			} else if (dst.IsXMM() && src.IsXMM()) {
				op = Code.EVEX_Vpmovwb_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovwb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovwb instruction.<br/>
		/// <br/>
		/// <c>VPMOVWB xmm1/m64 {k1}{z}, xmm2</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVWB xmm1/m128 {k1}{z}, ymm2</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVWB ymm1/m256 {k1}{z}, zmm2</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovwb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpmovwb_ymmm256_k1z_zmm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsYMM()) {
				op = Code.EVEX_Vpmovwb_xmmm128_k1z_ymm;
			} else if (dst.Size == MemoryOperandSize.DQwordPtr && src.IsXMM()) {
				op = Code.EVEX_Vpmovwb_xmmm64_k1z_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovwb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxbd instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBD ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBD zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxbd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxbd_zmm_k1z_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovzxbd_ymm_xmmm64;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovzxbd_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxbd instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXBD xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBD ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBD xmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBD ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBD zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 31 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxbd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxbd_zmm_k1z_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovzxbd_ymm_xmmm64;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxbd_ymm_k1z_xmmm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovzxbd_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxbd_xmm_k1z_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxbd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxbq instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBQ ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBQ zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxbq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxbq_zmm_k1z_xmmm64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovzxbq_ymm_xmmm32;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovzxbq_xmm_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxbq instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXBQ xmm1, xmm2/m16</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBQ ymm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBQ xmm1 {k1}{z}, xmm2/m16</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBQ ymm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBQ zmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 32 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxbq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxbq_zmm_k1z_xmmm64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovzxbq_ymm_xmmm32;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxbq_ymm_k1z_xmmm32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovzxbq_xmm_xmmm16;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxbq_xmm_k1z_xmmm16;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxbq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxbw instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBW ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBW zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxbw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxbw_zmm_k1z_ymmm256;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovzxbw_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovzxbw_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxbw instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXBW xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBW ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBW xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBW ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXBW zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 30 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxbw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxbw_zmm_k1z_ymmm256;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovzxbw_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxbw_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovzxbw_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxbw_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxbw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxdq instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 35 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXDQ ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 35 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXDQ zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxdq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxdq_zmm_k1z_ymmm256;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovzxdq_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovzxdq_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxdq instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXDQ xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 35 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXDQ ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 35 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXDQ xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXDQ ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXDQ zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 35 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxdq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxdq_zmm_k1z_ymmm256;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovzxdq_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxdq_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovzxdq_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxdq_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxwd instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWD zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxwd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxwd_zmm_k1z_ymmm256;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovzxwd_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovzxwd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxwd instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXWD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWD ymm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWD xmm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWD ymm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWD zmm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 33 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxwd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxwd_zmm_k1z_ymmm256;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovzxwd_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxwd_ymm_k1z_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovzxwd_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxwd_xmm_k1z_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxwd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxwq instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWQ ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWQ zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxwq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxwq_zmm_k1z_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmovzxwq_ymm_xmmm64;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmovzxwq_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmovzxwq instruction.<br/>
		/// <br/>
		/// <c>VPMOVZXWQ xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWQ ymm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWQ xmm1 {k1}{z}, xmm2/m32</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWQ ymm1 {k1}{z}, xmm2/m64</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMOVZXWQ zmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 34 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmovzxwq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmovzxwq_zmm_k1z_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmovzxwq_ymm_xmmm64;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxwq_ymm_k1z_xmmm64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmovzxwq_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmovzxwq_xmm_k1z_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmovzxwq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpmuldq instruction.<br/>
		/// <br/>
		/// <c>VPMULDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmuldq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmuldq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmuldq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmuldq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmuldq instruction.<br/>
		/// <br/>
		/// <c>VPMULDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 28 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 28 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmuldq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmuldq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmuldq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmuldq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulhrsw instruction.<br/>
		/// <br/>
		/// <c>VPMULHRSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHRSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHRSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulhrsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmulhrsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmulhrsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulhrsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulhrsw instruction.<br/>
		/// <br/>
		/// <c>VPMULHRSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHRSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHRSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHRSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHRSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 0B /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulhrsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmulhrsw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmulhrsw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulhrsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulhuw instruction.<br/>
		/// <br/>
		/// <c>VPMULHUW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHUW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHUW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulhuw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmulhuw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmulhuw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulhuw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulhuw instruction.<br/>
		/// <br/>
		/// <c>VPMULHUW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHUW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHUW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHUW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHUW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E4 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulhuw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmulhuw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmulhuw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulhuw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulhw instruction.<br/>
		/// <br/>
		/// <c>VPMULHW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulhw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmulhw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmulhw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulhw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulhw instruction.<br/>
		/// <br/>
		/// <c>VPMULHW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULHW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E5 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulhw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmulhw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmulhw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulhw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulld instruction.<br/>
		/// <br/>
		/// <c>VPMULLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 40 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 40 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmulld_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmulld_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmulld instruction.<br/>
		/// <br/>
		/// <c>VPMULLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 40 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 40 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmulld(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmulld_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmulld_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmulld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmullq instruction.<br/>
		/// <br/>
		/// <c>VPMULLQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmullq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmullq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmullq instruction.<br/>
		/// <br/>
		/// <c>VPMULLQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 40 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmullq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmullq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmullw instruction.<br/>
		/// <br/>
		/// <c>VPMULLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmullw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmullw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmullw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmullw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmullw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmullw instruction.<br/>
		/// <br/>
		/// <c>VPMULLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULLW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D5 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmullw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmullw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmullw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmullw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmullw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmullw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmullw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmultishiftqb instruction.<br/>
		/// <br/>
		/// <c>VPMULTISHIFTQB xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 83 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULTISHIFTQB ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 83 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULTISHIFTQB zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 83 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmultishiftqb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmultishiftqb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmultishiftqb instruction.<br/>
		/// <br/>
		/// <c>VPMULTISHIFTQB xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 83 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULTISHIFTQB ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 83 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULTISHIFTQB zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 83 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmultishiftqb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmultishiftqb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmuludq instruction.<br/>
		/// <br/>
		/// <c>VPMULUDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F4 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULUDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F4 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULUDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 F4 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmuludq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpmuludq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpmuludq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmuludq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpmuludq instruction.<br/>
		/// <br/>
		/// <c>VPMULUDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F4 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULUDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F4 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULUDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 F4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULUDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 F4 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPMULUDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 F4 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpmuludq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpmuludq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpmuludq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpmuludq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpopcntb instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTB xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTB ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTB zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntb(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntb_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntb_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntb_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntb instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTB xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTB ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTB zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntb_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntb_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntb_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntb), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntd instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntd instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntd_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntd_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntd_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntq instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntq(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntq instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 55 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VPOPCNTDQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntq(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntq_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntq_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntq_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntw instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTW xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTW ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTW zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntw(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntw_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntw_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntw_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpopcntw instruction.<br/>
		/// <br/>
		/// <c>VPOPCNTW xmm1 {k1}{z}, xmm2/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTW ymm1 {k1}{z}, ymm2/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOPCNTW zmm1 {k1}{z}, zmm2/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 54 /r</c><br/>
		/// <br/>
		/// <c>AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpopcntw(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpopcntw_zmm_k1z_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpopcntw_ymm_k1z_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpopcntw_xmm_k1z_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpopcntw), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpor instruction.<br/>
		/// <br/>
		/// <c>VPOR xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EB /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOR ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EB /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpor(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpor_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpor_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpor), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpor instruction.<br/>
		/// <br/>
		/// <c>VPOR xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EB /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPOR ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EB /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpor(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpor_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpor_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpor), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpord instruction.<br/>
		/// <br/>
		/// <c>VPORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpord(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpord_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpord_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpord_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpord instruction.<br/>
		/// <br/>
		/// <c>VPORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpord(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpord_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpord_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpord_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vporq instruction.<br/>
		/// <br/>
		/// <c>VPORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vporq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vporq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vporq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vporq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vporq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vporq instruction.<br/>
		/// <br/>
		/// <c>VPORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 EB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vporq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vporq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vporq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vporq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vporq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpperm instruction.<br/>
		/// <br/>
		/// <c>VPPERM xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 A3 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpperm(Register dst, Register src, Register arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpperm_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpperm), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpperm instruction.<br/>
		/// <br/>
		/// <c>VPPERM xmm1, xmm2, xmm3/m128, xmm4</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W0 A3 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpperm(Register dst, Register src, ExtendedMemoryOperand arg2, Register arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpperm_xmm_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpperm), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vpperm instruction.<br/>
		/// <br/>
		/// <c>VPPERM xmm1, xmm2, xmm3, xmm4/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X8.W1 A3 /r /is4</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpperm(Register dst, Register src, Register arg2, ExtendedMemoryOperand arg3) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpperm_xmm_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpperm), dst, src, arg2, arg3);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, arg3));
		}
		/// <summary>vprold instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprold(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprold_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprold_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprold_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprold), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprold instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprold(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprold_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprold_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprold_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprold), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprolq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprolq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprolq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprolq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprolq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprolq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprolvd instruction.<br/>
		/// <br/>
		/// <c>VPROLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprolvd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vprolvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprolvd instruction.<br/>
		/// <br/>
		/// <c>VPROLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprolvd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vprolvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprolvq instruction.<br/>
		/// <br/>
		/// <c>VPROLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprolvq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vprolvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprolvq instruction.<br/>
		/// <br/>
		/// <c>VPROLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPROLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprolvq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vprolvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprord instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprord(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprord_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprord_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprord_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprord), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprord instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprord(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprord_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprord_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprord_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprord), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprorq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprorq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprorq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprorq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprorq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprorq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprorvd instruction.<br/>
		/// <br/>
		/// <c>VPRORVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprorvd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vprorvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprorvd instruction.<br/>
		/// <br/>
		/// <c>VPRORVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprorvd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vprorvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprorvq instruction.<br/>
		/// <br/>
		/// <c>VPRORVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprorvq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vprorvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprorvq instruction.<br/>
		/// <br/>
		/// <c>VPRORVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPRORVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprorvq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vprorvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotb instruction.<br/>
		/// <br/>
		/// <c>VPROTB xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 90 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotb_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotb instruction.<br/>
		/// <br/>
		/// <c>VPROTB xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 90 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotb(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotb_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotb instruction.<br/>
		/// <br/>
		/// <c>VPROTB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 90 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotb(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotb_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotb instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotb(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotb_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotb), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotd instruction.<br/>
		/// <br/>
		/// <c>VPROTD xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 92 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotd_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotd instruction.<br/>
		/// <br/>
		/// <c>VPROTD xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 92 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotd(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotd_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotd instruction.<br/>
		/// <br/>
		/// <c>VPROTD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 92 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotq instruction.<br/>
		/// <br/>
		/// <c>VPROTQ xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 93 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotq_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotq instruction.<br/>
		/// <br/>
		/// <c>VPROTQ xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 93 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotq(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotq_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotq instruction.<br/>
		/// <br/>
		/// <c>VPROTQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 93 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotq_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotq_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotw instruction.<br/>
		/// <br/>
		/// <c>VPROTW xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 91 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotw_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotw instruction.<br/>
		/// <br/>
		/// <c>VPROTW xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 91 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotw(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotw_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotw instruction.<br/>
		/// <br/>
		/// <c>VPROTW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 91 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vprotw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vprotw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vprotw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vprotw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vprotw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vprotw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsadbw instruction.<br/>
		/// <br/>
		/// <c>VPSADBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSADBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSADBW zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsadbw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsadbw_zmm_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsadbw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsadbw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsadbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsadbw instruction.<br/>
		/// <br/>
		/// <c>VPSADBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSADBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSADBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSADBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSADBW zmm1, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F6 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsadbw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsadbw_zmm_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsadbw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsadbw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsadbw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsadbw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsadbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpscatterdd instruction.<br/>
		/// <br/>
		/// <c>VPSCATTERDD vm32x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A0 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERDD vm32y {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A0 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERDD vm32z {k1}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A0 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpscatterdd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsZMM()) {
				op = Code.EVEX_Vpscatterdd_vm32z_k1_zmm;
			} else if (src.IsYMM()) {
				op = Code.EVEX_Vpscatterdd_vm32y_k1_ymm;
			} else if (src.IsXMM()) {
				op = Code.EVEX_Vpscatterdd_vm32x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpscatterdd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpscatterdq instruction.<br/>
		/// <br/>
		/// <c>VPSCATTERDQ vm32x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A0 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERDQ vm32x {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A0 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERDQ vm32y {k1}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A0 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpscatterdq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsZMM()) {
				op = Code.EVEX_Vpscatterdq_vm32y_k1_zmm;
			} else if (src.IsYMM()) {
				op = Code.EVEX_Vpscatterdq_vm32x_k1_ymm;
			} else if (src.IsXMM()) {
				op = Code.EVEX_Vpscatterdq_vm32x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpscatterdq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpscatterqd instruction.<br/>
		/// <br/>
		/// <c>VPSCATTERQD vm64x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERQD vm64y {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERQD vm64z {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpscatterqd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsYMM()) {
				op = Code.EVEX_Vpscatterqd_vm64z_k1_ymm;
			} else if (src.IsXMM() && dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vpscatterqd_vm64y_k1_xmm;
			} else if (src.IsXMM() && dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vpscatterqd_vm64x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpscatterqd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpscatterqq instruction.<br/>
		/// <br/>
		/// <c>VPSCATTERQQ vm64x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERQQ vm64y {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSCATTERQQ vm64z {k1}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A1 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpscatterqq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsZMM()) {
				op = Code.EVEX_Vpscatterqq_vm64z_k1_zmm;
			} else if (src.IsYMM()) {
				op = Code.EVEX_Vpscatterqq_vm64y_k1_ymm;
			} else if (src.IsXMM()) {
				op = Code.EVEX_Vpscatterqq_vm64x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpscatterqq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vpshab instruction.<br/>
		/// <br/>
		/// <c>VPSHAB xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 98 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshab(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshab_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshab), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshab instruction.<br/>
		/// <br/>
		/// <c>VPSHAB xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 98 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshab(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshab_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshab), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshab instruction.<br/>
		/// <br/>
		/// <c>VPSHAB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 98 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshab(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshab_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshab), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshad instruction.<br/>
		/// <br/>
		/// <c>VPSHAD xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 9A /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshad(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshad_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshad), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshad instruction.<br/>
		/// <br/>
		/// <c>VPSHAD xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 9A /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshad(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshad_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshad), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshad instruction.<br/>
		/// <br/>
		/// <c>VPSHAD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 9A /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshad(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshad_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshad), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshaq instruction.<br/>
		/// <br/>
		/// <c>VPSHAQ xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 9B /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshaq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshaq_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshaq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshaq instruction.<br/>
		/// <br/>
		/// <c>VPSHAQ xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 9B /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshaq(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshaq_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshaq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshaq instruction.<br/>
		/// <br/>
		/// <c>VPSHAQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 9B /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshaq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshaq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshaq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshaw instruction.<br/>
		/// <br/>
		/// <c>VPSHAW xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 99 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshaw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshaw_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshaw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshaw instruction.<br/>
		/// <br/>
		/// <c>VPSHAW xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 99 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshaw(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshaw_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshaw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshaw instruction.<br/>
		/// <br/>
		/// <c>VPSHAW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 99 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshaw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshaw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshaw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlb instruction.<br/>
		/// <br/>
		/// <c>VPSHLB xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 94 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlb_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlb instruction.<br/>
		/// <br/>
		/// <c>VPSHLB xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 94 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlb(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlb_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlb instruction.<br/>
		/// <br/>
		/// <c>VPSHLB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 94 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshld instruction.<br/>
		/// <br/>
		/// <c>VPSHLD xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 96 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshld_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshld instruction.<br/>
		/// <br/>
		/// <c>VPSHLD xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 96 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshld(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshld_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshld instruction.<br/>
		/// <br/>
		/// <c>VPSHLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 96 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshld(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshld_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshldd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshldd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshldd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshldq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshldq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshldvd instruction.<br/>
		/// <br/>
		/// <c>VPSHLDVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshldvd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldvd instruction.<br/>
		/// <br/>
		/// <c>VPSHLDVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshldvd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldvq instruction.<br/>
		/// <br/>
		/// <c>VPSHLDVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshldvq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldvq instruction.<br/>
		/// <br/>
		/// <c>VPSHLDVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 71 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshldvq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldvw instruction.<br/>
		/// <br/>
		/// <c>VPSHLDVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 70 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 70 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 70 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshldvw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldvw instruction.<br/>
		/// <br/>
		/// <c>VPSHLDVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 70 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 70 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHLDVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 70 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshldvw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshldw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshldw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshldw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshldw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshldw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshlq instruction.<br/>
		/// <br/>
		/// <c>VPSHLQ xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 97 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlq_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlq instruction.<br/>
		/// <br/>
		/// <c>VPSHLQ xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 97 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlq(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlq_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlq instruction.<br/>
		/// <br/>
		/// <c>VPSHLQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 97 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlw instruction.<br/>
		/// <br/>
		/// <c>VPSHLW xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 95 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlw_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlw instruction.<br/>
		/// <br/>
		/// <c>VPSHLW xmm1, xmm2/m128, xmm3</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W0 95 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlw(Register dst, ExtendedMemoryOperand src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlw_xmm_xmmm128_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshlw instruction.<br/>
		/// <br/>
		/// <c>VPSHLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>XOP.128.X9.W1 95 /r</c><br/>
		/// <br/>
		/// <c>XOP</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshlw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.XOP_Vpshlw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshlw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshrdd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshrdd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshrdd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshrdq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshrdq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshrdq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshrdq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshrdvd instruction.<br/>
		/// <br/>
		/// <c>VPSHRDVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshrdvd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdvd instruction.<br/>
		/// <br/>
		/// <c>VPSHRDVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshrdvd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdvq instruction.<br/>
		/// <br/>
		/// <c>VPSHRDVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshrdvq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdvq instruction.<br/>
		/// <br/>
		/// <c>VPSHRDVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 73 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshrdvq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdvw instruction.<br/>
		/// <br/>
		/// <c>VPSHRDVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshrdvw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdvw instruction.<br/>
		/// <br/>
		/// <c>VPSHRDVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHRDVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 72 /r</c><br/>
		/// <br/>
		/// <c>AVX512_VBMI2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshrdvw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshrdw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshrdw(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshrdw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshrdw(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshrdw), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpshufb instruction.<br/>
		/// <br/>
		/// <c>VPSHUFB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshufb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshufb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpshufb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpshufb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshufb instruction.<br/>
		/// <br/>
		/// <c>VPSHUFB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.WIG 00 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshufb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshufb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpshufb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpshufb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpshufb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpshufb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshufbitqmb instruction.<br/>
		/// <br/>
		/// <c>VPSHUFBITQMB k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFBITQMB k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFBITQMB k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8F /r</c><br/>
		/// <br/>
		/// <c>AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshufbitqmb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpshufbitqmb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpshufbitqmb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpshufbitqmb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufbitqmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshufbitqmb instruction.<br/>
		/// <br/>
		/// <c>VPSHUFBITQMB k1 {k2}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 8F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFBITQMB k1 {k2}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 8F /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSHUFBITQMB k1 {k2}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 8F /r</c><br/>
		/// <br/>
		/// <c>AVX512_BITALG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpshufbitqmb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vpshufbitqmb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vpshufbitqmb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vpshufbitqmb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufbitqmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpshufd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshufd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpshufd_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpshufd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpshufd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshufd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpshufd_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpshufd_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpshufhw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshufhw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpshufhw_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpshufhw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufhw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpshufhw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshufhw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpshufhw_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpshufhw_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshufhw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpshuflw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshuflw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpshuflw_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpshuflw_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshuflw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpshuflw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpshuflw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpshuflw_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpshuflw_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpshuflw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsignb instruction.<br/>
		/// <br/>
		/// <c>VPSIGNB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 08 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSIGNB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 08 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsignb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpsignb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsignb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsignb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsignb instruction.<br/>
		/// <br/>
		/// <c>VPSIGNB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 08 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSIGNB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 08 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsignb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpsignb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsignb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsignb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsignd instruction.<br/>
		/// <br/>
		/// <c>VPSIGND xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 0A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSIGND ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 0A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsignd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpsignd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsignd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsignd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsignd instruction.<br/>
		/// <br/>
		/// <c>VPSIGND xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 0A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSIGND ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 0A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsignd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpsignd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsignd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsignd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsignw instruction.<br/>
		/// <br/>
		/// <c>VPSIGNW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 09 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSIGNW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 09 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsignw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpsignw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsignw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsignw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsignw instruction.<br/>
		/// <br/>
		/// <c>VPSIGNW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 09 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSIGNW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 09 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsignw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpsignw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsignw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsignw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpslld instruction.<br/>
		/// <br/>
		/// <c>VPSLLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F2 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLD ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F2 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLD zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 F2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpslld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpslld_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpslld_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpslld_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpslld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpslld instruction.<br/>
		/// <br/>
		/// <c>VPSLLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F2 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLD ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F2 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLD xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 F2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLD ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 F2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLD zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 F2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpslld(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpslld_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpslld_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpslld_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpslld_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpslld_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpslld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpslld instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpslld(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpslld_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpslld_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpslld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpslld instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpslld(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpslld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpslldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpslldq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpslldq_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpslldq_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpslldq_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpslldq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpslldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpslldq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpslldq_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpslldq_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpslldq_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpslldq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsllq instruction.<br/>
		/// <br/>
		/// <c>VPSLLQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F3 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLQ ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F3 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLQ zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 F3 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllq_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsllq_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsllq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllq instruction.<br/>
		/// <br/>
		/// <c>VPSLLQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F3 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLQ ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F3 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLQ xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 F3 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLQ ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 F3 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLQ zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 F3 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllq_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsllq_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsllq_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsllq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsllq_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsllq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsllq_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsllq_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsllq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsllq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsllvd instruction.<br/>
		/// <br/>
		/// <c>VPSLLVD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllvd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsllvd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsllvd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllvd instruction.<br/>
		/// <br/>
		/// <c>VPSLLVD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllvd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsllvd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsllvd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllvq instruction.<br/>
		/// <br/>
		/// <c>VPSLLVQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllvq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsllvq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsllvq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllvq instruction.<br/>
		/// <br/>
		/// <c>VPSLLVQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 47 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllvq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsllvq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsllvq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllvw instruction.<br/>
		/// <br/>
		/// <c>VPSLLVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllvw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllvw instruction.<br/>
		/// <br/>
		/// <c>VPSLLVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 12 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllvw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllw instruction.<br/>
		/// <br/>
		/// <c>VPSLLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLW ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLW zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllw_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsllw_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsllw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllw instruction.<br/>
		/// <br/>
		/// <c>VPSLLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLW ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLW ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSLLW zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F1 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsllw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllw_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsllw_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsllw_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsllw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsllw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsllw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsllw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsllw_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsllw_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsllw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsllw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsllw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsllw_ymm_k1z_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsllw_xmm_k1z_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsllw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrad instruction.<br/>
		/// <br/>
		/// <c>VPSRAD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E2 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAD ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E2 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAD zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrad(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrad_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrad_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrad_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrad), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrad instruction.<br/>
		/// <br/>
		/// <c>VPSRAD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E2 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAD ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E2 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAD xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAD ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAD zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrad(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrad_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsrad_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsrad_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsrad_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsrad_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrad), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrad instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrad(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrad_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrad_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrad), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrad instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrad(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrad), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsraq instruction.<br/>
		/// <br/>
		/// <c>VPSRAQ xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAQ ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAQ zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsraq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraq_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsraq_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsraq_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsraq instruction.<br/>
		/// <br/>
		/// <c>VPSRAQ xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAQ ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAQ zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 E2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsraq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraq_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsraq_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsraq_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsraq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsraq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsraq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsraq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsravd instruction.<br/>
		/// <br/>
		/// <c>VPSRAVD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsravd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsravd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsravd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsravd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsravd instruction.<br/>
		/// <br/>
		/// <c>VPSRAVD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsravd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsravd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsravd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsravd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsravq instruction.<br/>
		/// <br/>
		/// <c>VPSRAVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsravq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsravq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsravq instruction.<br/>
		/// <br/>
		/// <c>VPSRAVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 46 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsravq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsravq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsravw instruction.<br/>
		/// <br/>
		/// <c>VPSRAVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsravw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsravw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsravw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsravw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsravw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsravw instruction.<br/>
		/// <br/>
		/// <c>VPSRAVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 11 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsravw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsravw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsravw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsravw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsravw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsraw instruction.<br/>
		/// <br/>
		/// <c>VPSRAW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAW ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAW zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsraw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraw_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsraw_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsraw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsraw instruction.<br/>
		/// <br/>
		/// <c>VPSRAW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAW ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAW ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRAW zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E1 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsraw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraw_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsraw_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsraw_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsraw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsraw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsraw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsraw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsraw_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsraw_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsraw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsraw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsraw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsraw_ymm_k1z_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsraw_xmm_k1z_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsraw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrld instruction.<br/>
		/// <br/>
		/// <c>VPSRLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D2 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLD ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D2 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLD zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 D2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrld_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrld_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrld_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrld instruction.<br/>
		/// <br/>
		/// <c>VPSRLD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D2 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLD ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D2 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLD xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 D2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLD ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 D2 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLD zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 D2 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrld(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrld_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsrld_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsrld_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsrld_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsrld_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrld), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrld instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrld(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrld_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrld_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrld instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrld(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrld), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrldq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrldq_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrldq_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrldq_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrldq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrldq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrldq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrldq_zmm_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrldq_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrldq_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrldq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrlq instruction.<br/>
		/// <br/>
		/// <c>VPSRLQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D3 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLQ ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D3 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLQ zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 D3 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrlq_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrlq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlq instruction.<br/>
		/// <br/>
		/// <c>VPSRLQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D3 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLQ ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D3 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLQ xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 D3 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLQ ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 D3 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLQ zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 D3 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsrlq_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsrlq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrlq(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrlq_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrlq_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrlq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrlq(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlq), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrlvd instruction.<br/>
		/// <br/>
		/// <c>VPSRLVD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlvd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrlvd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrlvd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlvd instruction.<br/>
		/// <br/>
		/// <c>VPSRLVD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlvd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsrlvd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsrlvd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlvd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlvq instruction.<br/>
		/// <br/>
		/// <c>VPSRLVQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlvq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrlvq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrlvq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlvq instruction.<br/>
		/// <br/>
		/// <c>VPSRLVQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 45 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlvq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsrlvq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsrlvq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlvq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlvw instruction.<br/>
		/// <br/>
		/// <c>VPSRLVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlvw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlvw instruction.<br/>
		/// <br/>
		/// <c>VPSRLVW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLVW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 10 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlvw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlvw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlw instruction.<br/>
		/// <br/>
		/// <c>VPSRLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLW ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLW zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrlw_ymm_ymm_xmmm128;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrlw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlw instruction.<br/>
		/// <br/>
		/// <c>VPSRLW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLW ymm1, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLW ymm1 {k1}{z}, ymm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSRLW zmm1 {k1}{z}, zmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D1 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsrlw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsrlw_ymm_ymm_xmmm128;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsrlw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsrlw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrlw(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsrlw_ymm_ymm_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsrlw_xmm_xmm_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsrlw instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpsrlw(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsrlw), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vpsubb instruction.<br/>
		/// <br/>
		/// <c>VPSUBB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubb instruction.<br/>
		/// <br/>
		/// <c>VPSUBB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F8 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubd instruction.<br/>
		/// <br/>
		/// <c>VPSUBD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FA /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FA /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 FA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubd instruction.<br/>
		/// <br/>
		/// <c>VPSUBD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FA /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FA /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 FA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 FA /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 FA /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubq instruction.<br/>
		/// <br/>
		/// <c>VPSUBQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FB /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FB /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 FB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubq instruction.<br/>
		/// <br/>
		/// <c>VPSUBQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG FB /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG FB /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 FB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 FB /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 FB /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubsb instruction.<br/>
		/// <br/>
		/// <c>VPSUBSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubsb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubsb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubsb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubsb instruction.<br/>
		/// <br/>
		/// <c>VPSUBSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E8 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubsb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubsb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubsb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubsb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubsw instruction.<br/>
		/// <br/>
		/// <c>VPSUBSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubsw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubsw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubsw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubsw instruction.<br/>
		/// <br/>
		/// <c>VPSUBSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG E9 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubsw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubsw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubsw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubsw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubusb instruction.<br/>
		/// <br/>
		/// <c>VPSUBUSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubusb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubusb_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubusb_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubusb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubusb instruction.<br/>
		/// <br/>
		/// <c>VPSUBUSB xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSB ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSB xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSB ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSB zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D8 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubusb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubusb_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubusb_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubusb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubusw instruction.<br/>
		/// <br/>
		/// <c>VPSUBUSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubusw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubusw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubusw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubusw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubusw instruction.<br/>
		/// <br/>
		/// <c>VPSUBUSW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBUSW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG D9 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubusw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubusw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubusw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubusw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubw instruction.<br/>
		/// <br/>
		/// <c>VPSUBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpsubw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpsubw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpsubw instruction.<br/>
		/// <br/>
		/// <c>VPSUBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPSUBW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG F9 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpsubw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpsubw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpsubw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpsubw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpsubw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpsubw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpsubw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpternlogd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpternlogd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpternlogd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpternlogd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpternlogd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpternlogd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpternlogq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpternlogq(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpternlogq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vpternlogq instruction.<br/>
		/// <br/>
		/// </summary>
		public void vpternlogq(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vpternlogq), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vptest instruction.<br/>
		/// <br/>
		/// <c>VPTEST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTEST ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptest(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vptest_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vptest_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptest), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vptest instruction.<br/>
		/// <br/>
		/// <c>VPTEST xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTEST ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.WIG 17 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptest(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vptest_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vptest_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptest), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vptestmb instruction.<br/>
		/// <br/>
		/// <c>VPTESTMB k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMB k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMB k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmb instruction.<br/>
		/// <br/>
		/// <c>VPTESTMB k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMB k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMB k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmd instruction.<br/>
		/// <br/>
		/// <c>VPTESTMD k2 {k1}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMD k2 {k1}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmd instruction.<br/>
		/// <br/>
		/// <c>VPTESTMD k2 {k1}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMD k2 {k1}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmq instruction.<br/>
		/// <br/>
		/// <c>VPTESTMQ k2 {k1}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMQ k2 {k1}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMQ k2 {k1}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmq instruction.<br/>
		/// <br/>
		/// <c>VPTESTMQ k2 {k1}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMQ k2 {k1}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMQ k2 {k1}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmw instruction.<br/>
		/// <br/>
		/// <c>VPTESTMW k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMW k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMW k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestmw instruction.<br/>
		/// <br/>
		/// <c>VPTESTMW k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMW k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTMW k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestmw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestmw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestmw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestmw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestmw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmb instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMB k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMB k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMB k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmb(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmb instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMB k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMB k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMB k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmb(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmb_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmb_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmb_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmb), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmd instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMD k2 {k1}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMD k2 {k1}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMD k2 {k1}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmd instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMD k2 {k1}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMD k2 {k1}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMD k2 {k1}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W0 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmd_k_k1_zmm_zmmm512b32;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmd_k_k1_ymm_ymmm256b32;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmd_k_k1_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmq instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMQ k2 {k1}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMQ k2 {k1}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMQ k2 {k1}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmq instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMQ k2 {k1}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMQ k2 {k1}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMQ k2 {k1}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 27 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmq_k_k1_zmm_zmmm512b64;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmq_k_k1_ymm_ymmm256b64;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmq_k_k1_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmw instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMW k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMW k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMW k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vptestnmw instruction.<br/>
		/// <br/>
		/// <c>VPTESTNMW k2 {k1}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.F3.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMW k2 {k1}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.F3.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPTESTNMW k2 {k1}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.F3.0F38.W1 26 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vptestnmw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsK() && src.IsZMM()) {
				op = Code.EVEX_Vptestnmw_k_k1_zmm_zmmm512;
			} else if (dst.IsK() && src.IsYMM()) {
				op = Code.EVEX_Vptestnmw_k_k1_ymm_ymmm256;
			} else if (dst.IsK() && src.IsXMM()) {
				op = Code.EVEX_Vptestnmw_k_k1_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vptestnmw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhbw instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHBW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhbw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpckhbw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpckhbw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhbw instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHBW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHBW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHBW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 68 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhbw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpckhbw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpckhbw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhdq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 6A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhdq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpckhdq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpckhdq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhdq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6A /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6A /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 6A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 6A /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 6A /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhdq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpckhdq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpckhdq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhqdq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHQDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHQDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6D /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 6D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhqdq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpckhqdq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpckhqdq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhqdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhqdq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHQDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6D /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHQDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6D /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 6D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHQDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 6D /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 6D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhqdq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpckhqdq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpckhqdq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhqdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhwd instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHWD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHWD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHWD zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhwd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpckhwd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpckhwd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckhwd instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKHWD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHWD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHWD xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHWD ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKHWD zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 69 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckhwd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpckhwd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpckhwd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckhwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpcklbw instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLBW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpcklbw(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpcklbw_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpcklbw_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpcklbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpcklbw instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLBW xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLBW ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLBW xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLBW ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLBW zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 60 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpcklbw(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpcklbw_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpcklbw_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpcklbw), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckldq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 62 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 62 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckldq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpckldq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpckldq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckldq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpckldq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 62 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 62 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 62 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpckldq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpckldq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpckldq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpckldq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpcklqdq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLQDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLQDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 6C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpcklqdq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpcklqdq_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpcklqdq_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpcklqdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpcklqdq instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLQDQ xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 6C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLQDQ ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 6C /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 6C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLQDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 6C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 6C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpcklqdq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpcklqdq_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpcklqdq_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpcklqdq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpcklwd instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLWD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLWD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLWD zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpcklwd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vpunpcklwd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpunpcklwd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpcklwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpunpcklwd instruction.<br/>
		/// <br/>
		/// <c>VPUNPCKLWD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLWD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLWD xmm1 {k1}{z}, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLWD ymm1 {k1}{z}, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPUNPCKLWD zmm1 {k1}{z}, zmm2, zmm3/m512</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.WIG 61 /r</c><br/>
		/// <br/>
		/// <c>AVX512BW</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpunpcklwd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vpunpcklwd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vpunpcklwd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpunpcklwd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpxor instruction.<br/>
		/// <br/>
		/// <c>VPXOR xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EF /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXOR ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EF /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpxor(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpxor_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpxor_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpxor), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpxor instruction.<br/>
		/// <br/>
		/// <c>VPXOR xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG EF /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXOR ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG EF /r</c><br/>
		/// <br/>
		/// <c>AVX2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpxor(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vpxor_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vpxor_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vpxor), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpxord instruction.<br/>
		/// <br/>
		/// <c>VPXORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpxord(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpxord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpxord instruction.<br/>
		/// <br/>
		/// <c>VPXORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W0 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W0 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W0 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpxord(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vpxord), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpxorq instruction.<br/>
		/// <br/>
		/// <c>VPXORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpxorq(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpxorq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vpxorq instruction.<br/>
		/// <br/>
		/// <c>VPXORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VPXORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 EF /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vpxorq(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vpxorq), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrangepd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangepd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangepd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangepd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangepd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangepd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangeps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangeps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangeps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangeps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangeps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangeps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangesd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangesd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangesd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangesd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangesd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangesd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangess instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangess(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangess), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrangess instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrangess(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrangess), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrcp14pd instruction.<br/>
		/// <br/>
		/// <c>VRCP14PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PD zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp14pd_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrcp14pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp14pd instruction.<br/>
		/// <br/>
		/// <c>VRCP14PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PD zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp14pd_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrcp14pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp14ps instruction.<br/>
		/// <br/>
		/// <c>VRCP14PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PS zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp14ps_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrcp14ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp14ps instruction.<br/>
		/// <br/>
		/// <c>VRCP14PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCP14PS zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 4C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp14ps_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrcp14ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp14sd instruction.<br/>
		/// <br/>
		/// <c>VRCP14SD xmm1 {k1}{z}, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 4D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp14sd instruction.<br/>
		/// <br/>
		/// <c>VRCP14SD xmm1 {k1}{z}, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 4D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp14ss instruction.<br/>
		/// <br/>
		/// <c>VRCP14SS xmm1 {k1}{z}, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 4D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp14ss instruction.<br/>
		/// <br/>
		/// <c>VRCP14SS xmm1 {k1}{z}, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 4D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp14ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp14ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp28pd instruction.<br/>
		/// <br/>
		/// <c>VRCP28PD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 CA /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp28pd instruction.<br/>
		/// <br/>
		/// <c>VRCP28PD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 CA /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp28ps instruction.<br/>
		/// <br/>
		/// <c>VRCP28PS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 CA /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp28ps instruction.<br/>
		/// <br/>
		/// <c>VRCP28PS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 CA /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcp28sd instruction.<br/>
		/// <br/>
		/// <c>VRCP28SD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 CB /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp28sd instruction.<br/>
		/// <br/>
		/// <c>VRCP28SD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 CB /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp28ss instruction.<br/>
		/// <br/>
		/// <c>VRCP28SS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 CB /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcp28ss instruction.<br/>
		/// <br/>
		/// <c>VRCP28SS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 CB /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcp28ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcp28ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcpps instruction.<br/>
		/// <br/>
		/// <c>VRCPPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 53 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCPPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 53 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcpps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vrcpps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vrcpps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcpps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcpps instruction.<br/>
		/// <br/>
		/// <c>VRCPPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 53 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRCPPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 53 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcpps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vrcpps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vrcpps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcpps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrcpss instruction.<br/>
		/// <br/>
		/// <c>VRCPSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 53 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcpss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vrcpss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcpss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrcpss instruction.<br/>
		/// <br/>
		/// <c>VRCPSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 53 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrcpss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vrcpss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrcpss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vreducepd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreducepd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vreducepd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vreducepd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreducepd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vreducepd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vreduceps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreduceps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vreduceps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vreduceps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreduceps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vreduceps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vreducesd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreducesd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vreducesd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vreducesd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreducesd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vreducesd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vreducess instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreducess(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vreducess), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vreducess instruction.<br/>
		/// <br/>
		/// </summary>
		public void vreducess(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vreducess), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrndscalepd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscalepd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscalepd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vrndscalepd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscalepd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscalepd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vrndscaleps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscaleps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscaleps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vrndscaleps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscaleps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscaleps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vrndscalesd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscalesd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscalesd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrndscalesd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscalesd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscalesd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrndscaless instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscaless(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscaless), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrndscaless instruction.<br/>
		/// <br/>
		/// </summary>
		public void vrndscaless(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrndscaless), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vroundpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundpd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vroundpd_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vroundpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vroundpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundpd(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vroundpd_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vroundpd_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundpd), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vroundps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundps(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vroundps_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vroundps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vroundps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundps(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vroundps_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vroundps_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundps), dst, src, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		/// <summary>vroundsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundsd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vroundsd_xmm_xmm_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vroundsd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundsd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vroundsd_xmm_xmm_xmmm64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundsd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vroundss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundss(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vroundss_xmm_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vroundss instruction.<br/>
		/// <br/>
		/// </summary>
		public void vroundss(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vroundss_xmm_xmm_xmmm32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vroundss), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vrsqrt14pd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PD zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt14pd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14PD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PD zmm1 {k1}{z}, zmm2/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt14ps instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PS zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt14ps instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14PS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRT14PS zmm1 {k1}{z}, zmm2/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 4E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt14sd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14SD xmm1 {k1}{z}, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 4F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt14sd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14SD xmm1 {k1}{z}, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 4F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt14ss instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14SS xmm1 {k1}{z}, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 4F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt14ss instruction.<br/>
		/// <br/>
		/// <c>VRSQRT14SS xmm1 {k1}{z}, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 4F /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt14ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt14ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt28pd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28PD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 CC /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28pd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt28pd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28PD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 CC /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28pd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28pd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt28ps instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28PS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 CC /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28ps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt28ps instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28PS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 CC /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28ps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28ps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrt28sd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28SD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 CD /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28sd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt28sd instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28SD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 CD /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28sd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28sd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt28ss instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28SS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 CD /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28ss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrt28ss instruction.<br/>
		/// <br/>
		/// <c>VRSQRT28SS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 CD /r</c><br/>
		/// <br/>
		/// <c>AVX512ER</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrt28ss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrt28ss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrtps instruction.<br/>
		/// <br/>
		/// <c>VRSQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 52 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRTPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 52 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrtps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vrsqrtps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vrsqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrtps instruction.<br/>
		/// <br/>
		/// <c>VRSQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 52 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VRSQRTPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 52 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrtps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vrsqrtps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vrsqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vrsqrtss instruction.<br/>
		/// <br/>
		/// <c>VRSQRTSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 52 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrtss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vrsqrtss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrtss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vrsqrtss instruction.<br/>
		/// <br/>
		/// <c>VRSQRTSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 52 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vrsqrtss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vrsqrtss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vrsqrtss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefpd instruction.<br/>
		/// <br/>
		/// <c>VSCALEFPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefpd instruction.<br/>
		/// <br/>
		/// <c>VSCALEFPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefps instruction.<br/>
		/// <br/>
		/// <c>VSCALEFPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefps instruction.<br/>
		/// <br/>
		/// <c>VSCALEFPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCALEFPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 2C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefsd instruction.<br/>
		/// <br/>
		/// <c>VSCALEFSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefsd instruction.<br/>
		/// <br/>
		/// <c>VSCALEFSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W1 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefss instruction.<br/>
		/// <br/>
		/// <c>VSCALEFSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscalefss instruction.<br/>
		/// <br/>
		/// <c>VSCALEFSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F38.W0 2D /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscalefss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vscalefss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vscatterdpd instruction.<br/>
		/// <br/>
		/// <c>VSCATTERDPD vm32x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERDPD vm32x {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERDPD vm32y {k1}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterdpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsZMM()) {
				op = Code.EVEX_Vscatterdpd_vm32y_k1_zmm;
			} else if (src.IsYMM()) {
				op = Code.EVEX_Vscatterdpd_vm32x_k1_ymm;
			} else if (src.IsXMM()) {
				op = Code.EVEX_Vscatterdpd_vm32x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vscatterdpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vscatterdps instruction.<br/>
		/// <br/>
		/// <c>VSCATTERDPS vm32x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERDPS vm32y {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERDPS vm32z {k1}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A2 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterdps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsZMM()) {
				op = Code.EVEX_Vscatterdps_vm32z_k1_zmm;
			} else if (src.IsYMM()) {
				op = Code.EVEX_Vscatterdps_vm32y_k1_ymm;
			} else if (src.IsXMM()) {
				op = Code.EVEX_Vscatterdps_vm32x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vscatterdps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vscatterpf0dpd instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF0DPD vm32y {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C6 /5 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf0dpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf0dpd_vm32y_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf0dps instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF0DPS vm32z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C6 /5 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf0dps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf0dps_vm32z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf0qpd instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF0QPD vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C7 /5 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf0qpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf0qpd_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf0qps instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF0QPS vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C7 /5 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf0qps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf0qps_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf1dpd instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF1DPD vm32y {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C6 /6 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf1dpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf1dpd_vm32y_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf1dps instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF1DPS vm32z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C6 /6 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf1dps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf1dps_vm32z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf1qpd instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF1QPD vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 C7 /6 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf1qpd(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf1qpd_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterpf1qps instruction.<br/>
		/// <br/>
		/// <c>VSCATTERPF1QPS vm64z {k1}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 C7 /6 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512PF</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterpf1qps(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.EVEX_Vscatterpf1qps_vm64z_k1;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vscatterqpd instruction.<br/>
		/// <br/>
		/// <c>VSCATTERQPD vm64x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W1 A3 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERQPD vm64y {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W1 A3 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERQPD vm64z {k1}, zmm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W1 A3 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterqpd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsZMM()) {
				op = Code.EVEX_Vscatterqpd_vm64z_k1_zmm;
			} else if (src.IsYMM()) {
				op = Code.EVEX_Vscatterqpd_vm64y_k1_ymm;
			} else if (src.IsXMM()) {
				op = Code.EVEX_Vscatterqpd_vm64x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vscatterqpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vscatterqps instruction.<br/>
		/// <br/>
		/// <c>VSCATTERQPS vm64x {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F38.W0 A3 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERQPS vm64y {k1}, xmm1</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F38.W0 A3 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSCATTERQPS vm64z {k1}, ymm1</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F38.W0 A3 /vsib</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vscatterqps(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsYMM()) {
				op = Code.EVEX_Vscatterqps_vm64z_k1_ymm;
			} else if (src.IsXMM() && dst.Size == MemoryOperandSize.YwordPtr) {
				op = Code.EVEX_Vscatterqps_vm64y_k1_xmm;
			} else if (src.IsXMM() && dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.EVEX_Vscatterqps_vm64x_k1_xmm;
			} else {
				throw NoOpCodeFoundFor(nameof(vscatterqps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vshuff32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshuff32x4(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshuff32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshuff32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshuff32x4(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshuff32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshuff64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshuff64x2(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshuff64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshuff64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshuff64x2(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshuff64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufi32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufi32x4(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufi32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufi32x4 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufi32x4(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufi32x4), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufi64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufi64x2(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufi64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufi64x2 instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufi64x2(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufi64x2), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufpd(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vshufpd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vshufpd_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufpd instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufpd(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vshufpd_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vshufpd_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufpd), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufps(Register dst, Register src, Register arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vshufps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vshufps_xmm_xmm_xmmm128_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vshufps instruction.<br/>
		/// <br/>
		/// </summary>
		public void vshufps(Register dst, Register src, ExtendedMemoryOperand arg2, int imm) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vshufps_ymm_ymm_ymmm256_imm8;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vshufps_xmm_xmm_xmmm128_imm8;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8;
			} else {
				throw NoOpCodeFoundFor(nameof(vshufps), dst, src, arg2, imm);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2, imm));
		}
		/// <summary>vsqrtpd instruction.<br/>
		/// <br/>
		/// <c>VSQRTPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtpd(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vsqrtpd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vsqrtpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vsqrtpd instruction.<br/>
		/// <br/>
		/// <c>VSQRTPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPD xmm1 {k1}{z}, xmm2/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPD ymm1 {k1}{z}, ymm2/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vsqrtpd_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vsqrtpd_ymm_k1z_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsqrtpd_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsqrtpd_xmm_k1z_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vsqrtps instruction.<br/>
		/// <br/>
		/// <c>VSQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtps(Register dst, Register src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vsqrtps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vsqrtps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vsqrtps instruction.<br/>
		/// <br/>
		/// <c>VSQRTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPS xmm1 {k1}{z}, xmm2/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPS ymm1 {k1}{z}, ymm2/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vsqrtps_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vsqrtps_ymm_k1z_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsqrtps_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsqrtps_xmm_k1z_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vsqrtsd instruction.<br/>
		/// <br/>
		/// <c>VSQRTSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vsqrtsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsqrtsd instruction.<br/>
		/// <br/>
		/// <c>VSQRTSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsqrtsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsqrtss instruction.<br/>
		/// <br/>
		/// <c>VSQRTSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vsqrtss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsqrtss instruction.<br/>
		/// <br/>
		/// <c>VSQRTSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 51 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSQRTSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 51 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsqrtss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsqrtss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vsqrtss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vstmxcsr instruction.<br/>
		/// <br/>
		/// <c>VSTMXCSR m32</c><br/>
		/// <br/>
		/// <c>VEX.LZ.0F.WIG AE /3</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vstmxcsr(ExtendedMemoryOperand dst) {
			Code op;
			op = Code.VEX_Vstmxcsr_m32;
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>vsubpd instruction.<br/>
		/// <br/>
		/// <c>VSUBPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vsubpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vsubpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubpd instruction.<br/>
		/// <br/>
		/// <c>VSUBPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vsubpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsubpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubps instruction.<br/>
		/// <br/>
		/// <c>VSUBPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vsubps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vsubps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubps instruction.<br/>
		/// <br/>
		/// <c>VSUBPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vsubps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsubps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubsd instruction.<br/>
		/// <br/>
		/// <c>VSUBSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubsd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vsubsd_xmm_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubsd instruction.<br/>
		/// <br/>
		/// <c>VSUBSD xmm1, xmm2, xmm3/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F2.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F2.0F.W1 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubsd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsubsd_xmm_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubsd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubss instruction.<br/>
		/// <br/>
		/// <c>VSUBSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubss(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vsubss_xmm_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vsubss instruction.<br/>
		/// <br/>
		/// <c>VSUBSS xmm1, xmm2, xmm3/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.F3.0F.WIG 5C /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VSUBSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.F3.0F.W0 5C /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vsubss(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vsubss_xmm_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er;
			} else {
				throw NoOpCodeFoundFor(nameof(vsubss), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vtestpd instruction.<br/>
		/// <br/>
		/// <c>VTESTPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VTESTPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vtestpd(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vtestpd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vtestpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vtestpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vtestpd instruction.<br/>
		/// <br/>
		/// <c>VTESTPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VTESTPD ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0F /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vtestpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vtestpd_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vtestpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vtestpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vtestps instruction.<br/>
		/// <br/>
		/// <c>VTESTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VTESTPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vtestps(Register dst, Register src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vtestps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vtestps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vtestps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vtestps instruction.<br/>
		/// <br/>
		/// <c>VTESTPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F38.W0 0E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VTESTPS ymm1, ymm2/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F38.W0 0E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vtestps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsYMM()) {
				op = Code.VEX_Vtestps_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vtestps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vtestps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vucomisd instruction.<br/>
		/// <br/>
		/// <c>VUCOMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F.WIG 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vucomisd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vucomisd_xmm_xmmm64;
			} else {
				throw NoOpCodeFoundFor(nameof(vucomisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vucomisd instruction.<br/>
		/// <br/>
		/// <c>VUCOMISD xmm1, xmm2/m64</c><br/>
		/// <br/>
		/// <c>VEX.LIG.66.0F.WIG 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUCOMISD xmm1, xmm2/m64{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.66.0F.W1 2E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vucomisd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vucomisd_xmm_xmmm64;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vucomisd_xmm_xmmm64_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vucomisd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vucomiss instruction.<br/>
		/// <br/>
		/// <c>VUCOMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.0F.WIG 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vucomiss(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.VEX_Vucomiss_xmm_xmmm32;
			} else {
				throw NoOpCodeFoundFor(nameof(vucomiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vucomiss instruction.<br/>
		/// <br/>
		/// <c>VUCOMISS xmm1, xmm2/m32</c><br/>
		/// <br/>
		/// <c>VEX.LIG.0F.WIG 2E /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUCOMISS xmm1, xmm2/m32{sae}</c><br/>
		/// <br/>
		/// <c>EVEX.LIG.0F.W0 2E /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vucomiss(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vucomiss_xmm_xmmm32;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vucomiss_xmm_xmmm32_sae;
			} else {
				throw NoOpCodeFoundFor(nameof(vucomiss), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>vunpckhpd instruction.<br/>
		/// <br/>
		/// <c>VUNPCKHPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpckhpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vunpckhpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vunpckhpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpckhpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpckhpd instruction.<br/>
		/// <br/>
		/// <c>VUNPCKHPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpckhpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vunpckhpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vunpckhpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpckhpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpckhps instruction.<br/>
		/// <br/>
		/// <c>VUNPCKHPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpckhps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vunpckhps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vunpckhps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpckhps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpckhps instruction.<br/>
		/// <br/>
		/// <c>VUNPCKHPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 15 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKHPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 15 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpckhps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vunpckhps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vunpckhps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpckhps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpcklpd instruction.<br/>
		/// <br/>
		/// <c>VUNPCKLPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpcklpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vunpcklpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vunpcklpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpcklpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpcklpd instruction.<br/>
		/// <br/>
		/// <c>VUNPCKLPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpcklpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vunpcklpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vunpcklpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpcklpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpcklps instruction.<br/>
		/// <br/>
		/// <c>VUNPCKLPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpcklps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vunpcklps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vunpcklps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpcklps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vunpcklps instruction.<br/>
		/// <br/>
		/// <c>VUNPCKLPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 14 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VUNPCKLPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 14 /r</c><br/>
		/// <br/>
		/// <c>AVX512F</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vunpcklps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vunpcklps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vunpcklps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vunpcklps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vxorpd instruction.<br/>
		/// <br/>
		/// <c>VXORPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vxorpd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vxorpd_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vxorpd_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vxorpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vxorpd instruction.<br/>
		/// <br/>
		/// <c>VXORPD xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.66.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPD ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.66.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.66.0F.W1 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.66.0F.W1 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.66.0F.W1 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vxorpd(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vxorpd_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vxorpd_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64;
			} else {
				throw NoOpCodeFoundFor(nameof(vxorpd), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vxorps instruction.<br/>
		/// <br/>
		/// <c>VXORPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vxorps(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM()) {
				op = Code.VEX_Vxorps_ymm_ymm_ymmm256;
			} else if (dst.IsXMM()) {
				op = Code.VEX_Vxorps_xmm_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(vxorps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vxorps instruction.<br/>
		/// <br/>
		/// <c>VXORPS xmm1, xmm2, xmm3/m128</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPS ymm1, ymm2, ymm3/m256</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 57 /r</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.128.0F.W0 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.256.0F.W0 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512VL and AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>VXORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</c><br/>
		/// <br/>
		/// <c>EVEX.512.0F.W0 57 /r</c><br/>
		/// <br/>
		/// <c>AVX512DQ</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vxorps(Register dst, Register src, ExtendedMemoryOperand arg2) {
			Code op;
			if (dst.IsZMM()) {
				op = Code.EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32;
			} else if (dst.IsYMM() && PreferVex) {
				op = Code.VEX_Vxorps_ymm_ymm_ymmm256;
			} else if (dst.IsYMM() && !PreferVex) {
				op = Code.EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32;
			} else if (dst.IsXMM() && PreferVex) {
				op = Code.VEX_Vxorps_xmm_xmm_xmmm128;
			} else if (dst.IsXMM() && !PreferVex) {
				op = Code.EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32;
			} else {
				throw NoOpCodeFoundFor(nameof(vxorps), dst, src, arg2);
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		/// <summary>vzeroall instruction.<br/>
		/// <br/>
		/// <c>VZEROALL</c><br/>
		/// <br/>
		/// <c>VEX.256.0F.WIG 77</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vzeroall() {
			Code op;
			op = Code.VEX_Vzeroall;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>vzeroupper instruction.<br/>
		/// <br/>
		/// <c>VZEROUPPER</c><br/>
		/// <br/>
		/// <c>VEX.128.0F.WIG 77</c><br/>
		/// <br/>
		/// <c>AVX</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void vzeroupper() {
			Code op;
			op = Code.VEX_Vzeroupper;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>wait instruction.<br/>
		/// <br/>
		/// <c>WAIT</c><br/>
		/// <br/>
		/// <c>9B</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wait() {
			Code op;
			op = Code.Wait;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>wbinvd instruction.<br/>
		/// <br/>
		/// <c>WBINVD</c><br/>
		/// <br/>
		/// <c>0F 09</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wbinvd() {
			Code op;
			op = Code.Wbinvd;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>wbnoinvd instruction.<br/>
		/// <br/>
		/// <c>WBNOINVD</c><br/>
		/// <br/>
		/// <c>F3 0F 09</c><br/>
		/// <br/>
		/// <c>WBNOINVD</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wbnoinvd() {
			Code op;
			op = Code.Wbnoinvd;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>wrfsbase instruction.<br/>
		/// <br/>
		/// <c>WRFSBASE r32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /2</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>WRFSBASE r64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /2</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void wrfsbase(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Wrfsbase_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Wrfsbase_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(wrfsbase), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>wrgsbase instruction.<br/>
		/// <br/>
		/// <c>WRGSBASE r32</c><br/>
		/// <br/>
		/// <c>F3 0F AE /3</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>WRGSBASE r64</c><br/>
		/// <br/>
		/// <c>F3 REX.W 0F AE /3</c><br/>
		/// <br/>
		/// <c>FSGSBASE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void wrgsbase(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Wrgsbase_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Wrgsbase_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(wrgsbase), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>wrmsr instruction.<br/>
		/// <br/>
		/// <c>WRMSR</c><br/>
		/// <br/>
		/// <c>0F 30</c><br/>
		/// <br/>
		/// <c>MSR</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wrmsr() {
			Code op;
			op = Code.Wrmsr;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>wrpkru instruction.<br/>
		/// <br/>
		/// <c>WRPKRU</c><br/>
		/// <br/>
		/// <c>NP 0F 01 EF</c><br/>
		/// <br/>
		/// <c>PKU</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wrpkru() {
			Code op;
			op = Code.Wrpkru;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>wrssd instruction.<br/>
		/// <br/>
		/// <c>WRSSD m32, r32</c><br/>
		/// <br/>
		/// <c>NP 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wrssd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR32()) {
				op = Code.Wrssd_m32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(wrssd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>wrssq instruction.<br/>
		/// <br/>
		/// <c>WRSSQ m64, r64</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F 38 F6 /r</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void wrssq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Wrssq_m64_r64;
			} else {
				throw NoOpCodeFoundFor(nameof(wrssq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>wrussd instruction.<br/>
		/// <br/>
		/// <c>WRUSSD m32, r32</c><br/>
		/// <br/>
		/// <c>66 0F 38 F5 /r</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void wrussd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR32()) {
				op = Code.Wrussd_m32_r32;
			} else {
				throw NoOpCodeFoundFor(nameof(wrussd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>wrussq instruction.<br/>
		/// <br/>
		/// <c>WRUSSQ m64, r64</c><br/>
		/// <br/>
		/// <c>66 REX.W 0F 38 F5 /r</c><br/>
		/// <br/>
		/// <c>CET_SS</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void wrussq(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Wrussq_m64_r64;
			} else {
				throw NoOpCodeFoundFor(nameof(wrussq), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xabort instruction.<br/>
		/// <br/>
		/// </summary>
		public void xabort(int imm) {
			Code op;
			op = Code.Xabort_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		/// <summary>xadd instruction.<br/>
		/// <br/>
		/// <c>XADD r/m8, r8</c><br/>
		/// <br/>
		/// <c>0F C0 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XADD r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F C1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XADD r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F C1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XADD r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F C1 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xadd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xadd_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Xadd_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Xadd_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(xadd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xadd instruction.<br/>
		/// <br/>
		/// <c>XADD r/m8, r8</c><br/>
		/// <br/>
		/// <c>0F C0 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XADD r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 0F C1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XADD r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 0F C1 /r</c><br/>
		/// <br/>
		/// <c>486+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XADD r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 0F C1 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xadd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xadd_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xadd_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xadd_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(xadd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xbts instruction.<br/>
		/// <br/>
		/// <c>XBTS r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F A6 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XBTS r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F A6 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void xbts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(xbts), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xbts instruction.<br/>
		/// <br/>
		/// <c>XBTS r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 0F A6 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XBTS r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 0F A6 /r</c><br/>
		/// <br/>
		/// <c>386 A0</c><br/>
		/// <br/>
		/// <c>16/32-bit</c></summary>
		public void xbts(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw NoOpCodeFoundFor(nameof(xbts), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xchg instruction.<br/>
		/// <br/>
		/// <c>XCHG r16, AX</c><br/>
		/// <br/>
		/// <c>o16 90+rw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r32, EAX</c><br/>
		/// <br/>
		/// <c>o32 90+rd</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r64, RAX</c><br/>
		/// <br/>
		/// <c>REX.W 90+ro</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>XCHG r/m8, r8</c><br/>
		/// <br/>
		/// <c>86 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 87 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 87 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 87 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xchg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src == Register.RAX) {
				op = Code.Xchg_r64_RAX;
			} else if (dst.IsGPR64() && src.IsGPR64()) {
				op = Code.Xchg_rm64_r64;
			} else if (dst.IsGPR32() && src == Register.EAX) {
				op = Code.Xchg_r32_EAX;
			} else if (dst.IsGPR32() && src.IsGPR32()) {
				op = Code.Xchg_rm32_r32;
			} else if (dst.IsGPR16() && src == Register.AX) {
				op = Code.Xchg_r16_AX;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Xchg_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(xchg), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xchg instruction.<br/>
		/// <br/>
		/// <c>XCHG r/m8, r8</c><br/>
		/// <br/>
		/// <c>86 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 87 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 87 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCHG r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 87 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xchg_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xchg_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xchg_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(xchg), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xcryptcbc instruction.<br/>
		/// <br/>
		/// <c>XCRYPTCBC</c><br/>
		/// <br/>
		/// <c>a16 0F A7 D0</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XCRYPTCBC</c><br/>
		/// <br/>
		/// <c>a32 0F A7 D0</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCRYPTCBC</c><br/>
		/// <br/>
		/// <c>0F A7 D0</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xcryptcbc() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCbc_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCbc_32;
			} else if (Bitness == 16) {
				op = Code.XcryptCbc_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xcryptcbc));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xcryptcfb instruction.<br/>
		/// <br/>
		/// <c>XCRYPTCFB</c><br/>
		/// <br/>
		/// <c>a16 0F A7 E0</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XCRYPTCFB</c><br/>
		/// <br/>
		/// <c>a32 0F A7 E0</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCRYPTCFB</c><br/>
		/// <br/>
		/// <c>0F A7 E0</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xcryptcfb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCfb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCfb_32;
			} else if (Bitness == 16) {
				op = Code.XcryptCfb_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xcryptcfb));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xcryptctr instruction.<br/>
		/// <br/>
		/// <c>XCRYPTCTR</c><br/>
		/// <br/>
		/// <c>a16 0F A7 D8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XCRYPTCTR</c><br/>
		/// <br/>
		/// <c>a32 0F A7 D8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCRYPTCTR</c><br/>
		/// <br/>
		/// <c>0F A7 D8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xcryptctr() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCtr_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCtr_32;
			} else if (Bitness == 16) {
				op = Code.XcryptCtr_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xcryptctr));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xcryptecb instruction.<br/>
		/// <br/>
		/// <c>XCRYPTECB</c><br/>
		/// <br/>
		/// <c>a16 0F A7 C8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XCRYPTECB</c><br/>
		/// <br/>
		/// <c>a32 0F A7 C8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCRYPTECB</c><br/>
		/// <br/>
		/// <c>0F A7 C8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xcryptecb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptEcb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptEcb_32;
			} else if (Bitness == 16) {
				op = Code.XcryptEcb_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xcryptecb));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xcryptofb instruction.<br/>
		/// <br/>
		/// <c>XCRYPTOFB</c><br/>
		/// <br/>
		/// <c>a16 0F A7 E8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XCRYPTOFB</c><br/>
		/// <br/>
		/// <c>a32 0F A7 E8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XCRYPTOFB</c><br/>
		/// <br/>
		/// <c>0F A7 E8</c><br/>
		/// <br/>
		/// <c>PADLOCK_ACE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xcryptofb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptOfb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptOfb_32;
			} else if (Bitness == 16) {
				op = Code.XcryptOfb_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xcryptofb));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xend instruction.<br/>
		/// <br/>
		/// <c>XEND</c><br/>
		/// <br/>
		/// <c>NP 0F 01 D5</c><br/>
		/// <br/>
		/// <c>RTM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xend() {
			Code op;
			op = Code.Xend;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xgetbv instruction.<br/>
		/// <br/>
		/// <c>XGETBV</c><br/>
		/// <br/>
		/// <c>NP 0F 01 D0</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xgetbv() {
			Code op;
			op = Code.Xgetbv;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xor instruction.<br/>
		/// <br/>
		/// <c>XOR r/m8, r8</c><br/>
		/// <br/>
		/// <c>30 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 31 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 31 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 31 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xor(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(xor), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xor instruction.<br/>
		/// <br/>
		/// <c>XOR r/m8, r8</c><br/>
		/// <br/>
		/// <c>30 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m16, r16</c><br/>
		/// <br/>
		/// <c>o16 31 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m32, r32</c><br/>
		/// <br/>
		/// <c>o32 31 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m64, r64</c><br/>
		/// <br/>
		/// <c>REX.W 31 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xor(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xor_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xor_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xor_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xor_rm8_r8;
			} else {
				throw NoOpCodeFoundFor(nameof(xor), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xor instruction.<br/>
		/// <br/>
		/// <c>XOR r8, r/m8</c><br/>
		/// <br/>
		/// <c>32 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r16, r/m16</c><br/>
		/// <br/>
		/// <c>o16 33 /r</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r32, r/m32</c><br/>
		/// <br/>
		/// <c>o32 33 /r</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r64, r/m64</c><br/>
		/// <br/>
		/// <c>REX.W 33 /r</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xor(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_r8_rm8;
			} else {
				throw NoOpCodeFoundFor(nameof(xor), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xor instruction.<br/>
		/// <br/>
		/// <c>XOR AX, imm16</c><br/>
		/// <br/>
		/// <c>o16 35 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR EAX, imm32</c><br/>
		/// <br/>
		/// <c>o32 35 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR RAX, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 35 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c><c>XOR r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /6 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /6 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /6 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xor(Register dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Xor_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Xor_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Xor_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Xor_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Xor_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(xor), dst, imm);
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Xor_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Xor_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Xor_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Xor_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(xor), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>xor instruction.<br/>
		/// <br/>
		/// <c>XOR r/m16, imm16</c><br/>
		/// <br/>
		/// <c>o16 81 /6 iw</c><br/>
		/// <br/>
		/// <c>8086+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m32, imm32</c><br/>
		/// <br/>
		/// <c>o32 81 /6 id</c><br/>
		/// <br/>
		/// <c>386+</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XOR r/m64, imm32</c><br/>
		/// <br/>
		/// <c>REX.W 81 /6 id</c><br/>
		/// <br/>
		/// <c>X64</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xor(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm >= sbyte.MinValue && imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Xor_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Xor_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Xor_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Xor_rm8_imm8;
				} else {
					throw NoOpCodeFoundFor(nameof(xor), dst, imm);
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xor_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xor_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xor_rm16_imm16;
			} else {
				throw NoOpCodeFoundFor(nameof(xor), dst, imm);
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		/// <summary>xorpd instruction.<br/>
		/// <br/>
		/// <c>XORPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 57 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xorpd(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xorpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(xorpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xorpd instruction.<br/>
		/// <br/>
		/// <c>XORPD xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>66 0F 57 /r</c><br/>
		/// <br/>
		/// <c>SSE2</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xorpd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xorpd_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(xorpd), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xorps instruction.<br/>
		/// <br/>
		/// <c>XORPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 57 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xorps(Register dst, Register src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xorps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(xorps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xorps instruction.<br/>
		/// <br/>
		/// <c>XORPS xmm1, xmm2/m128</c><br/>
		/// <br/>
		/// <c>NP 0F 57 /r</c><br/>
		/// <br/>
		/// <c>SSE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xorps(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xorps_xmm_xmmm128;
			} else {
				throw NoOpCodeFoundFor(nameof(xorps), dst, src);
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		/// <summary>xrstor instruction.<br/>
		/// <br/>
		/// <c>XRSTOR mem</c><br/>
		/// <br/>
		/// <c>NP 0F AE /5</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xrstor(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xrstor_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstor), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstor instruction.<br/>
		/// <br/>
		/// <c>XRSTOR mem</c><br/>
		/// <br/>
		/// <c>NP 0F AE /5</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xrstor(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xrstor_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstor), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstor64 instruction.<br/>
		/// <br/>
		/// <c>XRSTOR64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /5</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xrstor64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xrstor64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstor64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstor64 instruction.<br/>
		/// <br/>
		/// <c>XRSTOR64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /5</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xrstor64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xrstor64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstor64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstors instruction.<br/>
		/// <br/>
		/// <c>XRSTORS mem</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /3</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xrstors(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xrstors_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstors), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstors instruction.<br/>
		/// <br/>
		/// <c>XRSTORS mem</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /3</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xrstors(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xrstors_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstors), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstors64 instruction.<br/>
		/// <br/>
		/// <c>XRSTORS64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C7 /3</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xrstors64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xrstors64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstors64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xrstors64 instruction.<br/>
		/// <br/>
		/// <c>XRSTORS64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C7 /3</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xrstors64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xrstors64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xrstors64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsave instruction.<br/>
		/// <br/>
		/// <c>XSAVE mem</c><br/>
		/// <br/>
		/// <c>NP 0F AE /4</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsave(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsave_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsave), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsave instruction.<br/>
		/// <br/>
		/// <c>XSAVE mem</c><br/>
		/// <br/>
		/// <c>NP 0F AE /4</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsave(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsave_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsave), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsave64 instruction.<br/>
		/// <br/>
		/// <c>XSAVE64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /4</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsave64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsave64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsave64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsave64 instruction.<br/>
		/// <br/>
		/// <c>XSAVE64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /4</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsave64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsave64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsave64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsavec instruction.<br/>
		/// <br/>
		/// <c>XSAVEC mem</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /4</c><br/>
		/// <br/>
		/// <c>XSAVEC</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsavec(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsavec_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsavec), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsavec instruction.<br/>
		/// <br/>
		/// <c>XSAVEC mem</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /4</c><br/>
		/// <br/>
		/// <c>XSAVEC</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsavec(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsavec_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsavec), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsavec64 instruction.<br/>
		/// <br/>
		/// <c>XSAVEC64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C7 /4</c><br/>
		/// <br/>
		/// <c>XSAVEC</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsavec64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsavec64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsavec64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsavec64 instruction.<br/>
		/// <br/>
		/// <c>XSAVEC64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C7 /4</c><br/>
		/// <br/>
		/// <c>XSAVEC</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsavec64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsavec64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsavec64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaveopt instruction.<br/>
		/// <br/>
		/// <c>XSAVEOPT mem</c><br/>
		/// <br/>
		/// <c>NP 0F AE /6</c><br/>
		/// <br/>
		/// <c>XSAVEOPT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsaveopt(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsaveopt_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaveopt), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaveopt instruction.<br/>
		/// <br/>
		/// <c>XSAVEOPT mem</c><br/>
		/// <br/>
		/// <c>NP 0F AE /6</c><br/>
		/// <br/>
		/// <c>XSAVEOPT</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsaveopt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsaveopt_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaveopt), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaveopt64 instruction.<br/>
		/// <br/>
		/// <c>XSAVEOPT64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /6</c><br/>
		/// <br/>
		/// <c>XSAVEOPT</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsaveopt64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsaveopt64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaveopt64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaveopt64 instruction.<br/>
		/// <br/>
		/// <c>XSAVEOPT64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F AE /6</c><br/>
		/// <br/>
		/// <c>XSAVEOPT</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsaveopt64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsaveopt64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaveopt64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaves instruction.<br/>
		/// <br/>
		/// <c>XSAVES mem</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /5</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsaves(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsaves_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaves), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaves instruction.<br/>
		/// <br/>
		/// <c>XSAVES mem</c><br/>
		/// <br/>
		/// <c>NP 0F C7 /5</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsaves(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsaves_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaves), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaves64 instruction.<br/>
		/// <br/>
		/// <c>XSAVES64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C7 /5</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsaves64(Register dst) {
			Code op;
			if (dst.IsXMM()) {
				op = Code.Xsaves64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaves64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsaves64 instruction.<br/>
		/// <br/>
		/// <c>XSAVES64 mem</c><br/>
		/// <br/>
		/// <c>NP REX.W 0F C7 /5</c><br/>
		/// <br/>
		/// <c>XSAVES</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsaves64(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DQwordPtr) {
				op = Code.Xsaves64_mem;
			} else {
				throw NoOpCodeFoundFor(nameof(xsaves64), dst);
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		/// <summary>xsetbv instruction.<br/>
		/// <br/>
		/// <c>XSETBV</c><br/>
		/// <br/>
		/// <c>NP 0F 01 D1</c><br/>
		/// <br/>
		/// <c>XSAVE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xsetbv() {
			Code op;
			op = Code.Xsetbv;
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xsha1 instruction.<br/>
		/// <br/>
		/// <c>XSHA1</c><br/>
		/// <br/>
		/// <c>a16 0F A6 C8</c><br/>
		/// <br/>
		/// <c>PADLOCK_PHE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XSHA1</c><br/>
		/// <br/>
		/// <c>a32 0F A6 C8</c><br/>
		/// <br/>
		/// <c>PADLOCK_PHE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XSHA1</c><br/>
		/// <br/>
		/// <c>0F A6 C8</c><br/>
		/// <br/>
		/// <c>PADLOCK_PHE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsha1() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xsha1_64;
			} else if (Bitness == 32) {
				op = Code.Xsha1_32;
			} else if (Bitness == 16) {
				op = Code.Xsha1_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xsha1));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xsha256 instruction.<br/>
		/// <br/>
		/// <c>XSHA256</c><br/>
		/// <br/>
		/// <c>a16 0F A6 D0</c><br/>
		/// <br/>
		/// <c>PADLOCK_PHE</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XSHA256</c><br/>
		/// <br/>
		/// <c>a32 0F A6 D0</c><br/>
		/// <br/>
		/// <c>PADLOCK_PHE</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XSHA256</c><br/>
		/// <br/>
		/// <c>0F A6 D0</c><br/>
		/// <br/>
		/// <c>PADLOCK_PHE</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xsha256() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xsha256_64;
			} else if (Bitness == 32) {
				op = Code.Xsha256_32;
			} else if (Bitness == 16) {
				op = Code.Xsha256_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xsha256));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xstore instruction.<br/>
		/// <br/>
		/// <c>XSTORE</c><br/>
		/// <br/>
		/// <c>a16 0F A7 C0</c><br/>
		/// <br/>
		/// <c>PADLOCK_RNG</c><br/>
		/// <br/>
		/// <c>16/32-bit</c><c>XSTORE</c><br/>
		/// <br/>
		/// <c>a32 0F A7 C0</c><br/>
		/// <br/>
		/// <c>PADLOCK_RNG</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c><c>XSTORE</c><br/>
		/// <br/>
		/// <c>0F A7 C0</c><br/>
		/// <br/>
		/// <c>PADLOCK_RNG</c><br/>
		/// <br/>
		/// <c>64-bit</c></summary>
		public void xstore() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xstore_64;
			} else if (Bitness == 32) {
				op = Code.Xstore_32;
			} else if (Bitness == 16) {
				op = Code.Xstore_16;
			} else {
				throw NoOpCodeFoundFor(nameof(xstore));
			}
			AddInstruction(Instruction.Create(op));
		}
		/// <summary>xtest instruction.<br/>
		/// <br/>
		/// <c>XTEST</c><br/>
		/// <br/>
		/// <c>NP 0F 01 D6</c><br/>
		/// <br/>
		/// <c>HLE or RTM</c><br/>
		/// <br/>
		/// <c>16/32/64-bit</c></summary>
		public void xtest() {
			Code op;
			op = Code.Xtest;
			AddInstruction(Instruction.Create(op));
		}
	}
}
#endif
