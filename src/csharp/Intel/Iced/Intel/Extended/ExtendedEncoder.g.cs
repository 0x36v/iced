/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#nullable enable

#if !NO_ENCODER
namespace Iced.Intel {
	using System;
	public sealed partial class ExtendedEncoder {
		public void aaa() {
			Code op;
			op = Code.Aaa;
			AddInstruction(Instruction.Create(op));
		}
		public void aad(int imm) {
			Code op;
			op = Code.Aad_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void aam(int imm) {
			Code op;
			op = Code.Aam_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void aas() {
			Code op;
			op = Code.Aas;
			AddInstruction(Instruction.Create(op));
		}
		public void adc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Adc_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Adc_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Adc_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Adc_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Adc_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Adc_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Adc_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Adc_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Adc_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Adc_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Adc_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Adc_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Adc_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void adc(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Adc_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Adc_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Adc_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Adc_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Adc_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Adc_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Adc_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void adcx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adcx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adcx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adcx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Add_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Add_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Add_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Add_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Add_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Add_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Add_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Add_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Add_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Add_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Add_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Add_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Add_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Add_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Add_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void add(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Add_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Add_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Add_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Add_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Add_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Add_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Add_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void adox(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adox)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adox(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(adox)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.And_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.And_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.And_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.And_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.And_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.And_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.And_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.And_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.And_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.And_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.And_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.And_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.And_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.And_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.And_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.And_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.And_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.And_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.And_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.And_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.And_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void and(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.And_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.And_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.And_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.And_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.And_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.And_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.And_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void arpl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Arpl_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(arpl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void arpl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Arpl_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(arpl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsf(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsf)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsf(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsf)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsr(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bsr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bswap(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bswap_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bswap_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bswap_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bswap)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void bt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bt_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bt_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bt_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bt(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bt_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bt_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bt_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bt(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bt_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Bt_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Bt_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void bt(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bt_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bt_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bt_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btc(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btc_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Btc_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Btc_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btc_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btc_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btc_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btc(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btc_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Btc_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Btc_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btc(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btc_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btc_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btc_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btr_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Btr_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Btr_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btr_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btr_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btr_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btr(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Btr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Btr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Btr_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void btr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Btr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Btr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Btr_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void bts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bts_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bts_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bts_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bts_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bts(Register dst, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bts_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Bts_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Bts_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void bts(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Bts_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Bts_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Bts_rm16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void call(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Call_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Call_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Call_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(call)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void call(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Call_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Call_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Call_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(call)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void cbw() {
			Code op;
			op = Code.Cbw;
			AddInstruction(Instruction.Create(op));
		}
		public void cdq() {
			Code op;
			op = Code.Cdq;
			AddInstruction(Instruction.Create(op));
		}
		public void cdqe() {
			Code op;
			op = Code.Cdqe;
			AddInstruction(Instruction.Create(op));
		}
		public void cl1invmb() {
			Code op;
			op = Code.Cl1invmb;
			AddInstruction(Instruction.Create(op));
		}
		public void clac() {
			Code op;
			op = Code.Clac;
			AddInstruction(Instruction.Create(op));
		}
		public void clc() {
			Code op;
			op = Code.Clc;
			AddInstruction(Instruction.Create(op));
		}
		public void cld() {
			Code op;
			op = Code.Cld;
			AddInstruction(Instruction.Create(op));
		}
		public void clgi() {
			Code op;
			op = Code.Clgi;
			AddInstruction(Instruction.Create(op));
		}
		public void cli() {
			Code op;
			op = Code.Cli;
			AddInstruction(Instruction.Create(op));
		}
		public void clts() {
			Code op;
			op = Code.Clts;
			AddInstruction(Instruction.Create(op));
		}
		public void clzero() {
			Code op;
			if (Bitness == 64) {
				op = Code.Clzeroq;
			} else if (Bitness == 32) {
				op = Code.Clzerod;
			} else {
				op = Code.Clzerow;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void cmc() {
			Code op;
			op = Code.Cmc;
			AddInstruction(Instruction.Create(op));
		}
		public void cmova(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmova)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmova(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmova)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovae(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovae(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovbe(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovbe(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmove(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmove)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmove(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmove)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovg(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovge(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovge(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovle(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovle(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovne(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovne(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovno(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovno(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovnp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovnp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovns(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovns(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovo(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovo)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovo(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovo)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovs(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovs)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovs(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmovs)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmp_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmp_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmp_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Cmp_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Cmp_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Cmp_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Cmp_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Cmp_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Cmp_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Cmp_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Cmp_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Cmp_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void cmp(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Cmp_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Cmp_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Cmp_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Cmp_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmp_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmp_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmp_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void cmpsb() {
			Code op;
			op = Code.Cmpsb_m8_m8;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpsd() {
			Code op;
			op = Code.Cmpsd_m32_m32;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpsq() {
			Code op;
			op = Code.Cmpsq_m64_m64;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpsw() {
			Code op;
			op = Code.Cmpsw_m16_m16;
			AddInstruction(Instruction.Create(op));
		}
		public void cmpxchg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmpxchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmpxchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(cmpxchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cpuid() {
			Code op;
			op = Code.Cpuid;
			AddInstruction(Instruction.Create(op));
		}
		public void cqo() {
			Code op;
			op = Code.Cqo;
			AddInstruction(Instruction.Create(op));
		}
		public void crc32(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR64()) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR32()) {
				op = Code.Crc32_r32_rm32;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Crc32_r32_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(crc32)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void crc32(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Crc32_r32_rm32;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Crc32_r32_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(crc32)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cwd() {
			Code op;
			op = Code.Cwd;
			AddInstruction(Instruction.Create(op));
		}
		public void cwde() {
			Code op;
			op = Code.Cwde;
			AddInstruction(Instruction.Create(op));
		}
		public void daa() {
			Code op;
			op = Code.Daa;
			AddInstruction(Instruction.Create(op));
		}
		public void das() {
			Code op;
			op = Code.Das;
			AddInstruction(Instruction.Create(op));
		}
		public void db() {
			Code op;
			op = Code.DeclareByte;
			AddInstruction(Instruction.Create(op));
		}
		public void dd() {
			Code op;
			op = Code.DeclareDword;
			AddInstruction(Instruction.Create(op));
		}
		public void dec(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Dec_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Dec_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Dec_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Dec_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(dec)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void dec(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Dec_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Dec_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Dec_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Dec_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(dec)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void div(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Div_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Div_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Div_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Div_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(div)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void div(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Div_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Div_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Div_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Div_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(div)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void dq() {
			Code op;
			op = Code.DeclareQword;
			AddInstruction(Instruction.Create(op));
		}
		public void dw() {
			Code op;
			op = Code.DeclareWord;
			AddInstruction(Instruction.Create(op));
		}
		public void emms() {
			Code op;
			op = Code.Emms;
			AddInstruction(Instruction.Create(op));
		}
		public void encls() {
			Code op;
			op = Code.Encls;
			AddInstruction(Instruction.Create(op));
		}
		public void enclu() {
			Code op;
			op = Code.Enclu;
			AddInstruction(Instruction.Create(op));
		}
		public void enclv() {
			Code op;
			op = Code.Enclv;
			AddInstruction(Instruction.Create(op));
		}
		public void endbr32() {
			Code op;
			op = Code.Endbr32;
			AddInstruction(Instruction.Create(op));
		}
		public void endbr64() {
			Code op;
			op = Code.Endbr64;
			AddInstruction(Instruction.Create(op));
		}
		public void f2xm1() {
			Code op;
			op = Code.F2xm1;
			AddInstruction(Instruction.Create(op));
		}
		public void fabs() {
			Code op;
			op = Code.Fabs;
			AddInstruction(Instruction.Create(op));
		}
		public void fchs() {
			Code op;
			op = Code.Fchs;
			AddInstruction(Instruction.Create(op));
		}
		public void fclex() {
			Code op;
			op = Code.Fclex;
			AddInstruction(Instruction.Create(op));
		}
		public void fcompp() {
			Code op;
			op = Code.Fcompp;
			AddInstruction(Instruction.Create(op));
		}
		public void fcos() {
			Code op;
			op = Code.Fcos;
			AddInstruction(Instruction.Create(op));
		}
		public void fdecstp() {
			Code op;
			op = Code.Fdecstp;
			AddInstruction(Instruction.Create(op));
		}
		public void fdisi() {
			Code op;
			op = Code.Fdisi;
			AddInstruction(Instruction.Create(op));
		}
		public void femms() {
			Code op;
			op = Code.Femms;
			AddInstruction(Instruction.Create(op));
		}
		public void feni() {
			Code op;
			op = Code.Feni;
			AddInstruction(Instruction.Create(op));
		}
		public void fincstp() {
			Code op;
			op = Code.Fincstp;
			AddInstruction(Instruction.Create(op));
		}
		public void finit() {
			Code op;
			op = Code.Finit;
			AddInstruction(Instruction.Create(op));
		}
		public void fld1() {
			Code op;
			op = Code.Fld1;
			AddInstruction(Instruction.Create(op));
		}
		public void fldl2e() {
			Code op;
			op = Code.Fldl2e;
			AddInstruction(Instruction.Create(op));
		}
		public void fldl2t() {
			Code op;
			op = Code.Fldl2t;
			AddInstruction(Instruction.Create(op));
		}
		public void fldlg2() {
			Code op;
			op = Code.Fldlg2;
			AddInstruction(Instruction.Create(op));
		}
		public void fldln2() {
			Code op;
			op = Code.Fldln2;
			AddInstruction(Instruction.Create(op));
		}
		public void fldpi() {
			Code op;
			op = Code.Fldpi;
			AddInstruction(Instruction.Create(op));
		}
		public void fldz() {
			Code op;
			op = Code.Fldz;
			AddInstruction(Instruction.Create(op));
		}
		public void fnclex() {
			Code op;
			op = Code.Fnclex;
			AddInstruction(Instruction.Create(op));
		}
		public void fndisi() {
			Code op;
			op = Code.Fndisi;
			AddInstruction(Instruction.Create(op));
		}
		public void fneni() {
			Code op;
			op = Code.Fneni;
			AddInstruction(Instruction.Create(op));
		}
		public void fninit() {
			Code op;
			op = Code.Fninit;
			AddInstruction(Instruction.Create(op));
		}
		public void fnop() {
			Code op;
			op = Code.Fnop;
			AddInstruction(Instruction.Create(op));
		}
		public void fnsetpm() {
			Code op;
			op = Code.Fnsetpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fnstsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fnstsw_AX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(fnstsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fpatan() {
			Code op;
			op = Code.Fpatan;
			AddInstruction(Instruction.Create(op));
		}
		public void fprem() {
			Code op;
			op = Code.Fprem;
			AddInstruction(Instruction.Create(op));
		}
		public void fprem1() {
			Code op;
			op = Code.Fprem1;
			AddInstruction(Instruction.Create(op));
		}
		public void fptan() {
			Code op;
			op = Code.Fptan;
			AddInstruction(Instruction.Create(op));
		}
		public void frndint() {
			Code op;
			op = Code.Frndint;
			AddInstruction(Instruction.Create(op));
		}
		public void frstpm() {
			Code op;
			op = Code.Frstpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fscale() {
			Code op;
			op = Code.Fscale;
			AddInstruction(Instruction.Create(op));
		}
		public void fsetpm() {
			Code op;
			op = Code.Fsetpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fsin() {
			Code op;
			op = Code.Fsin;
			AddInstruction(Instruction.Create(op));
		}
		public void fsincos() {
			Code op;
			op = Code.Fsincos;
			AddInstruction(Instruction.Create(op));
		}
		public void fsqrt() {
			Code op;
			op = Code.Fsqrt;
			AddInstruction(Instruction.Create(op));
		}
		public void fstdw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstdw_AX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(fstdw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fstsg(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstsg_AX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(fstsg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fstsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstsw_AX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(fstsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ftst() {
			Code op;
			op = Code.Ftst;
			AddInstruction(Instruction.Create(op));
		}
		public void fucompp() {
			Code op;
			op = Code.Fucompp;
			AddInstruction(Instruction.Create(op));
		}
		public void fxam() {
			Code op;
			op = Code.Fxam;
			AddInstruction(Instruction.Create(op));
		}
		public void fxtract() {
			Code op;
			op = Code.Fxtract;
			AddInstruction(Instruction.Create(op));
		}
		public void fyl2x() {
			Code op;
			op = Code.Fyl2x;
			AddInstruction(Instruction.Create(op));
		}
		public void fyl2xp1() {
			Code op;
			op = Code.Fyl2xp1;
			AddInstruction(Instruction.Create(op));
		}
		public void getsec() {
			Code op;
			op = Code.Getsec;
			AddInstruction(Instruction.Create(op));
		}
		public void hlt() {
			Code op;
			op = Code.Hlt;
			AddInstruction(Instruction.Create(op));
		}
		public void ibts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Ibts_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ibts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ibts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ibts_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ibts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void idiv(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Idiv_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Idiv_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Idiv_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Idiv_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(idiv)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void idiv(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Idiv_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Idiv_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Idiv_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Idiv_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(idiv)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Imul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Imul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Imul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Imul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Imul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void imul(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void imul(Register dst, Register src, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Imul_r64_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Imul_r32_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Imul_r16_rm16_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void imul(Register dst, ExtendedMemoryOperand src, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Imul_r64_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Imul_r32_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Imul_r16_rm16_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void @in(Register dst, Register src) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.In_EAX_DX;
			} else if (dst == Register.AX) {
				op = Code.In_AX_DX;
			} else if (dst == Register.AL) {
				op = Code.In_AL_DX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@in)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void @in(Register dst, int imm) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.In_EAX_imm8;
			} else if (dst == Register.AX) {
				op = Code.In_AX_imm8;
			} else if (dst == Register.AL) {
				op = Code.In_AL_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@in)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void inc(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Inc_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Inc_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Inc_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Inc_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(inc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void inc(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Inc_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Inc_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Inc_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Inc_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(inc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void insb(Register src) {
			Code op;
			if (src == Register.DX) {
				op = Code.Insb_m8_DX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(insb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void insd(Register src) {
			Code op;
			if (src == Register.DX) {
				op = Code.Insd_m32_DX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(insd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void insw(Register src) {
			Code op;
			if (src == Register.DX) {
				op = Code.Insw_m16_DX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(insw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void @int() {
			Code op;
			op = Code.Int3;
			AddInstruction(Instruction.Create(op));
		}
		public void @int(int imm) {
			Code op;
			op = Code.Int_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void int1() {
			Code op;
			op = Code.Int1;
			AddInstruction(Instruction.Create(op));
		}
		public void into() {
			Code op;
			op = Code.Into;
			AddInstruction(Instruction.Create(op));
		}
		public void invd() {
			Code op;
			op = Code.Invd;
			AddInstruction(Instruction.Create(op));
		}
		public void invlpga() {
			Code op;
			if (Bitness == 64) {
				op = Code.Invlpgaq;
			} else if (Bitness == 32) {
				op = Code.Invlpgad;
			} else {
				op = Code.Invlpgaw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void iret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Iretq;
			} else if (Bitness == 32) {
				op = Code.Iretd;
			} else {
				op = Code.Iretw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void jmp(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Jmp_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Jmp_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Jmp_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Jmp_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmp_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmp_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmpe(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Jmpe_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Jmpe_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmpe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmpe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmpe_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmpe_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(jmpe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lahf() {
			Code op;
			op = Code.Lahf;
			AddInstruction(Instruction.Create(op));
		}
		public void lar(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void lar(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void leave() {
			Code op;
			if (Bitness == 64) {
				op = Code.Leaveq;
			} else if (Bitness == 32) {
				op = Code.Leaved;
			} else {
				op = Code.Leavew;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void lfence() {
			Code op;
			op = Code.Lfence;
			AddInstruction(Instruction.Create(op));
		}
		public void lldt(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Lldt_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lldt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lldt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Lldt_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lldt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lmsw(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Lmsw_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lmsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lmsw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Lmsw_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lmsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void loadall() {
			Code op;
			op = Code.Loadall386;
			AddInstruction(Instruction.Create(op));
		}
		public void lodsb(Register dst) {
			Code op;
			if (dst == Register.AL) {
				op = Code.Lodsb_AL_m8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lodsb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lodsd(Register dst) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.Lodsd_EAX_m32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lodsd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lodsq(Register dst) {
			Code op;
			if (dst == Register.RAX) {
				op = Code.Lodsq_RAX_m64;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lodsq)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lodsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Lodsw_AX_m16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lodsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lsl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lsl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void lsl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lsl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ltr(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Ltr_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ltr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ltr(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ltr_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ltr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lzcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void lzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(lzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mcommit() {
			Code op;
			op = Code.Mcommit;
			AddInstruction(Instruction.Create(op));
		}
		public void mfence() {
			Code op;
			op = Code.Mfence;
			AddInstruction(Instruction.Create(op));
		}
		public void monitor() {
			Code op;
			if (Bitness == 64) {
				op = Code.Monitorq;
			} else if (Bitness == 32) {
				op = Code.Monitord;
			} else {
				op = Code.Monitorw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void monitorx() {
			Code op;
			if (Bitness == 64) {
				op = Code.Monitorxq;
			} else if (Bitness == 32) {
				op = Code.Monitorxd;
			} else {
				op = Code.Monitorxw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void montmul() {
			Code op;
			if (Bitness == 64) {
				op = Code.Montmul_64;
			} else if (Bitness == 32) {
				op = Code.Montmul_32;
			} else {
				op = Code.Montmul_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void mov(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mov_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mov_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mov_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(Register dst, long imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR8()) {
					op = Code.Mov_r8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Mov_r64_imm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_imm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void mov(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Mov_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mov_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mov_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mov_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void movsb() {
			Code op;
			op = Code.Movsb_m8_m8;
			AddInstruction(Instruction.Create(op));
		}
		public void movsd() {
			Code op;
			op = Code.Movsd_m32_m32;
			AddInstruction(Instruction.Create(op));
		}
		public void movsq() {
			Code op;
			op = Code.Movsq_m64_m64;
			AddInstruction(Instruction.Create(op));
		}
		public void movsw() {
			Code op;
			op = Code.Movsw_m16_m16;
			AddInstruction(Instruction.Create(op));
		}
		public void movsx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR16()) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Movsx_r16_rm16;
			} else if (dst.IsGPR16() && src.IsGPR8()) {
				op = Code.Movsx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movsx_r16_rm16;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movsx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsxd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsxd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsxd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movsxd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movzx(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src.IsGPR16()) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR64() && src.IsGPR8()) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR32() && src.IsGPR16()) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR32() && src.IsGPR8()) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Movzx_r16_rm16;
			} else if (dst.IsGPR16() && src.IsGPR8()) {
				op = Code.Movzx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movzx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movzx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR64() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR32() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.WordPtr) {
				op = Code.Movzx_r16_rm16;
			} else if (dst.IsGPR16() && src.Size == MemoryOperandSize.BytePtr) {
				op = Code.Movzx_r16_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(movzx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mul(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mul_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mul_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mul_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void mul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mul_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(mul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void mwait() {
			Code op;
			op = Code.Mwait;
			AddInstruction(Instruction.Create(op));
		}
		public void mwaitx() {
			Code op;
			op = Code.Mwaitx;
			AddInstruction(Instruction.Create(op));
		}
		public void neg(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Neg_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Neg_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Neg_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Neg_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(neg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void neg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Neg_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Neg_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Neg_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Neg_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(neg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void nop() {
			Code op;
			if (Bitness == 64) {
				op = Code.Nopq;
			} else if (Bitness == 32) {
				op = Code.Nopd;
			} else {
				op = Code.Nopw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void nop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Nop_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Nop_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Nop_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(nop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void nop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Nop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Nop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Nop_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(nop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void not(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Not_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Not_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Not_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Not_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(not)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void not(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Not_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Not_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Not_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Not_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(not)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void or(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Or_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Or_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Or_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Or_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Or_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Or_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Or_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Or_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Or_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Or_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Or_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Or_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Or_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Or_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Or_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void or(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Or_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Or_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Or_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Or_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Or_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Or_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Or_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void @out(Register dst, Register src) {
			Code op;
			if (dst == Register.DX && src == Register.EAX) {
				op = Code.Out_DX_EAX;
			} else if (dst == Register.DX && src == Register.AX) {
				op = Code.Out_DX_AX;
			} else if (dst == Register.DX && src == Register.AL) {
				op = Code.Out_DX_AL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@out)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void @out(int imm, Register src) {
			Code op;
			if (src == Register.EAX) {
				op = Code.Out_imm8_EAX;
			} else if (src == Register.AX) {
				op = Code.Out_imm8_AX;
			} else if (src == Register.AL) {
				op = Code.Out_imm8_AL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(@out)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, imm, src));
		}
		public void outsb(Register dst) {
			Code op;
			if (dst == Register.DX) {
				op = Code.Outsb_DX_m8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(outsb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void outsd(Register dst) {
			Code op;
			if (dst == Register.DX) {
				op = Code.Outsd_DX_m32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(outsd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void outsw(Register dst) {
			Code op;
			if (dst == Register.DX) {
				op = Code.Outsw_DX_m16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(outsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void pause() {
			Code op;
			op = Code.Pause;
			AddInstruction(Instruction.Create(op));
		}
		public void pcommit() {
			Code op;
			op = Code.Pcommit;
			AddInstruction(Instruction.Create(op));
		}
		public void pconfig() {
			Code op;
			op = Code.Pconfig;
			AddInstruction(Instruction.Create(op));
		}
		public void pop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Pop_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Pop_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Pop_r16;
			} else if (dst == Register.ES) {
				op = Bitness >= 32 ? Code.Popd_ES : Code.Popw_ES;
			} else if (dst == Register.CS) {
				op = Bitness >= 32 ? Code.Popw_CS : Code.Popw_CS;
			} else if (dst == Register.SS) {
				op = Bitness >= 32 ? Code.Popd_SS : Code.Popw_SS;
			} else if (dst == Register.DS) {
				op = Bitness >= 32 ? Code.Popd_DS : Code.Popw_DS;
			} else if (dst == Register.FS) {
				op = Bitness >= 32 ? Code.Popd_FS : Code.Popw_FS;
			} else if (dst == Register.GS) {
				op = Bitness >= 32 ? Code.Popd_GS : Code.Popw_GS;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(pop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void pop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Pop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Pop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pop_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(pop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void popa() {
			Code op;
			if (Bitness >= 32) {
				op = Code.Popad;
			} else {
				op = Code.Popaw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void popcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(popcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void popcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(popcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void popf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Popfq;
			} else if (Bitness == 32) {
				op = Code.Popfd;
			} else {
				op = Code.Popfw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void ptwrite(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ptwrite_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ptwrite_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ptwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ptwrite(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ptwrite_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ptwrite_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ptwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Push_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Push_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Push_r16;
			} else if (dst == Register.ES) {
				op = Bitness >= 32 ? Code.Pushd_ES : Code.Pushw_ES;
			} else if (dst == Register.CS) {
				op = Bitness >= 32 ? Code.Pushd_CS : Code.Pushw_CS;
			} else if (dst == Register.SS) {
				op = Bitness >= 32 ? Code.Pushd_SS : Code.Pushw_SS;
			} else if (dst == Register.DS) {
				op = Bitness >= 32 ? Code.Pushd_DS : Code.Pushw_DS;
			} else if (dst == Register.FS) {
				op = Bitness >= 32 ? Code.Pushd_FS : Code.Pushw_FS;
			} else if (dst == Register.GS) {
				op = Bitness >= 32 ? Code.Pushd_GS : Code.Pushw_GS;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(push)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Push_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Push_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Push_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(push)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Pushq_imm32;
			} else if (Bitness == 32) {
				op = Code.Pushd_imm32;
			} else {
				op = Code.Push_imm16;
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		public void pusha() {
			Code op;
			if (Bitness >= 32) {
				op = Code.Pushad;
			} else {
				op = Code.Pushaw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void pushf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Pushfq;
			} else if (Bitness == 32) {
				op = Code.Pushfd;
			} else {
				op = Code.Pushfw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void rcl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rcl_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rcl_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rcl_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rcl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcl_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcl_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcl_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcl(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rcl_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rcl_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rcl_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rcl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rcl_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rcl_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rcl_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rcl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rcl(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rcl_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rcl_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rcl_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rcl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcl_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcl_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcl_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rcr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rcr_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rcr_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rcr_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rcr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcr_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcr_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcr_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rcr(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rcr_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rcr_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rcr_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rcr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rcr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rcr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rcr_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rcr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rcr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rcr_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rcr_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rcr_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rcr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rcr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rcr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rcr_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rcr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rcr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rdmsr() {
			Code op;
			op = Code.Rdmsr;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpkru() {
			Code op;
			op = Code.Rdpkru;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpmc() {
			Code op;
			op = Code.Rdpmc;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpru() {
			Code op;
			op = Code.Rdpru;
			AddInstruction(Instruction.Create(op));
		}
		public void rdtsc() {
			Code op;
			op = Code.Rdtsc;
			AddInstruction(Instruction.Create(op));
		}
		public void rdtscp() {
			Code op;
			op = Code.Rdtscp;
			AddInstruction(Instruction.Create(op));
		}
		public void ret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Retnq;
			} else if (Bitness == 32) {
				op = Code.Retnd;
			} else {
				op = Code.Retnw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void ret(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Retnq_imm16;
			} else if (Bitness == 32) {
				op = Code.Retnd_imm16;
			} else {
				op = Code.Retnw_imm16;
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		public void retf() {
			Code op;
			if (Bitness == 64) {
				op = Code.Retfq;
			} else if (Bitness == 32) {
				op = Code.Retfd;
			} else {
				op = Code.Retfw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void retf(int imm) {
			Code op;
			if (Bitness == 64) {
				op = Code.Retfq_imm16;
			} else if (Bitness == 32) {
				op = Code.Retfd_imm16;
			} else {
				op = Code.Retfw_imm16;
			}
			AddInstruction(Instruction.Create(op, imm));
		}
		public void rol(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Rol_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Rol_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Rol_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Rol_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rol(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rol_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rol_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rol_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rol_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void rol(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Rol_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Rol_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Rol_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Rol_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Rol_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Rol_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Rol_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Rol_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rol(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Rol_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Rol_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Rol_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Rol_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Rol_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Rol_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Rol_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Rol_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(rol)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void ror(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ror_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Ror_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Ror_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Ror_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ror(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ror_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ror_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ror_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Ror_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ror(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Ror_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Ror_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Ror_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Ror_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Ror_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Ror_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Ror_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Ror_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void ror(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Ror_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Ror_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Ror_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Ror_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ror_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ror_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ror_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Ror_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ror)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void rsm() {
			Code op;
			op = Code.Rsm;
			AddInstruction(Instruction.Create(op));
		}
		public void sahf() {
			Code op;
			op = Code.Sahf;
			AddInstruction(Instruction.Create(op));
		}
		public void sal(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sal_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Sal_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Sal_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Sal_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sal(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sal_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sal_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sal_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sal_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sal(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Sal_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Sal_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Sal_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Sal_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Sal_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Sal_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Sal_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Sal_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sal(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sal_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sal_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sal_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sal_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sal_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sal_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sal_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sal_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sal)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void salc() {
			Code op;
			op = Code.Salc;
			AddInstruction(Instruction.Create(op));
		}
		public void sar(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sar_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Sar_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Sar_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Sar_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sar(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sar_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sar_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sar_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sar_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sar(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Sar_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Sar_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Sar_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Sar_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Sar_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Sar_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Sar_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Sar_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sar(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sar_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sar_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sar_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sar_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sar_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sar_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sar_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sar_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void saveprevssp() {
			Code op;
			op = Code.Saveprevssp;
			AddInstruction(Instruction.Create(op));
		}
		public void sbb(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sbb_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sbb_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sbb_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Sbb_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Sbb_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Sbb_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Sbb_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Sbb_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Sbb_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Sbb_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Sbb_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Sbb_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sbb(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sbb_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sbb_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sbb_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sbb_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sbb_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sbb_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sbb_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void scasb(Register dst) {
			Code op;
			if (dst == Register.AL) {
				op = Code.Scasb_AL_m8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(scasb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void scasd(Register dst) {
			Code op;
			if (dst == Register.EAX) {
				op = Code.Scasd_EAX_m32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(scasd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void scasq(Register dst) {
			Code op;
			if (dst == Register.RAX) {
				op = Code.Scasq_RAX_m64;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(scasq)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void scasw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Scasw_AX_m16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(scasw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seta(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Seta_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(seta)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seta(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Seta_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(seta)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setae(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setae_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setae(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setae_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setb(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setb_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setb(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setb_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setbe(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setbe_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setbe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setbe_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sete(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Sete_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sete)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sete(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sete_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sete)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setg(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setg_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setg_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setge(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setge_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setge(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setge_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setl(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setl_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setl(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setl_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setle(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setle_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setle(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setle_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setne(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setne_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setne(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setne_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setno(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setno_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setno(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setno_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setnp(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setnp_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setnp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setnp_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setns(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setns_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setns(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setns_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seto(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Seto_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(seto)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seto(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Seto_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(seto)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setp(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Setp_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setp_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(setp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sets(Register dst) {
			Code op;
			if (dst.IsGPR8()) {
				op = Code.Sets_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sets)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sets(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sets_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sets)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setssbsy() {
			Code op;
			op = Code.Setssbsy;
			AddInstruction(Instruction.Create(op));
		}
		public void sfence() {
			Code op;
			op = Code.Sfence;
			AddInstruction(Instruction.Create(op));
		}
		public void shl(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shl_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shl_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shl_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Shl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shl_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shl_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shl_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shl_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shl(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Shl_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Shl_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Shl_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Shl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Shl_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shl_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shl_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Shl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shl(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Shl_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Shl_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Shl_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Shl_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shl_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shl_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shl_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shl_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shld(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shld_rm64_r64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shld_rm32_r32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shld_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shld(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shld_rm64_r64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shld_rm32_r32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shld_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shld(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shld_rm64_r64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shld_rm32_r32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shld_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shld(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shld_rm64_r64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shld_rm32_r32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shld_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shld)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shr(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shr_rm64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shr_rm32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shr_rm16_CL;
			} else if (dst.IsGPR8()) {
				op = Code.Shr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shr_rm64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shr_rm32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shr_rm16_CL;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shr_rm8_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void shr(Register dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.IsGPR64()) {
					op = Code.Shr_rm64_1;
				} else if (dst.IsGPR32()) {
					op = Code.Shr_rm32_1;
				} else if (dst.IsGPR16()) {
					op = Code.Shr_rm16_1;
				} else if (dst.IsGPR8()) {
					op = Code.Shr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.IsGPR64()) {
				op = Code.Shr_rm64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shr_rm32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shr_rm16_imm8;
			} else if (dst.IsGPR8()) {
				op = Code.Shr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shr(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if (imm == 1) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Shr_rm64_1;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Shr_rm32_1;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Shr_rm16_1;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Shr_rm8_1;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shr_rm64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shr_rm32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shr_rm16_imm8;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Shr_rm8_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void shrd(Register dst, Register src, Register arg2) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shrd_rm64_r64_CL;
			} else if (dst.IsGPR32()) {
				op = Code.Shrd_rm32_r32_CL;
			} else if (dst.IsGPR16()) {
				op = Code.Shrd_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shrd(ExtendedMemoryOperand dst, Register src, Register arg2) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shrd_rm64_r64_CL;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shrd_rm32_r32_CL;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shrd_rm16_r16_CL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, arg2));
		}
		public void shrd(Register dst, Register src, int imm) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Shrd_rm64_r64_imm8;
			} else if (dst.IsGPR32()) {
				op = Code.Shrd_rm32_r32_imm8;
			} else if (dst.IsGPR16()) {
				op = Code.Shrd_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void shrd(ExtendedMemoryOperand dst, Register src, int imm) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Shrd_rm64_r64_imm8;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Shrd_rm32_r32_imm8;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Shrd_rm16_r16_imm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(shrd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src, imm));
		}
		public void skinit() {
			Code op;
			op = Code.Skinit;
			AddInstruction(Instruction.Create(op));
		}
		public void sldt(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Sldt_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sldt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sldt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sldt_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sldt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void smsw(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Smsw_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(smsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void smsw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Smsw_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(smsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void stac() {
			Code op;
			op = Code.Stac;
			AddInstruction(Instruction.Create(op));
		}
		public void stc() {
			Code op;
			op = Code.Stc;
			AddInstruction(Instruction.Create(op));
		}
		public void std() {
			Code op;
			op = Code.Std;
			AddInstruction(Instruction.Create(op));
		}
		public void stgi() {
			Code op;
			op = Code.Stgi;
			AddInstruction(Instruction.Create(op));
		}
		public void sti() {
			Code op;
			op = Code.Sti;
			AddInstruction(Instruction.Create(op));
		}
		public void stosb(Register src) {
			Code op;
			if (src == Register.AL) {
				op = Code.Stosb_m8_AL;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(stosb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void stosd(Register src) {
			Code op;
			if (src == Register.EAX) {
				op = Code.Stosd_m32_EAX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(stosd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void stosq(Register src) {
			Code op;
			if (src == Register.RAX) {
				op = Code.Stosq_m64_RAX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(stosq)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void stosw(Register src) {
			Code op;
			if (src == Register.AX) {
				op = Code.Stosw_m16_AX;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(stosw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, src));
		}
		public void str(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Str_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(str)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void str(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Str_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(str)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sub(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sub_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sub_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sub_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sub_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Sub_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Sub_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Sub_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Sub_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Sub_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Sub_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Sub_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Sub_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Sub_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void sub(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Sub_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Sub_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Sub_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Sub_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Sub_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Sub_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sub_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void swapgs() {
			Code op;
			op = Code.Swapgs;
			AddInstruction(Instruction.Create(op));
		}
		public void syscall() {
			Code op;
			op = Code.Syscall;
			AddInstruction(Instruction.Create(op));
		}
		public void sysenter() {
			Code op;
			op = Code.Sysenter;
			AddInstruction(Instruction.Create(op));
		}
		public void sysexit() {
			Code op;
			if (Bitness == 64) {
				op = Code.Sysexitq;
			} else {
				op = Code.Sysexitd;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void sysret() {
			Code op;
			if (Bitness == 64) {
				op = Code.Sysretq;
			} else {
				op = Code.Sysretd;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void test(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Test_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Test_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Test_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Test_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void test(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Test_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Test_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Test_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Test_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void test(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst == Register.AL) {
					op = Code.Test_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Test_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Test_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Test_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Test_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Test_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Test_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Test_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void test(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Test_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Test_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Test_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Test_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void tzcnt(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(tzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void tzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(tzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud0(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud0)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud0(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud0)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud1(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud1)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud1(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(ud1)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud2() {
			Code op;
			op = Code.Ud2;
			AddInstruction(Instruction.Create(op));
		}
		public void umov(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void umov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Umov_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Umov_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Umov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void umov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void verr(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Verr_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(verr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verr(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Verr_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(verr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verw(Register dst) {
			Code op;
			if (dst.IsGPR16()) {
				op = Code.Verw_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(verw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Verw_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(verw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void vmcall() {
			Code op;
			op = Code.Vmcall;
			AddInstruction(Instruction.Create(op));
		}
		public void vmfunc() {
			Code op;
			op = Code.Vmfunc;
			AddInstruction(Instruction.Create(op));
		}
		public void vmlaunch() {
			Code op;
			op = Code.Vmlaunch;
			AddInstruction(Instruction.Create(op));
		}
		public void vmload() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmloadq;
			} else if (Bitness == 32) {
				op = Code.Vmloadd;
			} else {
				op = Code.Vmloadw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void vmmcall() {
			Code op;
			op = Code.Vmmcall;
			AddInstruction(Instruction.Create(op));
		}
		public void vmread(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmread_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmread)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmread(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Vmread_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmread)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmresume() {
			Code op;
			op = Code.Vmresume;
			AddInstruction(Instruction.Create(op));
		}
		public void vmrun() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmrunq;
			} else if (Bitness == 32) {
				op = Code.Vmrund;
			} else {
				op = Code.Vmrunw;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void vmsave() {
			Code op;
			if (Bitness == 64) {
				op = Code.Vmsaveq;
			} else if (Bitness == 32) {
				op = Code.Vmsaved;
			} else {
				op = Code.Vmsavew;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void vmwrite(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmwrite(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(vmwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmxoff() {
			Code op;
			op = Code.Vmxoff;
			AddInstruction(Instruction.Create(op));
		}
		public void wait() {
			Code op;
			op = Code.Wait;
			AddInstruction(Instruction.Create(op));
		}
		public void wbinvd() {
			Code op;
			op = Code.Wbinvd;
			AddInstruction(Instruction.Create(op));
		}
		public void wbnoinvd() {
			Code op;
			op = Code.Wbnoinvd;
			AddInstruction(Instruction.Create(op));
		}
		public void wrmsr() {
			Code op;
			op = Code.Wrmsr;
			AddInstruction(Instruction.Create(op));
		}
		public void wrpkru() {
			Code op;
			op = Code.Wrpkru;
			AddInstruction(Instruction.Create(op));
		}
		public void xabort(int imm) {
			Code op;
			op = Code.Xabort_imm8;
			AddInstruction(Instruction.Create(op, imm));
		}
		public void xadd(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xadd_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Xadd_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Xadd_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xadd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xadd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xadd_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xadd_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xadd_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xadd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xbts(Register dst, Register src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xbts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xbts(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xbts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xchg(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64() && src == Register.RAX) {
				op = Code.Xchg_r64_RAX;
			} else if (dst.IsGPR64() && src.IsGPR64()) {
				op = Code.Xchg_rm64_r64;
			} else if (dst.IsGPR32() && src == Register.EAX) {
				op = Code.Xchg_r32_EAX;
			} else if (dst.IsGPR32() && src.IsGPR32()) {
				op = Code.Xchg_rm32_r32;
			} else if (dst.IsGPR16() && src == Register.AX) {
				op = Code.Xchg_r16_AX;
			} else if (dst.IsGPR16() && src.IsGPR16()) {
				op = Code.Xchg_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xchg_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xchg_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xchg_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xcryptcbc() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCbc_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCbc_32;
			} else {
				op = Code.XcryptCbc_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptcfb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCfb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCfb_32;
			} else {
				op = Code.XcryptCfb_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptctr() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptCtr_64;
			} else if (Bitness == 32) {
				op = Code.XcryptCtr_32;
			} else {
				op = Code.XcryptCtr_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptecb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptEcb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptEcb_32;
			} else {
				op = Code.XcryptEcb_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptofb() {
			Code op;
			if (Bitness == 64) {
				op = Code.XcryptOfb_64;
			} else if (Bitness == 32) {
				op = Code.XcryptOfb_32;
			} else {
				op = Code.XcryptOfb_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xend() {
			Code op;
			op = Code.Xend;
			AddInstruction(Instruction.Create(op));
		}
		public void xgetbv() {
			Code op;
			op = Code.Xgetbv;
			AddInstruction(Instruction.Create(op));
		}
		public void xor(Register dst, Register src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_rm64_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_rm32_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_rm16_r16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xor_rm64_r64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xor_rm32_r32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xor_rm16_r16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Xor_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(Register dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.IsGPR64()) {
					op = Code.Xor_rm64_imm8;
				} else if (dst.IsGPR32()) {
					op = Code.Xor_rm32_imm8;
				} else if (dst.IsGPR16()) {
					op = Code.Xor_rm16_imm8;
				} else if (dst == Register.AL) {
					op = Code.Xor_AL_imm8;
				} else if (dst.IsGPR8()) {
					op = Code.Xor_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst == Register.RAX) {
				op = Code.Xor_RAX_imm32;
			} else if (dst.IsGPR64()) {
				op = Code.Xor_rm64_imm32;
			} else if (dst == Register.EAX) {
				op = Code.Xor_EAX_imm32;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_rm32_imm32;
			} else if (dst == Register.AX) {
				op = Code.Xor_AX_imm16;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void xor(ExtendedMemoryOperand dst, int imm) {
			Code op;
			if ((uint)imm <= byte.MaxValue) {
				if (dst.Size == MemoryOperandSize.QwordPtr) {
					op = Code.Xor_rm64_imm8;
				} else if (dst.Size == MemoryOperandSize.DwordPtr) {
					op = Code.Xor_rm32_imm8;
				} else if (dst.Size == MemoryOperandSize.WordPtr) {
					op = Code.Xor_rm16_imm8;
				} else if (dst.Size == MemoryOperandSize.BytePtr) {
					op = Code.Xor_rm8_imm8;
				} else {
					throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
				}
			}
			else if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Xor_rm64_imm32;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Xor_rm32_imm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Xor_rm16_imm16;
			} else {
				throw new ArgumentException($"Invalid register for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, imm));
		}
		public void xsetbv() {
			Code op;
			op = Code.Xsetbv;
			AddInstruction(Instruction.Create(op));
		}
		public void xsha1() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xsha1_64;
			} else if (Bitness == 32) {
				op = Code.Xsha1_32;
			} else {
				op = Code.Xsha1_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xsha256() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xsha256_64;
			} else if (Bitness == 32) {
				op = Code.Xsha256_32;
			} else {
				op = Code.Xsha256_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xstore() {
			Code op;
			if (Bitness == 64) {
				op = Code.Xstore_64;
			} else if (Bitness == 32) {
				op = Code.Xstore_32;
			} else {
				op = Code.Xstore_16;
			}
			AddInstruction(Instruction.Create(op));
		}
		public void xtest() {
			Code op;
			op = Code.Xtest;
			AddInstruction(Instruction.Create(op));
		}
	}
}
#endif
