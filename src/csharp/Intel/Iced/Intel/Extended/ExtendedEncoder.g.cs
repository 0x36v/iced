/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#nullable enable

#if !NO_ENCODER
namespace Iced.Intel {
	using System;
	public sealed partial class ExtendedEncoder {
		public void aaa() {
			Code op;
			op = Code.Aaa;
			AddInstruction(Instruction.Create(op));
		}
		public void aas() {
			Code op;
			op = Code.Aas;
			AddInstruction(Instruction.Create(op));
		}
		public void adc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Adc_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Adc_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Adc_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Adc_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adc(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adc_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adc_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Adc_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Adc_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(adc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adcx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adcx_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adcx_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(adcx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Add_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Add_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Add_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Add_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void add(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Add_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Add_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Add_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Add_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(add)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void adox(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Adox_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Adox_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(adox)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.And_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.And_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.And_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.And_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void and(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.And_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.And_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.And_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.And_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(and)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void arpl(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR16()) {
				op = Code.Arpl_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(arpl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsf(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsf_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsf_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsf_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(bsf)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bsr(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bsr_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Bsr_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Bsr_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(bsr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bswap(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Bswap_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Bswap_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Bswap_r16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(bswap)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void bt(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Bt_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Bt_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Bt_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(bt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btc(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Btc_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Btc_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Btc_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(btc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void btr(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Btr_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Btr_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Btr_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(btr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void bts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Bts_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Bts_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Bts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(bts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void call(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Call_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Call_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Call_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(call)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void cbw() {
			Code op;
			op = Code.Cbw;
			AddInstruction(Instruction.Create(op));
		}
		public void cdq() {
			Code op;
			op = Code.Cdq;
			AddInstruction(Instruction.Create(op));
		}
		public void cdqe() {
			Code op;
			op = Code.Cdqe;
			AddInstruction(Instruction.Create(op));
		}
		public void cl1invmb() {
			Code op;
			op = Code.Cl1invmb;
			AddInstruction(Instruction.Create(op));
		}
		public void clac() {
			Code op;
			op = Code.Clac;
			AddInstruction(Instruction.Create(op));
		}
		public void clc() {
			Code op;
			op = Code.Clc;
			AddInstruction(Instruction.Create(op));
		}
		public void cld() {
			Code op;
			op = Code.Cld;
			AddInstruction(Instruction.Create(op));
		}
		public void clgi() {
			Code op;
			op = Code.Clgi;
			AddInstruction(Instruction.Create(op));
		}
		public void cli() {
			Code op;
			op = Code.Cli;
			AddInstruction(Instruction.Create(op));
		}
		public void clts() {
			Code op;
			op = Code.Clts;
			AddInstruction(Instruction.Create(op));
		}
		public void clzerod() {
			Code op;
			op = Code.Clzerod;
			AddInstruction(Instruction.Create(op));
		}
		public void clzeroq() {
			Code op;
			op = Code.Clzeroq;
			AddInstruction(Instruction.Create(op));
		}
		public void clzerow() {
			Code op;
			op = Code.Clzerow;
			AddInstruction(Instruction.Create(op));
		}
		public void cmc() {
			Code op;
			op = Code.Cmc;
			AddInstruction(Instruction.Create(op));
		}
		public void cmova(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmova_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmova_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmova_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmova)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovae(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovae_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovae_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovae_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovb_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovbe(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovbe_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovbe_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovbe_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmove(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmove_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmove_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmove_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmove)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovg(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovg_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovg_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovg_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovge(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovge_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovge_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovge_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovl_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovl_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovle(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovle_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovle_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovle_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovne(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovne_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovne_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovne_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovno(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovno_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovno_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovno_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovnp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovnp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovnp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovnp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovns(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovns_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovns_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovns_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovo(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovo_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovo_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovo_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovo)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovp_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmovs(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmovs_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmovs_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmovs_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmovs)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Cmp_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Cmp_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Cmp_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Cmp_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmp(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Cmp_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Cmp_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Cmp_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Cmp_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(cmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmpxchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Cmpxchg_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Cmpxchg_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Cmpxchg_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Cmpxchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(cmpxchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cmpxchg486(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR32()) {
				op = Code.Cmpxchg486_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Cmpxchg486_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Cmpxchg486_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(cmpxchg486)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cpuid() {
			Code op;
			op = Code.Cpuid;
			AddInstruction(Instruction.Create(op));
		}
		public void cqo() {
			Code op;
			op = Code.Cqo;
			AddInstruction(Instruction.Create(op));
		}
		public void crc32(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Crc32_r64_rm8;
			} else if (dst.IsGPR64()) {
				op = Code.Crc32_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Crc32_r32_rm8;
			} else if (dst.IsGPR32()) {
				op = Code.Crc32_r32_rm16;
			} else if (dst.IsGPR32()) {
				op = Code.Crc32_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(crc32)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void cwd() {
			Code op;
			op = Code.Cwd;
			AddInstruction(Instruction.Create(op));
		}
		public void cwde() {
			Code op;
			op = Code.Cwde;
			AddInstruction(Instruction.Create(op));
		}
		public void d3now() {
			Code op;
			op = Code.D3NOW_Pi2fw_mm_mmm64;
			AddInstruction(Instruction.Create(op));
		}
		public void daa() {
			Code op;
			op = Code.Daa;
			AddInstruction(Instruction.Create(op));
		}
		public void das() {
			Code op;
			op = Code.Das;
			AddInstruction(Instruction.Create(op));
		}
		public void dec(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Dec_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Dec_r16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(dec)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void dec(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Dec_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Dec_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Dec_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Dec_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(dec)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void declarebyte() {
			Code op;
			op = Code.DeclareByte;
			AddInstruction(Instruction.Create(op));
		}
		public void declaredword() {
			Code op;
			op = Code.DeclareDword;
			AddInstruction(Instruction.Create(op));
		}
		public void declareqword() {
			Code op;
			op = Code.DeclareQword;
			AddInstruction(Instruction.Create(op));
		}
		public void declareword() {
			Code op;
			op = Code.DeclareWord;
			AddInstruction(Instruction.Create(op));
		}
		public void div(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Div_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Div_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Div_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Div_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(div)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void emms() {
			Code op;
			op = Code.Emms;
			AddInstruction(Instruction.Create(op));
		}
		public void encls() {
			Code op;
			op = Code.Encls;
			AddInstruction(Instruction.Create(op));
		}
		public void enclu() {
			Code op;
			op = Code.Enclu;
			AddInstruction(Instruction.Create(op));
		}
		public void enclv() {
			Code op;
			op = Code.Enclv;
			AddInstruction(Instruction.Create(op));
		}
		public void endbr32() {
			Code op;
			op = Code.Endbr32;
			AddInstruction(Instruction.Create(op));
		}
		public void endbr64() {
			Code op;
			op = Code.Endbr64;
			AddInstruction(Instruction.Create(op));
		}
		public void evex() {
			Code op;
			op = Code.EVEX_Vmovups_xmm_k1z_xmmm128;
			AddInstruction(Instruction.Create(op));
		}
		public void f2xm1() {
			Code op;
			op = Code.F2xm1;
			AddInstruction(Instruction.Create(op));
		}
		public void fabs() {
			Code op;
			op = Code.Fabs;
			AddInstruction(Instruction.Create(op));
		}
		public void fchs() {
			Code op;
			op = Code.Fchs;
			AddInstruction(Instruction.Create(op));
		}
		public void fclex() {
			Code op;
			op = Code.Fclex;
			AddInstruction(Instruction.Create(op));
		}
		public void fcompp() {
			Code op;
			op = Code.Fcompp;
			AddInstruction(Instruction.Create(op));
		}
		public void fcos() {
			Code op;
			op = Code.Fcos;
			AddInstruction(Instruction.Create(op));
		}
		public void fdecstp() {
			Code op;
			op = Code.Fdecstp;
			AddInstruction(Instruction.Create(op));
		}
		public void fdisi() {
			Code op;
			op = Code.Fdisi;
			AddInstruction(Instruction.Create(op));
		}
		public void femms() {
			Code op;
			op = Code.Femms;
			AddInstruction(Instruction.Create(op));
		}
		public void feni() {
			Code op;
			op = Code.Feni;
			AddInstruction(Instruction.Create(op));
		}
		public void fincstp() {
			Code op;
			op = Code.Fincstp;
			AddInstruction(Instruction.Create(op));
		}
		public void finit() {
			Code op;
			op = Code.Finit;
			AddInstruction(Instruction.Create(op));
		}
		public void fld1() {
			Code op;
			op = Code.Fld1;
			AddInstruction(Instruction.Create(op));
		}
		public void fldl2e() {
			Code op;
			op = Code.Fldl2e;
			AddInstruction(Instruction.Create(op));
		}
		public void fldl2t() {
			Code op;
			op = Code.Fldl2t;
			AddInstruction(Instruction.Create(op));
		}
		public void fldlg2() {
			Code op;
			op = Code.Fldlg2;
			AddInstruction(Instruction.Create(op));
		}
		public void fldln2() {
			Code op;
			op = Code.Fldln2;
			AddInstruction(Instruction.Create(op));
		}
		public void fldpi() {
			Code op;
			op = Code.Fldpi;
			AddInstruction(Instruction.Create(op));
		}
		public void fldz() {
			Code op;
			op = Code.Fldz;
			AddInstruction(Instruction.Create(op));
		}
		public void fnclex() {
			Code op;
			op = Code.Fnclex;
			AddInstruction(Instruction.Create(op));
		}
		public void fndisi() {
			Code op;
			op = Code.Fndisi;
			AddInstruction(Instruction.Create(op));
		}
		public void fneni() {
			Code op;
			op = Code.Fneni;
			AddInstruction(Instruction.Create(op));
		}
		public void fninit() {
			Code op;
			op = Code.Fninit;
			AddInstruction(Instruction.Create(op));
		}
		public void fnop() {
			Code op;
			op = Code.Fnop;
			AddInstruction(Instruction.Create(op));
		}
		public void fnsetpm() {
			Code op;
			op = Code.Fnsetpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fnstsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fnstsw_AX;
			}
			 else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(fnstsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fpatan() {
			Code op;
			op = Code.Fpatan;
			AddInstruction(Instruction.Create(op));
		}
		public void fprem() {
			Code op;
			op = Code.Fprem;
			AddInstruction(Instruction.Create(op));
		}
		public void fprem1() {
			Code op;
			op = Code.Fprem1;
			AddInstruction(Instruction.Create(op));
		}
		public void fptan() {
			Code op;
			op = Code.Fptan;
			AddInstruction(Instruction.Create(op));
		}
		public void frndint() {
			Code op;
			op = Code.Frndint;
			AddInstruction(Instruction.Create(op));
		}
		public void frstpm() {
			Code op;
			op = Code.Frstpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fscale() {
			Code op;
			op = Code.Fscale;
			AddInstruction(Instruction.Create(op));
		}
		public void fsetpm() {
			Code op;
			op = Code.Fsetpm;
			AddInstruction(Instruction.Create(op));
		}
		public void fsin() {
			Code op;
			op = Code.Fsin;
			AddInstruction(Instruction.Create(op));
		}
		public void fsincos() {
			Code op;
			op = Code.Fsincos;
			AddInstruction(Instruction.Create(op));
		}
		public void fsqrt() {
			Code op;
			op = Code.Fsqrt;
			AddInstruction(Instruction.Create(op));
		}
		public void fstdw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstdw_AX;
			}
			 else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(fstdw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fstsg(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstsg_AX;
			}
			 else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(fstsg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void fstsw(Register dst) {
			Code op;
			if (dst == Register.AX) {
				op = Code.Fstsw_AX;
			}
			 else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(fstsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void ftst() {
			Code op;
			op = Code.Ftst;
			AddInstruction(Instruction.Create(op));
		}
		public void fucompp() {
			Code op;
			op = Code.Fucompp;
			AddInstruction(Instruction.Create(op));
		}
		public void fxam() {
			Code op;
			op = Code.Fxam;
			AddInstruction(Instruction.Create(op));
		}
		public void fxtract() {
			Code op;
			op = Code.Fxtract;
			AddInstruction(Instruction.Create(op));
		}
		public void fyl2x() {
			Code op;
			op = Code.Fyl2x;
			AddInstruction(Instruction.Create(op));
		}
		public void fyl2xp1() {
			Code op;
			op = Code.Fyl2xp1;
			AddInstruction(Instruction.Create(op));
		}
		public void getsec() {
			Code op;
			op = Code.Getsec;
			AddInstruction(Instruction.Create(op));
		}
		public void hlt() {
			Code op;
			op = Code.Hlt;
			AddInstruction(Instruction.Create(op));
		}
		public void ibts(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR32()) {
				op = Code.Ibts_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Ibts_rm16_r16;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(ibts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void idiv(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Idiv_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Idiv_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Idiv_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Idiv_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(idiv)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Imul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Imul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Imul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Imul_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void imul(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Imul_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Imul_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Imul_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(imul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void inc(Register dst) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Inc_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Inc_r16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(inc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void inc(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Inc_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Inc_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Inc_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Inc_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(inc)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void int1() {
			Code op;
			op = Code.Int1;
			AddInstruction(Instruction.Create(op));
		}
		public void int3() {
			Code op;
			op = Code.Int3;
			AddInstruction(Instruction.Create(op));
		}
		public void into() {
			Code op;
			op = Code.Into;
			AddInstruction(Instruction.Create(op));
		}
		public void invalid() {
			Code op;
			op = Code.INVALID;
			AddInstruction(Instruction.Create(op));
		}
		public void invd() {
			Code op;
			op = Code.Invd;
			AddInstruction(Instruction.Create(op));
		}
		public void invlpgad() {
			Code op;
			op = Code.Invlpgad;
			AddInstruction(Instruction.Create(op));
		}
		public void invlpgaq() {
			Code op;
			op = Code.Invlpgaq;
			AddInstruction(Instruction.Create(op));
		}
		public void invlpgaw() {
			Code op;
			op = Code.Invlpgaw;
			AddInstruction(Instruction.Create(op));
		}
		public void iretd() {
			Code op;
			op = Code.Iretd;
			AddInstruction(Instruction.Create(op));
		}
		public void iretq() {
			Code op;
			op = Code.Iretq;
			AddInstruction(Instruction.Create(op));
		}
		public void iretw() {
			Code op;
			op = Code.Iretw;
			AddInstruction(Instruction.Create(op));
		}
		public void jmp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Jmp_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmp_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmp_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(jmp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void jmpe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Jmpe_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Jmpe_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(jmpe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lahf() {
			Code op;
			op = Code.Lahf;
			AddInstruction(Instruction.Create(op));
		}
		public void lar(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lar_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lar_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lar_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(lar)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void leaved() {
			Code op;
			op = Code.Leaved;
			AddInstruction(Instruction.Create(op));
		}
		public void leaveq() {
			Code op;
			op = Code.Leaveq;
			AddInstruction(Instruction.Create(op));
		}
		public void leavew() {
			Code op;
			op = Code.Leavew;
			AddInstruction(Instruction.Create(op));
		}
		public void lfence() {
			Code op;
			op = Code.Lfence;
			AddInstruction(Instruction.Create(op));
		}
		public void lldt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Lldt_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(lldt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lmsw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Lmsw_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(lmsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void loadall286() {
			Code op;
			op = Code.Loadall286;
			AddInstruction(Instruction.Create(op));
		}
		public void loadall386() {
			Code op;
			op = Code.Loadall386;
			AddInstruction(Instruction.Create(op));
		}
		public void loadallreset286() {
			Code op;
			op = Code.Loadallreset286;
			AddInstruction(Instruction.Create(op));
		}
		public void lsl(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lsl_r64_r64m16;
			} else if (dst.IsGPR32()) {
				op = Code.Lsl_r32_r32m16;
			} else if (dst.IsGPR16()) {
				op = Code.Lsl_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(lsl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ltr(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Ltr_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(ltr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void lzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Lzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Lzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Lzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(lzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mcommit() {
			Code op;
			op = Code.Mcommit;
			AddInstruction(Instruction.Create(op));
		}
		public void mfence() {
			Code op;
			op = Code.Mfence;
			AddInstruction(Instruction.Create(op));
		}
		public void monitord() {
			Code op;
			op = Code.Monitord;
			AddInstruction(Instruction.Create(op));
		}
		public void monitorq() {
			Code op;
			op = Code.Monitorq;
			AddInstruction(Instruction.Create(op));
		}
		public void monitorw() {
			Code op;
			op = Code.Monitorw;
			AddInstruction(Instruction.Create(op));
		}
		public void monitorxd() {
			Code op;
			op = Code.Monitorxd;
			AddInstruction(Instruction.Create(op));
		}
		public void monitorxq() {
			Code op;
			op = Code.Monitorxq;
			AddInstruction(Instruction.Create(op));
		}
		public void monitorxw() {
			Code op;
			op = Code.Monitorxw;
			AddInstruction(Instruction.Create(op));
		}
		public void montmul() {
			Code op;
			op = Code.Montmul_16;
			AddInstruction(Instruction.Create(op));
		}
		public void mov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Mov_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Mov_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Mov_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Mov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Mov_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Mov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Mov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Mov_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(mov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsx_r64_rm8;
			} else if (dst.IsGPR64()) {
				op = Code.Movsx_r64_rm16;
			} else if (dst.IsGPR32()) {
				op = Code.Movsx_r32_rm8;
			} else if (dst.IsGPR32()) {
				op = Code.Movsx_r32_rm16;
			} else if (dst.IsGPR16()) {
				op = Code.Movsx_r16_rm8;
			} else if (dst.IsGPR16()) {
				op = Code.Movsx_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(movsx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movsxd(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movsxd_r64_rm32;
			} else if (dst.IsGPR32()) {
				op = Code.Movsxd_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Movsxd_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(movsxd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void movzx(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Movzx_r64_rm8;
			} else if (dst.IsGPR64()) {
				op = Code.Movzx_r64_rm16;
			} else if (dst.IsGPR32()) {
				op = Code.Movzx_r32_rm8;
			} else if (dst.IsGPR32()) {
				op = Code.Movzx_r32_rm16;
			} else if (dst.IsGPR16()) {
				op = Code.Movzx_r16_rm8;
			} else if (dst.IsGPR16()) {
				op = Code.Movzx_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(movzx)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void mul(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Mul_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Mul_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Mul_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Mul_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(mul)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void mwait() {
			Code op;
			op = Code.Mwait;
			AddInstruction(Instruction.Create(op));
		}
		public void mwaitx() {
			Code op;
			op = Code.Mwaitx;
			AddInstruction(Instruction.Create(op));
		}
		public void neg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Neg_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Neg_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Neg_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Neg_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(neg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void nop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Nop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Nop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Nop_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(nop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void nopd() {
			Code op;
			op = Code.Nopd;
			AddInstruction(Instruction.Create(op));
		}
		public void nopq() {
			Code op;
			op = Code.Nopq;
			AddInstruction(Instruction.Create(op));
		}
		public void nopw() {
			Code op;
			op = Code.Nopw;
			AddInstruction(Instruction.Create(op));
		}
		public void not(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Not_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Not_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Not_rm16;
			} else if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Not_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(not)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void or(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Or_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Or_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Or_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Or_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void or(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Or_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Or_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Or_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Or_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(or)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void pause() {
			Code op;
			op = Code.Pause;
			AddInstruction(Instruction.Create(op));
		}
		public void pcommit() {
			Code op;
			op = Code.Pcommit;
			AddInstruction(Instruction.Create(op));
		}
		public void pconfig() {
			Code op;
			op = Code.Pconfig;
			AddInstruction(Instruction.Create(op));
		}
		public void pop(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Pop_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Pop_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Pop_r16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(pop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void pop(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Pop_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Pop_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Pop_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(pop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void popad() {
			Code op;
			op = Code.Popad;
			AddInstruction(Instruction.Create(op));
		}
		public void popaw() {
			Code op;
			op = Code.Popaw;
			AddInstruction(Instruction.Create(op));
		}
		public void popcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Popcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Popcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Popcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(popcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void popfd() {
			Code op;
			op = Code.Popfd;
			AddInstruction(Instruction.Create(op));
		}
		public void popfq() {
			Code op;
			op = Code.Popfq;
			AddInstruction(Instruction.Create(op));
		}
		public void popfw() {
			Code op;
			op = Code.Popfw;
			AddInstruction(Instruction.Create(op));
		}
		public void ptwrite(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Ptwrite_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Ptwrite_rm32;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(ptwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(Register dst) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Push_r64;
			} else if (dst.IsGPR32()) {
				op = Code.Push_r32;
			} else if (dst.IsGPR16()) {
				op = Code.Push_r16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(push)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void push(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.QwordPtr) {
				op = Code.Push_rm64;
			} else if (dst.Size == MemoryOperandSize.DwordPtr) {
				op = Code.Push_rm32;
			} else if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Push_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(push)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void pushad() {
			Code op;
			op = Code.Pushad;
			AddInstruction(Instruction.Create(op));
		}
		public void pushaw() {
			Code op;
			op = Code.Pushaw;
			AddInstruction(Instruction.Create(op));
		}
		public void pushfd() {
			Code op;
			op = Code.Pushfd;
			AddInstruction(Instruction.Create(op));
		}
		public void pushfq() {
			Code op;
			op = Code.Pushfq;
			AddInstruction(Instruction.Create(op));
		}
		public void pushfw() {
			Code op;
			op = Code.Pushfw;
			AddInstruction(Instruction.Create(op));
		}
		public void rdmsr() {
			Code op;
			op = Code.Rdmsr;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpkru() {
			Code op;
			op = Code.Rdpkru;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpmc() {
			Code op;
			op = Code.Rdpmc;
			AddInstruction(Instruction.Create(op));
		}
		public void rdpru() {
			Code op;
			op = Code.Rdpru;
			AddInstruction(Instruction.Create(op));
		}
		public void rdtsc() {
			Code op;
			op = Code.Rdtsc;
			AddInstruction(Instruction.Create(op));
		}
		public void rdtscp() {
			Code op;
			op = Code.Rdtscp;
			AddInstruction(Instruction.Create(op));
		}
		public void reservednop(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F1F;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F1E;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F0D;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F1D;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F18;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F1C;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F19;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F1B;
			} else if (src.IsGPR64()) {
				op = Code.ReservedNop_rm64_r64_0F1A;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F1E;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F1D;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F1C;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F1F;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F1B;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F1A;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F19;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F18;
			} else if (src.IsGPR32()) {
				op = Code.ReservedNop_rm32_r32_0F0D;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F1C;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F1A;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F1D;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F19;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F1E;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F18;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F1F;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F1B;
			} else if (src.IsGPR16()) {
				op = Code.ReservedNop_rm16_r16_0F0D;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(reservednop)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void retfd() {
			Code op;
			op = Code.Retfd;
			AddInstruction(Instruction.Create(op));
		}
		public void retfq() {
			Code op;
			op = Code.Retfq;
			AddInstruction(Instruction.Create(op));
		}
		public void retfw() {
			Code op;
			op = Code.Retfw;
			AddInstruction(Instruction.Create(op));
		}
		public void retnd() {
			Code op;
			op = Code.Retnd;
			AddInstruction(Instruction.Create(op));
		}
		public void retnq() {
			Code op;
			op = Code.Retnq;
			AddInstruction(Instruction.Create(op));
		}
		public void retnw() {
			Code op;
			op = Code.Retnw;
			AddInstruction(Instruction.Create(op));
		}
		public void rsm() {
			Code op;
			op = Code.Rsm;
			AddInstruction(Instruction.Create(op));
		}
		public void sahf() {
			Code op;
			op = Code.Sahf;
			AddInstruction(Instruction.Create(op));
		}
		public void salc() {
			Code op;
			op = Code.Salc;
			AddInstruction(Instruction.Create(op));
		}
		public void saveprevssp() {
			Code op;
			op = Code.Saveprevssp;
			AddInstruction(Instruction.Create(op));
		}
		public void sbb(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Sbb_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Sbb_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Sbb_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Sbb_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sbb(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sbb_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sbb_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sbb_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sbb_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(sbb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void seta(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Seta_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(seta)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setae(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setae_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setae)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setb(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setb_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setb)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setbe(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setbe_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setbe)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sete(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sete_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(sete)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setg(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setg_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setge(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setge_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setge)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setl(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setl_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setl)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setle(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setle_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setle)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setne(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setne_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setne)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setno(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setno_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setno)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setnp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setnp_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setnp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setns(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setns_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setns)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void seto(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Seto_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(seto)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setp(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Setp_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(setp)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sets(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.BytePtr) {
				op = Code.Sets_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(sets)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void setssbsy() {
			Code op;
			op = Code.Setssbsy;
			AddInstruction(Instruction.Create(op));
		}
		public void sfence() {
			Code op;
			op = Code.Sfence;
			AddInstruction(Instruction.Create(op));
		}
		public void skinit() {
			Code op;
			op = Code.Skinit;
			AddInstruction(Instruction.Create(op));
		}
		public void sldt(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Sldt_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(sldt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void smsw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Smsw_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(smsw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void stac() {
			Code op;
			op = Code.Stac;
			AddInstruction(Instruction.Create(op));
		}
		public void stc() {
			Code op;
			op = Code.Stc;
			AddInstruction(Instruction.Create(op));
		}
		public void std() {
			Code op;
			op = Code.Std;
			AddInstruction(Instruction.Create(op));
		}
		public void stgi() {
			Code op;
			op = Code.Stgi;
			AddInstruction(Instruction.Create(op));
		}
		public void sti() {
			Code op;
			op = Code.Sti;
			AddInstruction(Instruction.Create(op));
		}
		public void str(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Str_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(str)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void sub(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Sub_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Sub_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Sub_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Sub_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void sub(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Sub_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Sub_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Sub_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Sub_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(sub)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void swapgs() {
			Code op;
			op = Code.Swapgs;
			AddInstruction(Instruction.Create(op));
		}
		public void syscall() {
			Code op;
			op = Code.Syscall;
			AddInstruction(Instruction.Create(op));
		}
		public void sysenter() {
			Code op;
			op = Code.Sysenter;
			AddInstruction(Instruction.Create(op));
		}
		public void sysexitd() {
			Code op;
			op = Code.Sysexitd;
			AddInstruction(Instruction.Create(op));
		}
		public void sysexitq() {
			Code op;
			op = Code.Sysexitq;
			AddInstruction(Instruction.Create(op));
		}
		public void sysretd() {
			Code op;
			op = Code.Sysretd;
			AddInstruction(Instruction.Create(op));
		}
		public void sysretq() {
			Code op;
			op = Code.Sysretq;
			AddInstruction(Instruction.Create(op));
		}
		public void test(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Test_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Test_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Test_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Test_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(test)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void tzcnt(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Tzcnt_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Tzcnt_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Tzcnt_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(tzcnt)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud0(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud0_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud0_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud0_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(ud0)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud1(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Ud1_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Ud1_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Ud1_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(ud1)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void ud2() {
			Code op;
			op = Code.Ud2;
			AddInstruction(Instruction.Create(op));
		}
		public void umov(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR32()) {
				op = Code.Umov_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Umov_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Umov_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void umov(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Umov_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Umov_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Umov_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(umov)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void verr(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Verr_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(verr)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void verw(ExtendedMemoryOperand dst) {
			Code op;
			if (dst.Size == MemoryOperandSize.WordPtr) {
				op = Code.Verw_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(verw)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst));
		}
		public void vex() {
			Code op;
			op = Code.VEX_Vmovups_xmm_xmmm128;
			AddInstruction(Instruction.Create(op));
		}
		public void vmcall() {
			Code op;
			op = Code.Vmcall;
			AddInstruction(Instruction.Create(op));
		}
		public void vmfunc() {
			Code op;
			op = Code.Vmfunc;
			AddInstruction(Instruction.Create(op));
		}
		public void vmlaunch() {
			Code op;
			op = Code.Vmlaunch;
			AddInstruction(Instruction.Create(op));
		}
		public void vmloadd() {
			Code op;
			op = Code.Vmloadd;
			AddInstruction(Instruction.Create(op));
		}
		public void vmloadq() {
			Code op;
			op = Code.Vmloadq;
			AddInstruction(Instruction.Create(op));
		}
		public void vmloadw() {
			Code op;
			op = Code.Vmloadw;
			AddInstruction(Instruction.Create(op));
		}
		public void vmmcall() {
			Code op;
			op = Code.Vmmcall;
			AddInstruction(Instruction.Create(op));
		}
		public void vmread(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Vmread_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Vmread_rm32_r32;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(vmread)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmresume() {
			Code op;
			op = Code.Vmresume;
			AddInstruction(Instruction.Create(op));
		}
		public void vmrund() {
			Code op;
			op = Code.Vmrund;
			AddInstruction(Instruction.Create(op));
		}
		public void vmrunq() {
			Code op;
			op = Code.Vmrunq;
			AddInstruction(Instruction.Create(op));
		}
		public void vmrunw() {
			Code op;
			op = Code.Vmrunw;
			AddInstruction(Instruction.Create(op));
		}
		public void vmsaved() {
			Code op;
			op = Code.Vmsaved;
			AddInstruction(Instruction.Create(op));
		}
		public void vmsaveq() {
			Code op;
			op = Code.Vmsaveq;
			AddInstruction(Instruction.Create(op));
		}
		public void vmsavew() {
			Code op;
			op = Code.Vmsavew;
			AddInstruction(Instruction.Create(op));
		}
		public void vmwrite(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Vmwrite_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Vmwrite_r32_rm32;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(vmwrite)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void vmxoff() {
			Code op;
			op = Code.Vmxoff;
			AddInstruction(Instruction.Create(op));
		}
		public void wait() {
			Code op;
			op = Code.Wait;
			AddInstruction(Instruction.Create(op));
		}
		public void wbinvd() {
			Code op;
			op = Code.Wbinvd;
			AddInstruction(Instruction.Create(op));
		}
		public void wbnoinvd() {
			Code op;
			op = Code.Wbnoinvd;
			AddInstruction(Instruction.Create(op));
		}
		public void wrmsr() {
			Code op;
			op = Code.Wrmsr;
			AddInstruction(Instruction.Create(op));
		}
		public void wrpkru() {
			Code op;
			op = Code.Wrpkru;
			AddInstruction(Instruction.Create(op));
		}
		public void xadd(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Xadd_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Xadd_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Xadd_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Xadd_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(xadd)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xbts(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR32()) {
				op = Code.Xbts_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xbts_r16_rm16;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(xbts)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xchg(Register dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Xchg_r64_RAX;
			} else if (src.IsGPR32()) {
				op = Code.Xchg_r32_EAX;
			} else if (src.IsGPR16()) {
				op = Code.Xchg_r16_AX;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(xchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xchg(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Xchg_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Xchg_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Xchg_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Xchg_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(xchg)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xcryptcbc() {
			Code op;
			op = Code.XcryptCbc_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptcfb() {
			Code op;
			op = Code.XcryptCfb_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptctr() {
			Code op;
			op = Code.XcryptCtr_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptecb() {
			Code op;
			op = Code.XcryptEcb_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xcryptofb() {
			Code op;
			op = Code.XcryptOfb_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xend() {
			Code op;
			op = Code.Xend;
			AddInstruction(Instruction.Create(op));
		}
		public void xgetbv() {
			Code op;
			op = Code.Xgetbv;
			AddInstruction(Instruction.Create(op));
		}
		public void xop() {
			Code op;
			op = Code.XOP_Vpmacssww_xmm_xmm_xmmm128_xmm;
			AddInstruction(Instruction.Create(op));
		}
		public void xor(ExtendedMemoryOperand dst, Register src) {
			Code op;
			if (src.IsGPR64()) {
				op = Code.Xor_rm64_r64;
			} else if (src.IsGPR32()) {
				op = Code.Xor_rm32_r32;
			} else if (src.IsGPR16()) {
				op = Code.Xor_rm16_r16;
			} else if (src.IsGPR8()) {
				op = Code.Xor_rm8_r8;
			} else {
				throw new ArgumentException($"Invalid register `{src}` for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xor(Register dst, ExtendedMemoryOperand src) {
			Code op;
			if (dst.IsGPR64()) {
				op = Code.Xor_r64_rm64;
			} else if (dst.IsGPR32()) {
				op = Code.Xor_r32_rm32;
			} else if (dst.IsGPR16()) {
				op = Code.Xor_r16_rm16;
			} else if (dst.IsGPR8()) {
				op = Code.Xor_r8_rm8;
			} else {
				throw new ArgumentException($"Invalid register `{dst}` for `{nameof(xor)}` instruction. Expecting 16/32/64");
			}
			AddInstruction(Instruction.Create(op, dst, src));
		}
		public void xsetbv() {
			Code op;
			op = Code.Xsetbv;
			AddInstruction(Instruction.Create(op));
		}
		public void xsha1() {
			Code op;
			op = Code.Xsha1_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xsha256() {
			Code op;
			op = Code.Xsha256_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xstore() {
			Code op;
			op = Code.Xstore_16;
			AddInstruction(Instruction.Create(op));
		}
		public void xtest() {
			Code op;
			op = Code.Xtest;
			AddInstruction(Instruction.Create(op));
		}
	}
}
#endif
