/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

use wasm_bindgen::prelude::*;

// GENERATOR-BEGIN: Enum
// ⚠️This was generated by GENERATOR!🦹‍♂️
/// Operand kind
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum OpCodeOperandKind {
	/// No operand
	None,
	/// Far branch 16-bit offset, 16-bit segment/selector
	farbr2_2,
	/// Far branch 32-bit offset, 16-bit segment/selector
	farbr4_2,
	/// Memory offset without a modrm byte (eg. `MOV AL,[offset]`)
	mem_offs,
	/// Memory (modrm)
	mem,
	/// Memory (modrm), MPX:
	///
	/// 16/32-bit mode: must be 32-bit addressing
	///
	/// 64-bit mode: 64-bit addressing is forced
	mem_mpx,
	/// Memory (modrm), MPX:
	///
	/// 16/32-bit mode: must be 32-bit addressing
	///
	/// 64-bit mode: 64-bit addressing is forced and must not be RIP relative
	mem_mib,
	/// Memory (modrm), vsib32, xmm registers
	mem_vsib32x,
	/// Memory (modrm), vsib64, xmm registers
	mem_vsib64x,
	/// Memory (modrm), vsib32, ymm registers
	mem_vsib32y,
	/// Memory (modrm), vsib64, ymm registers
	mem_vsib64y,
	/// Memory (modrm), vsib32, zmm registers
	mem_vsib32z,
	/// Memory (modrm), vsib64, zmm registers
	mem_vsib64z,
	/// 8-bit GPR or memory
	r8_or_mem,
	/// 16-bit GPR or memory
	r16_or_mem,
	/// 32-bit GPR or memory
	r32_or_mem,
	/// 32-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	r32_or_mem_mpx,
	/// 64-bit GPR or memory
	r64_or_mem,
	/// 64-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	r64_or_mem_mpx,
	/// MM register or memory
	mm_or_mem,
	/// XMM register or memory
	xmm_or_mem,
	/// YMM register or memory
	ymm_or_mem,
	/// ZMM register or memory
	zmm_or_mem,
	/// BND register or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	bnd_or_mem_mpx,
	/// K register or memory
	k_or_mem,
	/// 8-bit GPR encoded in the `reg` field of the modrm byte
	r8_reg,
	/// 8-bit GPR encoded in the low 3 bits of the opcode
	r8_opcode,
	/// 16-bit GPR encoded in the `reg` field of the modrm byte
	r16_reg,
	/// 16-bit GPR encoded in the `reg` field of the modrm byte. This is a memory operand and it uses the address size prefix (`67h`) not the operand size prefix (`66h`).
	r16_reg_mem,
	/// 16-bit GPR encoded in the `mod + r/m` fields of the modrm byte
	r16_rm,
	/// 16-bit GPR encoded in the low 3 bits of the opcode
	r16_opcode,
	/// 32-bit GPR encoded in the `reg` field of the modrm byte
	r32_reg,
	/// 32-bit GPR encoded in the `reg` field of the modrm byte. This is a memory operand and it uses the address size prefix (`67h`) not the operand size prefix (`66h`).
	r32_reg_mem,
	/// 32-bit GPR encoded in the `mod + r/m` fields of the modrm byte
	r32_rm,
	/// 32-bit GPR encoded in the low 3 bits of the opcode
	r32_opcode,
	/// 32-bit GPR encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	r32_vvvv,
	/// 64-bit GPR encoded in the `reg` field of the modrm byte
	r64_reg,
	/// 64-bit GPR encoded in the `reg` field of the modrm byte. This is a memory operand and it uses the address size prefix (`67h`) not the operand size prefix (`66h`).
	r64_reg_mem,
	/// 64-bit GPR encoded in the `mod + r/m` fields of the modrm byte
	r64_rm,
	/// 64-bit GPR encoded in the low 3 bits of the opcode
	r64_opcode,
	/// 64-bit GPR encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	r64_vvvv,
	/// Segment register encoded in the `reg` field of the modrm byte
	seg_reg,
	/// K register encoded in the `reg` field of the modrm byte
	k_reg,
	/// K register (+1) encoded in the `reg` field of the modrm byte
	kp1_reg,
	/// K register encoded in the `mod + r/m` fields of the modrm byte
	k_rm,
	/// K register encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	k_vvvv,
	/// MM register encoded in the `reg` field of the modrm byte
	mm_reg,
	/// MM register encoded in the `mod + r/m` fields of the modrm byte
	mm_rm,
	/// XMM register encoded in the `reg` field of the modrm byte
	xmm_reg,
	/// XMM register encoded in the `mod + r/m` fields of the modrm byte
	xmm_rm,
	/// XMM register encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	xmm_vvvv,
	/// XMM register (+3) encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	xmmp3_vvvv,
	/// XMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only XMM0-XMM15)
	xmm_is4,
	/// XMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only XMM0-XMM15)
	xmm_is5,
	/// YMM register encoded in the `reg` field of the modrm byte
	ymm_reg,
	/// YMM register encoded in the `mod + r/m` fields of the modrm byte
	ymm_rm,
	/// YMM register encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	ymm_vvvv,
	/// YMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only YMM0-YMM15)
	ymm_is4,
	/// YMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only YMM0-YMM15)
	ymm_is5,
	/// ZMM register encoded in the `reg` field of the modrm byte
	zmm_reg,
	/// ZMM register encoded in the `mod + r/m` fields of the modrm byte
	zmm_rm,
	/// ZMM register encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	zmm_vvvv,
	/// ZMM register (+3) encoded in the the `V'vvvv` field (VEX/EVEX/XOP)
	zmmp3_vvvv,
	/// CR register encoded in the `reg` field of the modrm byte
	cr_reg,
	/// DR register encoded in the `reg` field of the modrm byte
	dr_reg,
	/// TR register encoded in the `reg` field of the modrm byte
	tr_reg,
	/// BND register encoded in the `reg` field of the modrm byte
	bnd_reg,
	/// ES register
	es,
	/// CS register
	cs,
	/// SS register
	ss,
	/// DS register
	ds,
	/// FS register
	fs,
	/// GS register
	gs,
	/// AL register
	al,
	/// CL register
	cl,
	/// AX register
	ax,
	/// DX register
	dx,
	/// EAX register
	eax,
	/// RAX register
	rax,
	/// ST0 register
	st0,
	/// ST(i) register encoded in the low 3 bits of the opcode
	sti_opcode,
	/// 2-bit immediate (m2z field, low 2 bits of the /is5 immediate, eg. `VPERMIL2PS`)
	imm2_m2z,
	/// 8-bit immediate
	imm8,
	/// Constant 1 (8-bit immediate)
	imm8_const_1,
	/// 8-bit immediate sign extended to 16 bits
	imm8sex16,
	/// 8-bit immediate sign extended to 32 bits
	imm8sex32,
	/// 8-bit immediate sign extended to 64 bits
	imm8sex64,
	/// 16-bit immediate
	imm16,
	/// 32-bit immediate
	imm32,
	/// 32-bit immediate sign extended to 64 bits
	imm32sex64,
	/// 64-bit immediate
	imm64,
	/// `seg:[rSI]` memory operand (string instructions)
	seg_rSI,
	/// `es:[rDI]` memory operand (string instructions)
	es_rDI,
	/// `seg:[rDI]` memory operand (`(V)MASKMOVQ` instructions)
	seg_rDI,
	/// `seg:[rBX+al]` memory operand (`XLATB` instruction)
	seg_rBX_al,
	/// 16-bit branch, 1-byte signed relative offset
	br16_1,
	/// 32-bit branch, 1-byte signed relative offset
	br32_1,
	/// 64-bit branch, 1-byte signed relative offset
	br64_1,
	/// 16-bit branch, 2-byte signed relative offset
	br16_2,
	/// 32-bit branch, 4-byte signed relative offset
	br32_4,
	/// 64-bit branch, 4-byte signed relative offset
	br64_4,
	/// `XBEGIN`, 2-byte signed relative offset
	xbegin_2,
	/// `XBEGIN`, 4-byte signed relative offset
	xbegin_4,
	/// 2-byte branch offset (`JMPE` instruction)
	brdisp_2,
	/// 4-byte branch offset (`JMPE` instruction)
	brdisp_4,
}
// GENERATOR-END: Enum

#[allow(dead_code)]
pub(crate) fn iced_to_op_code_operand_kind(value: iced_x86::OpCodeOperandKind) -> OpCodeOperandKind {
	// Safe, the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}
